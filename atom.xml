<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="https://goupos.top/atom.xml" rel="self"/>
  
  <link href="https://goupos.top/"/>
  <updated>2023-11-06T09:00:27.726Z</updated>
  <id>https://goupos.top/</id>
  
  <author>
    <name>构造</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++学习笔记0</title>
    <link href="https://goupos.top/2023/11/06/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
    <id>https://goupos.top/2023/11/06/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</id>
    <published>2023-11-06T00:49:23.000Z</published>
    <updated>2023-11-06T09:00:27.726Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h4>]]></content>
    
    
    <summary type="html">C++学习笔记0</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记2</title>
    <link href="https://goupos.top/2023/11/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://goupos.top/2023/11/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</id>
    <published>2023-11-05T14:16:50.000Z</published>
    <updated>2023-11-11T20:01:33.876Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-类模板-模板类与友元"><a href="#1-类模板-模板类与友元" class="headerlink" title="1. 类模板-模板类与友元"></a>1. 类模板-模板类与友元</h4><p>模板类的友元函数有三类：<br>1）非模板友元:友元函数不是模板函数，而是利用模板类参数生成的函数。只能在类中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">friend void show(AA&lt;T1, T2&gt;&amp; a)//编译器利用模板参数生成了友元函数，但是，这个函数不是模板函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;show(AA&lt;T1, T2&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译器会利用友元函数模板生成实例，和下面这些代码冲突了，所以出现了重定义</span><br><span class="line">//函数模板具体化</span><br><span class="line">//friend void show(AA&lt;int, string&gt;&amp; a);//这样就很麻烦了，要为每一个类型创建一个友元函数</span><br><span class="line">//friend void show(AA&lt;char, string&gt;&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA&lt;int, string&gt; aa_1(8,&quot;我是一只快乐鸟&quot;);</span><br><span class="line"></span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;x= &quot; &lt;&lt; aa_1.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; aa_1.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//void show(AA&lt;int,string&gt;&amp; a)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot;show(AA&lt;int,string&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//void show(AA&lt;char, string&gt;&amp; a)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot;show(AA&lt;char, string&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_2(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line">AA&lt;char, string&gt; aa_3(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line">AA&lt;double, string&gt; aa_4(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line"></span><br><span class="line">show();</span><br><span class="line">show(aa_2);</span><br><span class="line">show(aa_3);</span><br><span class="line">show(aa_4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案的本质是：编译器利用模板参数帮我生成了友元函数。方便使用，注意：编译器利用模板参数生成了友元函数，但是，这个函数不是模板函数，而是友元函数实体<br>这样对我们写程序有什么影响：如果我们想为某种数据类型创建特别版本的友元函数（具体化）这种方法是无法做到，用该方法生成的友元函数只能用于这个模板类，不能用于其他的模板类.</p><p>2）约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。(最好的友元函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T&amp; a);//第一步：在模板类的定义前面声明友元函数模板</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)//通用类型函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)//具体化函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好的友元方案，该方案的友元函数是函数模板，为模板设置友元分三个步骤<br>第一步：在模板类的定义前面，声明友元函数模板；目的是为了让模板类AA知道友元函数模板的存在<br>第二步：在模板类中再次声明友元函数模板；目的是让编译知道需要实例化的友元函数模板 ，类模板与函数模板本来是没有关系的，如下（1）代码让他们有关系,编译器在实例化某种数据类型的模板类时，也会实例化这种数据类型的模板函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1) friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);</span><br></pre></td></tr></table></figure><p>第三步：友元函数模板的定义，放在模板类的下面;因为友元函数是函数模板，可以有具体化的版本。</p><p>这种友元的函数模板可以用于多个模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)//通用类型函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T&amp; a);//第一步：在模板类的定义前面声明友元函数模板</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(BB&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~BB() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(BB&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">BB&lt;int, string&gt; bb_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(bb_1);</span><br><span class="line"></span><br><span class="line">BB&lt;char, string&gt; bb_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(bb_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以具体化、支持多个模板类</p><p>3）非约束模板类友元：模板类实例化时，如果实例化了n个类，也会实例化n个友元函数，每个实例化的类都拥有n个有缘函数。(它不科学)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">template&lt;typename T&gt; friend void show(T&amp; a);</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//通用的函数模板</span><br><span class="line">void show(T&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//函数模板的具体版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类模板-模板类的成员模板"><a href="#2-类模板-模板类的成员模板" class="headerlink" title="2. 类模板-模板类的成员模板"></a>2. 类模板-模板类的成员模板</h4><p>意思是在模板类中创建模板类和函数模板，开发中，模板类中有类模板和函数模板的情况很常见；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_x=&quot; &lt;&lt; m_x &lt;&lt; &quot;  , m_y=&quot; &lt;&lt; m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;//里面这个类模板参数可以和外面的类模板相同，也可以不同</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T m_a;</span><br><span class="line">T1 m_b;//可以用AA的模参数T1和T2创建成员变量</span><br><span class="line">T1 m_c;</span><br><span class="line">//BB() &#123;&#125;</span><br><span class="line">BB() &#123;&#125;</span><br><span class="line">~BB() &#123;&#125;</span><br><span class="line">//void show()</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; m_a &lt;&lt; &quot;  , m_b=&quot; &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">void show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BB&lt;string&gt; m_bb;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T tt)//是类模板AA的成员函数，也是函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tt=&quot; &lt;&lt; tt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;m_x=&quot; &lt;&lt; m_x &lt;&lt; &quot;  , m_y=&quot; &lt;&lt; m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AA&lt;T1,T2&gt;::BB&lt;T&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; m_a &lt;&lt; &quot;  , m_b=&quot; &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; a(88, &quot;我是小明&quot;);</span><br><span class="line">a.show();</span><br><span class="line">a.m_bb.m_a = &quot;小婷&quot;;</span><br><span class="line">a.m_bb.m_b = 66;</span><br><span class="line">a.m_bb.show();</span><br><span class="line">a.show(&quot;结束行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-类模板-将模板类用作参数"><a href="#3-类模板-将模板类用作参数" class="headerlink" title="3. 类模板-将模板类用作参数"></a>3. 类模板-将模板类用作参数</h4><p>链表数组，为了支持任意类型数据，最好的方法是用类模板来实现（物理结构不相同，但是逻辑结构是相同的）<br>模板的目的就是代码重用。链表和数组的逻辑结构是一样的，是否可以做成一个模板类呢？可以的。<br>链表这个模板类模板化目的为了兼容各种数据类型<br>C++支持模板的模板:把模板名当成一种特殊的类型，实例化对象的时候，可以用模板名作为参数，传给模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">class LinkList//链表类模板 被称为容器 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1* m_head;</span><br><span class="line">int m_len = len;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">LinkList();</span><br><span class="line">~LinkList();</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中插入一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ddelete()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中删除了一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void update()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中更新一条记录&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">LinkList&lt;T1, len&gt;::LinkList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">LinkList&lt;T1, len&gt;::~LinkList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1* m_data;//数组指针</span><br><span class="line">int m_len = len;//表长</span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中插入一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ddelete()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中删除了一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void update()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中更新一条记录&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">Array&lt;T1, len&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">Array&lt;T1, len&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线性表模板类：tabletype-线性表类型  datetype-线性表数据类型</span><br><span class="line">//template&lt;class, int&gt;class 模板类</span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">class LinearList</span><br><span class="line">&#123;</span><br><span class="line">/*线性表模板类的代码实现，特别地方有：</span><br><span class="line">那就是它的参数</span><br><span class="line">*/</span><br><span class="line">public:</span><br><span class="line">tabletype&lt;datatype, len&gt; m_table;//创建线性表对象</span><br><span class="line"></span><br><span class="line">LinearList();</span><br><span class="line">~LinearList();</span><br><span class="line"></span><br><span class="line">void insert()//线性表插入操作</span><br><span class="line">&#123;</span><br><span class="line">m_table.insert();</span><br><span class="line">&#125;</span><br><span class="line">void ddelete() &#123; m_table.ddelete(); &#125;//线性表删除操作</span><br><span class="line">void updata() &#123; m_table.update(); &#125;//线性表更新操作</span><br><span class="line">void oper()//按业务要求操作线性表</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;len=&quot; &lt;&lt; m_table.m_len &lt;&lt; endl;</span><br><span class="line">m_table.insert();</span><br><span class="line">m_table.update();</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">LinearList&lt;tabletype, datatype, len&gt;::LinearList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">LinearList&lt;tabletype, datatype, len&gt;::~LinearList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建线性表对象,容器类型为链表，链表的数据类型为int,表长为20</span><br><span class="line">LinearList&lt;LinkList, int, 20&gt;a;</span><br><span class="line">//LinearList:线性表的类模板名，创建线性表对象</span><br><span class="line">//LinkList：线性表第一个参数是容器的类型，容器都是类模板，所以填写类模板名</span><br><span class="line">//第二个参数用于指定容器的数据类型，意思是容器中存放的是什么类型的数据</span><br><span class="line">//第三个参数是指定容器的大小</span><br><span class="line">a.insert(); </span><br><span class="line">a.ddelete(); </span><br><span class="line">a.updata();</span><br><span class="line"></span><br><span class="line">//创建线性表对象,容器类型为链表，链表的数据类型为string,表长为20</span><br><span class="line">LinearList&lt;Array, string, 20&gt;b;</span><br><span class="line">b.insert(); </span><br><span class="line">b.ddelete(); </span><br><span class="line">b.updata();</span><br><span class="line"></span><br><span class="line">/*他们选择不同容器 LinkList 和 Array 容器，容器可以不同，但是操作数据的方法是相同的*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性表模板类的代码实现，特别地方有：那就是它的参数<br><code>template&lt;class, int&gt;class tabletype</code>的意思：表示 <code>tabletype</code> 不是一个普通的参数，而是模板，意思是这个参数要填写模板名，不要填写普通类型（int、string）;<br>填什么样的模板名呢？填有两个参数的类模板名，一个参数的类模板名是不可以的。并且要求类模板的第一个参数是通用类型，第二个是非通用类型。<br>在如下代码中 class 也可以用 typename 代替,类模板更习惯用 class 而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class, int&gt;class tabletype</span><br><span class="line">template&lt;typename, int&gt;class tabletype</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br></pre></td></tr></table></figure><p>模板名通过参数 tabletype 传入到了类中，类中可以用 tabletype 创建对象；<code>tabletype</code> 是一个模板名， 用<code>tabletype</code>创建对象的时候，还需要指定具体的数据类型；<code>tabletype</code>应该用什么数据类型。<br>最常见的做法是：用模板参数从外面传进来，例如 把 datatype 填这里，len 填在这里<br>这个一般用于数据处理中</p><h4 id="4-编译预处理"><a href="#4-编译预处理" class="headerlink" title="4. 编译预处理"></a>4. 编译预处理</h4><p>C++程序编译的过程：预处理 -&gt; 编译（优化、汇编） -&gt; 链接<br>预处理指令主要有以下三种：<br>包含头文件:#include<br>宏定义:#define #undef<br>条件编译：#if #else #elif #end #ifnedf #if defined</p><h4 id="5-编译和链接"><a href="#5-编译和链接" class="headerlink" title="5. 编译和链接"></a>5. 编译和链接</h4><p>1）分开编译的好处：每次只编译修改过的源文件，然后在再链接，效率最高。<br>2）编译单个<code>*.cpp</code> 文件的时候，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误。<br>3）编译单个<code>*.cpp</code> 文件的时候，编译器只需要知道名称的存在，不会把他们的定义一起编译。<br>4）如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令<br>5）链接的时候、变量、函数和类的定义只能有一个，否则会出现重定义错误。(如果把变量、函数和类的定义放在<code>*.h</code> 文件中，<code>*.h</code> 会被多次包含，链接前会存在多个副本，如果放在<code>*.cpp</code> 文件中，<code>*.cpp</code> 文件不会被包含，只会被编译一次，链接前只存在一个版本)(如果加上 <code>static</code> 可以避免被重复包含)<br>6）把变量、函数和类的定义放在<code>*.h</code>中是不规范的做法，如果<code>*.h</code>被多个<code>*.cpp</code>包含，会出现重定义。头文件加上防止重定义编译的宏定义<br>7）用 <code>#include</code> 包含 <code>*.cpp</code> 是不规范的做饭，原理同上<br>8）尽可能不使用全局变量，如果一定要用，要在 <code>*.h</code> 文件中声明（需要加 <code>extern</code>）, <code>*.cpp</code> 中定义。<br>9）全局的<code>const</code>常量在头文件中定义 (<code>const</code>常量仅在文件内有效)<br>10）<code>*.h</code> 重复包含的处理方法只对单个的<code>*.cpp</code>文件有效，不是整个项目.<br>11）函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在<code>*.h</code>文件中;函数模板和类模板的具体化版本的代码是真实的定义，所以放在<code>*.cpp</code> 文件中。<br>12) Linux下C++编译和链接的原理与VS一样。</p><h4 id="6-C-命名空间"><a href="#6-C-命名空间" class="headerlink" title="6. C++命名空间"></a>6. C++命名空间</h4><p>实际开发中，较大型的项目会使用大量的全局名字，如类、函数、模板、变量等，很容易出现名字冲突的情况。<br>命名空间分割了全局空间，每个命名空间是一个作用域，防止名字冲突<br>语法<br>创建命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace 命名空间的名字</span><br><span class="line">&#123;</span><br><span class="line">//类、函数、模板、变量的声明和定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建命名空间的别名<br>namespace 别名 &#x3D; 原名;</p><p>要使用命名空间的数据类型有三种方法：<br>第一种方法：在名字前面加上命名空间的名字和两个冒号,这种方法简单明了，不会造成任何冲突，但是使用起来比较繁琐，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果想使用命名空间中的变量</span><br><span class="line">cout&lt;&lt;AA::aa&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>第二种方法：用using声明,使用using声明要注意这样一个问题，如果再同一个区域出现了相同的名字，那么编译会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//如果想用 AA 命名空间的 aa ,但是在下面代码中不能再出现 aa 变量名</span><br><span class="line">using AA::aa;</span><br><span class="line">using AA::func;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法：用using编译指令，使用using编译指令要注意这样一个问题，如果再同一个区域出现了相同的名字，虽然编译不会报错，但是会屏蔽之前创建的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">using namespace AA;//有了这行代码后，main函数中，AA命名空间中的全部名字都可以用 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项<br>1）命名空间是全局的，可以分布再多个文件中(有命名空间和没有命名空间代码组织一样的，函数和类的声明在头文件中，函数和类的定义在源文件中；全局变量在头文件中声明，在源文件中定义)</p><figure class="highlight plaintext"><figcaption><span>namespace_new.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">int ab = 1; //全局变量</span><br><span class="line"></span><br><span class="line">void A1::show()//类成员函数的类外实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A1::show()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func1()//调用了全局函数定义</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">extern int ab;</span><br><span class="line"></span><br><span class="line">void func1();//全局函数声明</span><br><span class="line"></span><br><span class="line">class A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show();//类的成员函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace aa;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A1 a1;</span><br><span class="line">a1.show();</span><br><span class="line">func1();</span><br><span class="line">cout &lt;&lt; ab &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有同一个命名空间的代码可以分散在不同的文件中,例如把命名空间AA代码分开，如下所示</p><figure class="highlight plaintext"><figcaption><span>namespace_new.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">void A1::show()//类成员函数的类外实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A1::show()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func1()//调用了全局函数定义</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">void func1();//全局函数声明</span><br><span class="line"></span><br><span class="line">class A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show();//类的成员函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new2.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new2.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">int ab = 1; //全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">extern int ab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，组织代码的方法，和没有命名空间相比，只是在代码外面，套了一个命名空间而已</p><p>2）命名空间可以嵌套。<br>3）在命名空间中声明变量，而不是使用外部全局变量和静态全局变量（应用经验。静态变量不适用原因：例如上面全局变量 ab 在源文件中定义，头文件中声明，不在头文件中声明，那么外部就不知道有该变量，效果和静态变量一样）<br>4）对于using声明，首选将其作用域设置为局部而不是全局 ；将这个代码放在main函数作用域中<code>using AA::aa;</code>，不要放置外面<br>5）不要在头文件中使用using编译指令，如果非要使用，应将它放在所有的 #include 之后。<br>6）匿名的命名空间，在当前文件中从创建的位置到文件结束有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace //匿名的命名空间</span><br><span class="line">&#123;</span><br><span class="line">int ii = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ii&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-C-类型转换-static-cast"><a href="#7-C-类型转换-static-cast" class="headerlink" title="7. C++类型转换 static_cast"></a>7. C++类型转换 static_cast</h4>]]></content>
    
    
    <summary type="html">C++学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL创建多项目-多工程编译</title>
    <link href="https://goupos.top/2023/10/31/MDK%20KEIL/MDK%20KEIL%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/"/>
    <id>https://goupos.top/2023/10/31/MDK%20KEIL/MDK%20KEIL%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/</id>
    <published>2023-10-31T03:30:34.000Z</published>
    <updated>2023-11-01T09:29:07.305Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li><p>首先说明一下多工程的作用：<br>假如你写了一个boot和一个app等好几个工程，当如果这几个工程同用一个文件，你修改了以后，意味着所有的工程都需要重新编译，一个一个工程编译就带来了困难。</p></li><li><p>开始创建多工程</p></li></ol><p>1)你已经创建了两个以及以上的前提上<br>2)创建多工程（多工程其实也是一个工程）<br>方法：点击 <code>Project</code> -&gt; <code>New Multi-Project Workspace...</code> -&gt; 填写工程名字，放置在选择的文件夹,然后保存 -&gt; 会弹出提示框 <code>Create New xxxx-Project Workspace </code> 在 <code>uVision Projects</code>添加项目路径（如果不添加路径无法保存） -&gt; 点击 <code>OK</code><br>3)如果还想继续添加工程到当前项目中，可以找到界面上这个图标，如下是路径：<br>方法：点击 <code>Project</code> -&gt; <code>manage</code> -&gt; <code>New Multi-Project Workspace...</code><br>4）所有工程全编译<br>方法：找到界面中 <code>Batch Build</code> 下拉 -&gt; <code>Batch Setup</code> -&gt; <code>Select All</code> -&gt; <code>Close</code><br>再次点击<code>Batch Build</code> 下拉 -&gt; <code>Batch Rebuild</code><br>5）选择工程目录<br>方法：界面中点击 <code>Project</code> 目录中需要选中的项目，右击鼠标 -&gt; <code>Set as Active Project</code>  </p>]]></content>
    
    
    <summary type="html">MDK KEIL创建多工程-多工程编译</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-21T09:15:14.000Z</published>
    <updated>2023-11-05T14:25:29.107Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没什么可看的，都是我不会记录一下</p></blockquote><span id="more"></span><h4 id="0-关于为什么要用-new-创建变量"><a href="#0-关于为什么要用-new-创建变量" class="headerlink" title="0. 关于为什么要用 new 创建变量"></a>0. 关于为什么要用 <code>new</code> 创建变量</h4><p>原因是分给程序的栈空间一般很小，<code>8M</code> 空间 ,当有很大的数组或者变量的时候，栈空间不足，但是堆空间很大，可以使用堆空间。</p><h4 id="1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数"><a href="#1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数" class="headerlink" title="1. 成员初始化表中成员初始化列表格式 如下形式，Student(string name,int age) 参数初始化对象中的参数"></a>1. 成员初始化表中成员初始化列表格式 如下形式，<code>Student(string name,int age)</code> 参数初始化对象中的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Student(string name,int age):name(Name),age(Age)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">string Name;</span><br><span class="line">int Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-new-创建数组，要使用如下方式删除数组-delete-数组名"><a href="#2-new-创建数组，要使用如下方式删除数组-delete-数组名" class="headerlink" title="2. new 创建数组，要使用如下方式删除数组 delete []数组名"></a>2. <code>new</code> 创建数组，要使用如下方式删除数组 <code>delete []数组名</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64_t *arr = new uint64_t[10];</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        *arr = 5;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] =*(arr+(i-1))*10;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *(arr + i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete[]arr;</span><br><span class="line">cout &lt;&lt; &quot;结束任务&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="3-对象的赋值和复制"><a href="#3-对象的赋值和复制" class="headerlink" title="3. 对象的赋值和复制"></a>3. 对象的赋值和复制</h4><p>（1）对象的赋值 如果两个对象都已存在，这种叫赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(&quot;yuyu&quot;,56);</span><br><span class="line">t1 = t2;</span><br></pre></td></tr></table></figure><p>（2）对象的复制（拷贝）用一个已存在的对象去创建一个新的对象，叫拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(t1);//Student t2 = t1;调用了一个拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"><a href="#4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors" class="headerlink" title="4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"></a>4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）<code>-fno-elide-constructors</code></h4><h4 id="5-拷贝构造函数-copy-constructor"><a href="#5-拷贝构造函数-copy-constructor" class="headerlink" title="5. 拷贝构造函数(copy constructor)"></a>5. 拷贝构造函数(copy constructor)</h4><p>当一个类中没有显式的去声明拷贝构造函数时候，编译器会自动生成。自动生成的拷贝构造函数执行：逐成员赋值</p><h4 id="6-不可重载运算符以及只能被成员函数重载运算符"><a href="#6-不可重载运算符以及只能被成员函数重载运算符" class="headerlink" title="6. 不可重载运算符以及只能被成员函数重载运算符"></a>6. 不可重载运算符以及只能被成员函数重载运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不可重载运算符</span><br><span class="line">sizeof        sizeof运算符</span><br><span class="line">.             成员运算符</span><br><span class="line">.*            成员指针运算符</span><br><span class="line">::            作用域解析运算符</span><br><span class="line">?:            条件运算符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只能被成员函数重载运算符</span><br><span class="line">=        赋值运算符</span><br><span class="line">()       函数调用运算符</span><br><span class="line">[]       下标运算符</span><br><span class="line">-&gt;       通过指针访问成员的运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-访问修饰符"><a href="#7-访问修饰符" class="headerlink" title="7. 访问修饰符"></a>7. 访问修饰符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private    私有的    只能在类的内部访问，外界不能直接访问</span><br><span class="line">public     公有的    在任意地方都可以访问</span><br><span class="line">protected  保护的    只能在类的内部访问，外界不能直接访问，其子类可以访问</span><br></pre></td></tr></table></figure><h4 id="8-浅拷贝与深拷贝"><a href="#8-浅拷贝与深拷贝" class="headerlink" title="8.浅拷贝与深拷贝"></a>8.浅拷贝与深拷贝</h4><p>浅拷贝：多个指针指向同一段内存<br>深拷贝：每个指针指向单独的内存</p><h4 id="9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。"><a href="#9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。" class="headerlink" title="9. new和delete重载函数，编译器默认加上了 static 是静态成员，该关键字可以是类成员也可以是全局成员。"></a>9. <code>new</code>和<code>delete</code>重载函数，编译器默认加上了 <code>static</code> 是静态成员，该关键字可以是类成员也可以是全局成员。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-using-使用using-关键字可以改变基类成员在派生类中的访问权限"><a href="#10-using-使用using-关键字可以改变基类成员在派生类中的访问权限" class="headerlink" title="10. using 使用using 关键字可以改变基类成员在派生类中的访问权限"></a>10. using 使用using 关键字可以改变基类成员在派生类中的访问权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">using A::m_b;//把m_b的权限修改为共有的</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">using A::m_a;//把m_a的权限修改为私有的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明"><a href="#11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明" class="headerlink" title="11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明"></a>11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showA(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_d;</span><br><span class="line">B():m_d(0),A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void showB(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因"><a href="#12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因" class="headerlink" title="12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)"></a>12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showA(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_d;</span><br><span class="line">B():m_d(0),A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数1,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数2,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void showB(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">B b(10, 20, 30, 40);</span><br><span class="line">b.showA();</span><br><span class="line">b.showB();</span><br><span class="line">b.A::show();//重点</span><br><span class="line">b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-虚函数关键字：-virtual"><a href="#13-虚函数关键字：-virtual" class="headerlink" title="13. 虚函数关键字： virtual"></a>13. 虚函数关键字： virtual</h4><p>类中如果有虚函数，那么会创建虚函数列表，虚函数列表保存着虚函数地址，正常类成员函数，是在链接中放入类中<br>类中的成员变量。如果存在菱形的虚继承，也会出现虚成员表保存类成员，出现虚基类<br>如果要使用基类对象析构派生类对象时，需要对基类析构函数使用虚函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点"><a href="#14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点" class="headerlink" title="14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点"></a>14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~a()&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"><a href="#15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用" class="headerlink" title="15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"></a>15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">virtual void func() = 0;//基类中定义，但是继承类中一定要实现，才能实例化，</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~A() = 0</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void showA(void) = 0//一定要有代码实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类"><a href="#16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类" class="headerlink" title="16. dynamic_cast 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)"></a>16. <code>dynamic_cast</code> 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)</h4><p>派生类指针 &#x3D; dynamic_cast&lt;派生类类型<code>*</code>&gt;(基类指针)<br>可以正确生成，则返回具体之，否则返回 <code>nullptr</code> ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-typeid运算符和type-info类"><a href="#17-typeid运算符和type-info类" class="headerlink" title="17. typeid运算符和type_info类"></a>17. typeid运算符和type_info类</h4><p>typeid 用于获取数据类型的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// expre_typeid_Operator.cpp</span><br><span class="line">// compile with: /GR /EHsc</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void vvfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">   Derived* pd = new Derived;</span><br><span class="line">   Base* pb = pd;</span><br><span class="line">   cout &lt;&lt; typeid( pb ).name() &lt;&lt; endl;   //prints &quot;class Base *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pb ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   cout &lt;&lt; typeid( pd ).name() &lt;&lt; endl;   //prints &quot;class Derived *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pd ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   delete pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="18-关于-auto-的一些用法"><a href="#18-关于-auto-的一些用法" class="headerlink" title="18. 关于 auto 的一些用法"></a>18. 关于 <code>auto</code> 的一些用法</h4><p>方法一：代替冗长复杂的变量声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">double func(int a,int b , char *c ,int d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;&quot;  b = &quot; &lt;&lt; b &lt;&lt;&quot;  c = &quot;&lt;&lt; c &lt;&lt; &quot;   d = &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">return 1.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">auto funcp = func;</span><br><span class="line">funcp(10,20,&quot;小婷&quot;,40); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-函数模板概念"><a href="#19-函数模板概念" class="headerlink" title="19. 函数模板概念"></a>19. 函数模板概念</h4><p>在对一个数据进行交换时，可能重载很多数据的交换类型，每增加一种数据类型，就要增加一个重载函数，这样始终不是很好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void Swap(int &amp;a , int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(double &amp;a , double &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">double &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(char &amp;a , char &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">char &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数模板是通用的函数描述，使用任意类型（泛型）来描述函数<br>编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。<br>生成函数定义的过程被称为实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//template模板</span><br><span class="line">//typename类型名称</span><br><span class="line">//template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">anytype temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">double temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">Swap(a,b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想让编译器自动推导，可以手工指定市场的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//template模板</span><br><span class="line">//typename类型名称</span><br><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">anytype temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">double temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str_a = &quot;小婷&quot;, str_b = &quot;小明&quot;;</span><br><span class="line">Swap&lt;string&gt;(str_a, str_b);//&lt;&gt;中强制指定类型</span><br><span class="line">cout &lt;&lt; &quot;str_a = &quot; &lt;&lt; str_a &lt;&lt; &quot;  str_b = &quot; &lt;&lt; str_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++98添加关键字typename之前，C++使用关键字class来创建模板；建议使用 <code>typename</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">template&lt;class anytype&gt;</span><br></pre></td></tr></table></figure><p>可以为类的成员函数创建模板，但是不能是虚函数和析构函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class template_class</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">template_class(T perem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T perem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">template_class temp_class(&quot;小婷&quot;);</span><br><span class="line">temp_class.show(&quot;小婷&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数模板，必须明确数据类型，确保实参与函数模板能匹配上；函数模板多个变量时候，一定要保证<code>T</code>是相同类型，否则无法匹配，还有一个特殊类，函数模板没有参数，必须明确类型，如果没有参数，只能显示的指定类型了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;shou函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">show&lt;int&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()//这种就不适用函数模板中的代码</span><br><span class="line">&#123;</span><br><span class="line">CGil a, b;</span><br><span class="line">add_vlaue(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数模板，如果是自动类型推导，不会发生隐式类型转换，如果显示指定了函数模板的数据类型，可以发生隐式类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">int a = 10; </span><br><span class="line">char b = 20;</span><br><span class="line">int c= add_vlaue&lt;int&gt;(a,b);//显式制定了函数模板的数据类型，编译器就可以对实参惊醒隐式类型转换</span><br><span class="line">cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; c &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数模板可以被重载，可以有非通用数据类型的参数（T Multi_type(T a, T2 b, int c)）；支持多个通用数据类型的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b, int c)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2, typename T3, typename T4, typename T5&gt;</span><br><span class="line">T Multi_type(T a, T2 b, T3 c, T4 d, T5 e)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b + c + d + e;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = Multi_type((unsigned int)b, (unsigned char)f);</span><br></pre></td></tr></table></figure><h4 id="20-函数模板的具体化"><a href="#20-函数模板的具体化" class="headerlink" title="20. 函数模板的具体化"></a>20. 函数模板的具体化</h4><p>可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板；具体化（特丽化、特化）的语法；就是函数通用版本以外的一个特殊版本：<br>具体函数的返回值、函数名和形参列表与函数模板相同，但是对具体化函数来说，不管是函数的声明还是函数体中，都是具体的数据类型，没有通用的数据类型了，函数体中代码随意写，满足要求就可以<br>编译器推导实参数据类型匹配，会直接使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_rank;</span><br><span class="line">CGil(int a):m_rank(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show(string str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">CGil g1(10),g2(20);</span><br><span class="line">Swap(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">Swap(g1,g2);</span><br><span class="line">g1.show(&quot;g1&quot;);</span><br><span class="line">g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板声明和定义都可以分开写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b);</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; \</span><br><span class="line">void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; </span><br><span class="line">void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于给定的函数名，有普通函数、函数模板、具体化函数模板、重载函数<br>如果多种函数都可以匹配上，编译器使用规则<br>普通函数(重载函数) &gt; 具体化函数模板 &gt; 函数模板<br>如果希望使用函数模板，可以使用空模板参数强制使用函数模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//空模板函数示例</span><br><span class="line">Swap&lt;&gt;(1,2);//使用具体化函数模板示例</span><br></pre></td></tr></table></figure><p>如果函数模板能产生更好的匹配，将优先于普通函数</p><h4 id="21-函数模板-函数模板份文件编写"><a href="#21-函数模板-函数模板份文件编写" class="headerlink" title="21. 函数模板-函数模板份文件编写"></a>21. 函数模板-函数模板份文件编写</h4><p>函数模板只是函数的描述，没有实体(函数模板只是模型，并没有直接写入可执行文件中，有点宏定义特性)<br>《C++ P P》 函数模板一般放在头文件中<br>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中。<br>函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件，定义在源文件中</p><figure class="highlight plaintext"><figcaption><span>xxx.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_rank;</span><br><span class="line">CGil(int a):m_rank(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show(string str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数模板具体化</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>xxx.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#Include &quot;xxx.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">CGil g1(10),g2(20);</span><br><span class="line">Swap(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Swap(g1,g2);</span><br><span class="line">g1.show(&quot;g1&quot;);</span><br><span class="line">g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通函数和函数模板具体化，在头文件声明，源文件中定义，函数模板都在头文件中（其他函数模板形式无意义）；</p><figure class="highlight plaintext"><figcaption><span>函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"><a href="#22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）" class="headerlink" title="22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"></a>22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）</h4><p><code>decltype</code> 关键字，在C++11中，decltype 操作符，用于查询表达式的的数据类型<br>语法 decltype(expression) var; expression:填写表达式 var:是变量<br><code>decltype</code> 分析表达式并得到他的类型，不会计算执行表达式。函数调用也是一种表达式，因此不必担心在使用 decltype 时执行了函数。<br><code>decltype</code> 返回值是数据类型，可以用它定义变量，后面直接写变量名就行了；如果表达式中有函数，不用担心会被调用执行<br>decltype 规则<br>（1）如果 <code>expression</code> 是没有用括号括起来的标识符(decltype本身括号不算括号,要在decltype内部再加一个括号)，则var的类型与该标识符的类型相同，包括const等限定符。</p><figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">short a = 5;</span><br><span class="line">decltype(a) da;//`da`变量类型与变量`a`相同，`a` `da`都是short</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）如果 <code>expression</code> 是函数调用，则var的类型与函数的返回值类型相同(函数不能返回 <code>void</code> ,但可以返回<code>（void *）</code> ;这是因为 <code>void</code> 无法声明变量)</p><figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int func_main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 100;</span><br><span class="line"></span><br><span class="line">//如下两个格式变量不相同 decltype表达式中，填函数调用和填函数名是两回事，</span><br><span class="line">//只填写函数名，得到的是函数的类型，不是返回值的类型 </span><br><span class="line">//函数返回值类型</span><br><span class="line">decltype(func_main())func_main_value = a;</span><br><span class="line"></span><br><span class="line">decltype(func_main) func_main_value_g;//无用 void 无法声明变量</span><br><span class="line"></span><br><span class="line">//函数名类型 :int()(),对变量名加入 * 号，转换为函数指针</span><br><span class="line">decltype(func_main) *pfunc_main_value = func;// void * 声明变量</span><br><span class="line">pfunc_main_value_g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果 <code>expression</code> 是左值（能取地址）（排除第一种可能）、或者用括号括起来的标识符，那么var的类型是<code>expression</code>的引用<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int func_main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = 10;</span><br><span class="line"></span><br><span class="line">//注意：没有用括号和用了括号不一样</span><br><span class="line">decltype(b) copy_b; //int copy_b;</span><br><span class="line">//加了括号都变成了引用</span><br><span class="line">decltype((b)) yingyong1_b = b; // int &amp;yingyong1_b = b;</span><br><span class="line"></span><br><span class="line">decltype((func_main)) yingyong_func_main = func_main;// int (&amp;yingyong_func_main)() = func_main;</span><br><span class="line">//引用一定要初始化</span><br><span class="line">yingyong_func_main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（4）如果上面的条件都不满足，则var的类型与 <code>expression</code> 的类型相同；<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><br>decltype：关键字不是应用就是，就是变量<br>如果需要多次使用decltype,可以结合 <code>typedef</code> 和 <code>using</code><br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;//释放某个变量到当前作用域</span><br><span class="line">using namespace std;//释放这个命名空间到当前作用域</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><br>函数后置返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x ,int y);</span><br><span class="line">//等同</span><br><span class="line">auto func(int x,int y) -&gt; int;//C++11中有的，不管是函数声明还是定义都可以这么写</span><br></pre></td></tr></table></figure><p>将返回类型移到了函数声明后面。<br><code>auto</code> 是一个占位符（c++11给 <code>auto</code> 新增的角色），为函数返回值占了一个位置。<br>这种语法也可以用户函数定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) -&gt; int </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) -&gt; decltype(x+y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++14的 <code>auto</code> 关键字：C++14标准对函数返回类型推导规则做了优化，函数的返回值可以用 <code>auto</code> ,不必尾随返回类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , typename T2&gt;</span><br><span class="line">auto func(T x,T2 y)</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-类模板-模板类的基本概念"><a href="#23-类模板-模板类的基本概念" class="headerlink" title="23. 类模板-模板类的基本概念"></a>23. 类模板-模板类的基本概念</h4><p>类模板与模板类都是同一个；函数模板和模板函数都是同一个。<br>类模板是通用类的描述，使用任意类型(泛型)来描述类的定义。<br>使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义</p><figure class="highlight plaintext"><figcaption><span>语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 2;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int, double &gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.m_a = &quot; &lt;&lt; a.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.m_b = &quot; &lt;&lt; a.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类模板，数据类型必须适应类模板中的代码；<br>类模板可以为通用类型指定缺省值的数据类型（C++11标准的才支持函数模板缺省值设置，以前不可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt; //如果T2没有指定类型，那么就会使用缺省值double</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 2;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板类的成员函数可以在类外实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">T2 AA&lt;T, T2&gt;::getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 1;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>new</code>创建模板类对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AA&lt;int ,double&gt; * p_a1 = new AA&lt;int ,double&gt;;</span><br><span class="line">AA&lt;int, double&gt;* p_a2 = new AA&lt;int, double&gt;(10, 10.5);</span><br><span class="line"></span><br><span class="line">delete p_a1;</span><br><span class="line">delete p_a2;</span><br></pre></td></tr></table></figure><p>模板类的成员函数和模板函数相同，都是使用了才会创建，不使用不会创建。</p><h4 id="24-模板类的示例-栈"><a href="#24-模板类的示例-栈" class="headerlink" title="24.模板类的示例-栈"></a>24.模板类的示例-栈</h4><p>模板类最常用的就是作为容器类<br>C++标准库:栈、数组、链表、二叉树和哈希表</p><h4 id="25-模板类的示例-数组"><a href="#25-模板类的示例-数组" class="headerlink" title="25.模板类的示例-数组"></a>25.模板类的示例-数组</h4><p>定长数组:array容器（C++11标准）<br>可变数组:vector容器<br>类模板的非通用类型参数</p><figure class="highlight plaintext"><figcaption><span>定长数组:array容器（C++11标准）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T items[MAXLEN];//数组元素</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T &amp;Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T &amp;Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Array&lt;int&gt; array;</span><br><span class="line">array[3] = 10;</span><br><span class="line">cout &lt;&lt; array[3] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板的非通用类型参数；非通用类型参数可以有缺省值，创建类型的时候，可以不用填写</p><figure class="highlight plaintext"><figcaption><span>类模板的非通用类型参数（定长类数组容器）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T,int len&gt;//类模板可以支持非通用类</span><br><span class="line">//template&lt;class T,int len = 10&gt;//类模板可以支持非通用类，非通用类添加缺省值</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T items[len];//数组元素</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">const T &amp;Array&lt;T,len&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">T &amp;Array&lt;T,len&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//如下是三个类</span><br><span class="line">Array&lt;string,100&gt; array;</span><br><span class="line">Array&lt;string,101&gt; array1;</span><br><span class="line">Array&lt;string,102&gt; array2;</span><br><span class="line"></span><br><span class="line">array[0] = &quot;小0&quot;;</span><br><span class="line">array[1] = &quot;小1&quot;;</span><br><span class="line">array[2] = &quot;小2&quot;;</span><br><span class="line">array[3] = &quot;小3&quot;;</span><br><span class="line">array[4] = &quot;小4&quot;;</span><br><span class="line">array[5] = &quot;小5&quot;;</span><br><span class="line">array[6] = &quot;小6&quot;;</span><br><span class="line">array[7] = &quot;小7&quot;;</span><br><span class="line">array[8] = &quot;小8&quot;;</span><br><span class="line">array[9] = &quot;小9&quot;;</span><br><span class="line">array[10] = &quot;小10&quot;;</span><br><span class="line">array[11] = &quot;小11&quot;;</span><br><span class="line">array[12] = &quot;小12&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 13; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; array[i].c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板可以有非通用类型参数：1.通常是整型(C++20标准可以用其它)；2.实例化模板必须用常量表达式；3.模板中不能修改参数的值<br>优点：在栈上分配内存，以维护，执行速度快，合适小型数组<br>缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类,导致程序的二进制代码会更大，运行的时候，占用的内存空间也更多，Vector_Array容器效率虽然不如Array容器，但是更通用，还可以自动扩展，也不会存在Array容器创建多个类定义的情况.<br>构造函数的方法更通用，因为数据的大小是类的成员(而不是硬编码)，可以创建数组大小可变的类。</p><figure class="highlight plaintext"><figcaption><span>变长数组容器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 10);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Vector_Array&lt;string&gt;array(5);</span><br><span class="line">array[0] = &quot;小11&quot;;</span><br><span class="line">array[1] = &quot;小12&quot;;</span><br><span class="line">array[2] = &quot;小13&quot;;</span><br><span class="line">array[3] = &quot;小14&quot;;</span><br><span class="line">array[4] = &quot;小15&quot;;</span><br><span class="line">array[5] = &quot;小16&quot;;</span><br><span class="line">array[6] = &quot;小17&quot;;</span><br><span class="line">array[7] = &quot;小18&quot;;</span><br><span class="line">array[8] = &quot;小19&quot;;</span><br><span class="line">array[9] = &quot;小110&quot;;</span><br><span class="line">array[10] =&quot;小111&quot;;</span><br><span class="line">array[11] =&quot;小112&quot;;</span><br><span class="line">array[12] =&quot;小113&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;array.size_Array() = &quot; &lt;&lt; array.size_Array() &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; array.size_Array(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;array[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; array[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="26-类模板-嵌套和递归使用模板类"><a href="#26-类模板-嵌套和递归使用模板类" class="headerlink" title="26.类模板-嵌套和递归使用模板类"></a>26.类模板-嵌套和递归使用模板类</h4><p>1.容器中有容器<br>2.数组的元素可以是栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DataType *items;</span><br><span class="line">int top;</span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Stack(int size = 3);</span><br><span class="line">~Stack();</span><br><span class="line">bool isempty();//判断栈是否为空。</span><br><span class="line">bool isfull();//判断栈是否以满</span><br><span class="line">bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;top = 0;</span><br><span class="line">this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">item = this-&gt;items[--this-&gt;top];</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;//释放原内存</span><br><span class="line">this-&gt;stacksize = v.stacksize;//栈实际的大小</span><br><span class="line">this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">this-&gt;top = v.top;//栈顶指针</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 2);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;len = v.len;</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">Vector_Array&lt; Stack&lt;string&gt; &gt; vs;</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">vs[0].push(&quot;小婷0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小明0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小雯0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[1].push(&quot;小婷1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小明1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小雯1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[2].push(&quot;小婷2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小明2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小雯2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[3].push(&quot;小婷3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小明3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小雯3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[4].push(&quot;小婷4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小明4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小雯4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[5].push(&quot;小婷5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小明5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小雯5&quot;);//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">&#123;</span><br><span class="line">while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">vs[ii].pop(item);</span><br><span class="line">cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.栈中的元素可以是数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DataType *items;</span><br><span class="line">int top;</span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Stack(int size = 3);</span><br><span class="line">~Stack();</span><br><span class="line">bool isempty();//判断栈是否为空。</span><br><span class="line">bool isfull();//判断栈是否以满</span><br><span class="line">bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;top = 0;</span><br><span class="line">this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">item = this-&gt;items[--this-&gt;top];</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;//释放原内存</span><br><span class="line">this-&gt;stacksize = v.stacksize;//栈实际的大小</span><br><span class="line">this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">this-&gt;top = v.top;//栈顶指针</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 2);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 2);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;len = v.len;</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">Vector_Array&lt; Stack&lt;string&gt; &gt; vs;//数组中有栈</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">vs[0].push(&quot;小婷0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小明0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小雯0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[1].push(&quot;小婷1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小明1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小雯1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[2].push(&quot;小婷2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小明2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小雯2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[3].push(&quot;小婷3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小明3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小雯3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[4].push(&quot;小婷4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小明4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小雯4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[5].push(&quot;小婷5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小明5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小雯5&quot;);//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">&#123;</span><br><span class="line">while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">vs[ii].pop(item);</span><br><span class="line">cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Stack容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">Stack&lt;Vector_Array&lt;string&gt;&gt;sv;//栈中有数组</span><br><span class="line"></span><br><span class="line">Vector_Array&lt;string&gt; temp;//栈的元素，临时Vector&lt;string&gt;容器</span><br><span class="line">//第一个入栈的元素</span><br><span class="line">temp[0] = &quot;西施1&quot;; temp[1] = &quot;西施2&quot;;sv.push(temp);</span><br><span class="line">//第二个入栈的元素</span><br><span class="line">temp[0] = &quot;西瓜1&quot;; temp[1] = &quot;西瓜2&quot;;sv.push(temp);</span><br><span class="line">//第三个入栈的元素</span><br><span class="line">temp[0] = &quot;冰冰1&quot;; temp[1] = &quot;冰冰2&quot;; temp[2] = &quot;冰冰3&quot;; temp[3] = &quot;冰冰4&quot;; sv.push(temp);</span><br><span class="line"></span><br><span class="line">Vector_Array&lt;string&gt; temp_pop;</span><br><span class="line">while (sv.isempty() == false)</span><br><span class="line">&#123;</span><br><span class="line">sv.pop(temp_pop);//出栈一个元素，放在临时容器中</span><br><span class="line"></span><br><span class="line">for (int ii = 0; ii &lt; temp_pop.size_Array(); ii++)//遍历临时Vector_Array&lt;string&gt;容器，显示容器中每个元素的值</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;vt[&quot; &lt;&lt; ii &lt;&lt; &quot;] = &quot; &lt;&lt; temp_pop[ii].c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Vector_Array容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">Vector_Array&lt;Vector_Array&lt;string&gt;&gt; vv;//递归使用模板类</span><br><span class="line">//char a[][]//二维指针，是连续内存</span><br><span class="line">//char *a[] -&gt; char b[]递归模板类 是先创建一个指针数组，指针数组元素再指向一个数组</span><br><span class="line">//二维数组大小固定，这一个大小是可变的</span><br><span class="line">vv[0][0] = &quot;西施1&quot;; vv[0][1] = &quot;西施2&quot;; vv[0][2] = &quot;西施3&quot;;</span><br><span class="line">vv[1][0] = &quot;西瓜1&quot;; vv[1][1] = &quot;西瓜2&quot;;</span><br><span class="line">vv[2][0] = &quot;冰冰1&quot;; vv[2][1] = &quot;冰冰2&quot;; vv[2][2] = &quot;冰冰3&quot;; vv[2][3] = &quot;冰冰4&quot;;</span><br><span class="line"></span><br><span class="line">for (int ii = 0; ii &lt; vv.size_Array(); ii++)</span><br><span class="line">&#123;</span><br><span class="line">for (int jj = 0; jj &lt; vv[ii].size_Array(); jj++)</span><br><span class="line">&#123;</span><br><span class="line">//cout &lt;&lt; &quot;vv[&quot; &lt;&lt; ii &lt;&lt; &quot;][&quot; &lt;&lt; jj &lt;&lt; &quot;]= &quot; &lt;&lt; vv[ii][jj].c_str() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; vv[ii][jj].c_str() &lt;&lt; &quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++11 之前 嵌套使用模板类的时候 &gt; &gt;之间要加空格。</p><h4 id="27-类模板-模板类具体化"><a href="#27-类模板-模板类具体化" class="headerlink" title="27.类模板-模板类具体化"></a>27.类模板-模板类具体化</h4><p>模板类具体化(特化、特例化)有两种：完全具体化和部分具体化。</p><p>完全具体化：语法和函数模板集体化是相似的，template关键字，一对空的尖括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(const T1 x, const T2 y):m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板完全具体化 模板类AA的一个完全具体化版本*/</span><br><span class="line">template&lt;&gt; </span><br><span class="line">class AA&lt;int, string&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_x;</span><br><span class="line">string m_y;</span><br><span class="line">AA(int x, string y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;完全具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void AA&lt;int,string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;完全具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分具体化：函数模板没有部分具体化说法，只有类模板才有,<br>部分具体化的意思是：为多个模板参数的部分参数指定具体的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(T1 x, T2 y):m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板部分具体化 模板类AA的一个部分具体化版本*/</span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">class AA&lt;T1, string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">string m_y;</span><br><span class="line">AA(const T1 x, const string y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;部分具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">void AA&lt;T1, string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;部分具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>调用示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(8, &quot;完全具体化类模板&quot;);</span><br><span class="line">aa_1.show();</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(8, &quot;部分具体化类模板&quot;);</span><br><span class="line">aa_2.show();</span><br><span class="line"></span><br><span class="line">AA&lt;char, int&gt; aa_3(8, 8);</span><br><span class="line">aa_3.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板规则：具体化程度高 &gt; 集体化程度低 &gt; 没有具体化的类；主要看匹配</p><h4 id="28-类模板-模板类与继承"><a href="#28-类模板-模板类与继承" class="headerlink" title="28.类模板-模板类与继承"></a>28.类模板-模板类与继承</h4><p>1）模板类继承普通类（常见）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a):m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1,class T2&gt;</span><br><span class="line">class BB :public AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y, int a);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1,T2&gt;::BB(T1 x,T2 y,int a):AA(a),m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;, 9);</span><br><span class="line">bb_1.func2();</span><br><span class="line">bb_1.func1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）普通类继承模板类的实例版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AA: public BB&lt;int,string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, int x, string y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a,int x,string y):m_a(a),BB(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">//bb_1.func2();</span><br><span class="line"></span><br><span class="line">AA aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">aa_1.func1();</span><br><span class="line">aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）普通类继承模板类（常见） 要把普通类也变成模板类：注意的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, const T1 x, const T2 y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int,string&gt; aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">aa_1.func1();</span><br><span class="line">aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）模板类继承模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, const T1 x, const T2 y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2,class T3&gt;</span><br><span class="line">class CC : public BB&lt;T2, T3&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_a;</span><br><span class="line">public:</span><br><span class="line">CC(T1 a, T2 x, T3 y);</span><br><span class="line">~CC();</span><br><span class="line">void func3();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1,T2 ,T3&gt;::CC(T1 a,T2 x,T3 y):m_a(a), BB&lt;T2,T3&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了CC的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1, T2, T3&gt;::~CC()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了CC析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">void CC&lt;T1, T2, T3&gt;::func3()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func3()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">CC&lt;int ,int ,string&gt; cc_1(4,5,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">cc_1.func2();</span><br><span class="line">cc_1.func3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）模板类继承模板类参数给出的基类（不能是模板类）关注 <code>EE</code> 类 EE既是模板类，也是派生类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA() &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">AA(int a) &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">BB() &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">BB(int a) &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~BB() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CC</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CC() &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">CC(int a) &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~CC() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class DD</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DD() &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">DD(int a) &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD(T a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~DD() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class EE:public T//模板类继承模板阐述给出的基类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">EE():T() &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">EE(int a):T(a) &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE(int a)&quot; &lt;&lt; endl; &#125;//模板参数T调用基类构造函数</span><br><span class="line">~EE() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">EE&lt;AA&gt;ea1;//AA作为基类</span><br><span class="line">EE&lt;BB&gt;eb1;//BB作为基类</span><br><span class="line">EE&lt;CC&gt;ec1;//CC作为基类</span><br><span class="line">EE&lt;DD&lt;int&gt;&gt; ed1;//DD&lt;int&gt;作为基类 看上去像容器嵌套</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EE继承模板T，也就是他继承的是可以改变的，</p><h4 id="29-类模板-模板类与函数"><a href="#29-类模板-模板类与函数" class="headerlink" title="29.类模板-模板类与函数"></a>29.类模板-模板类与函数</h4><p>模板类可以用于函数的参数和返回值，有三种形式<br>1）普通函数，参数和返回值是模板类的实例化版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA&lt;int ,string&gt; func(AA&lt;int,string&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(AA&lt;int,string&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）函数模板，参数和返回值是某种模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板，参数和返回值的是模板类AA，这种不是通用的</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt; func(AA&lt;T1, T2&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(AA&lt;T1, T2&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）函数模板，参数和返回值是任意类型（支持普通类和米板类和其它类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板类，参数和返回值都是任意类型</span><br><span class="line">template&lt;typename T1&gt;</span><br><span class="line">T1 func(T1 &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(T1 &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法更规范，支持所有的类或者普通函数，第二种方法只支持AA这一种模板类，函数模板不管传入什么，只要符合函数内部程序就可以</p>]]></content>
    
    
    <summary type="html">C++学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL添加自定义XXX</title>
    <link href="https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89XXX/"/>
    <id>https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89XXX/</id>
    <published>2023-09-11T06:44:55.000Z</published>
    <updated>2023-09-13T09:13:19.549Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="哦，这些解密后的内容无法验证，不过你还是可以看看的。">  <script id="hbeData" type="hbeData" data-hmacdigest="da79ac6a7feec0eba324834689bb30212634e26506091f56cdea35ed465fd846">22af57287ee59bb36a4c5a3674ae7175e9ba87d1b08e855353ff04e6b3f142ed3fe92962bd9945ad32baab4a86d2aeaf890858386b4c8561844fb391a78ccac21f7c3f4524d4d35e347f2581cd69cefc3ea69f65e84c8eb6d827fcf6ae1e43637778d9e26aea85307bb31afd4dddd5d9b8694e46b51f72bd6c6b8688a253ee0c9acd2ba1ccdfeb7a87c53fcab56529bee2ae650f4dd8750dd5979f0d3945bd878d8f8ce02626f1a1d316fbe8908f1fcce813454d89fa26802c40a7b572ec30c63119db6d50c65dc80a6f2b8fb910f3104617a624ba832acd702911354aafa7106f3c5a2ddfea5515c5475499a182883cd94734f21eadfcd1ab5541d6c31245fdbccce44d2cc76301d5d89801cbb62c4264fd9b01085922af3fc1c6cb21c72d0b76ac1033154353644e37827794f878424b70e436ad0600d4226042eb5eb536f0d44b19033313e2803a06234640fe0a37265831d86c8e308a165d1235c768d48b819fd3f409eaac31de435ccc232b9e7c4a077c219a74813d19829d740b1732eb47218bf98b9f4fc03cf9148dff09e07669d5a7b7848c6d440ae396b9e42e830969c902c20dd18aea5fab907b779cb3207850a424b05a826beb91f939a94acdacdb10a2dca847f78dff8241a8a02c46d8081cf167aabab773106128a1dd3d61e8a368e8fdd64700005a3b3b5a52f51885d6da93b8d0522e1c518b25eb0f5e5dc181ded6684b33f196b57499579943cac5c8fdcb190c603f369fd15d5093fc8c504ecba220182dcff20ff946d540b2a71fe6e963e8d7ee8acaa4eee180d61e2ac3130f1120143e9df8ee5466c471693a836289415491076d8a1ff3ec1e87c9a5e1325d5a0ed9dd4a8659dab27b1e988cdb03bc3b9acaee07f090afd37d5cbfa15f835694ed226fa7e0faf4efce2f678895c03b7a53f154c0dc98cea3fbd95822036f3fb94a6d077b6306529f33f78d2f37e8608d6f08ffd61ba84668b7e9c94bc9bbbcda32604a0540cba108bc72faf5fbebb18b234744fdd7f683ffacf1e656a5a743a51271864535fb1f87587515e60833fc6c0afc6ef73b4e244da406bc2ac476146687a580ef1c804c90293959969f5026b2e3172afdfa403d7e25a8fadc4fff9aa6554efbab5f70cb9b695ca6588a15053042efad3d048acd66a50e6614fa46afe9351bdd462d81e157d8e6070a4f9fa1f9bf6b523e4a993cc5835aa9c7733eb7ff8404d124cae3f6376822f0c116daa9f9f869f7014830739256e73cfe944710f1ffe47b279e921a4a6e20bee2beb7ffb0ff518539c4a52a06f63c4ecd3fa4eee852ea8ad1766d03670de06c9102185e661fbeb2e0c78025259ba87446142a23ef81008ad923678376d0228729cf8005451ee54357e5dd428708f706d0f05fdb1a3a5489d433adce12b08721164baf31167b712a53bb532865d25486a6be50c85ba829b7d55789c5d00b0ebbbcd4ab091fa6dbaeab5d008e55ae30740d3089133c29596e475c4cdc48ee0995ed4c5a59f4cb1dff4a3f6fe65c019d4aa2e2f966bc6628eeb8f4955c205504cd50d3b7c376a42583f5de45128d5a1bf32fcdbe3066eb1d24daa7de21e3c36bde3c2f270b488ec35b4484c6108dc66db1cd011f6a21b8f64ebb61d68725de08d74f59fcd55dc24265b2e77ab5e801abe77a1ac7c2d03974e6b7d5b8bd72d94787dfa67d54bd84474ea11fa227ef7eac3075bcac90baacbf40efb4d719f383817d5b0047e280daa808ea75db5e260a70f534900c8e3292c46127caa2354949e8f00ea30f26e5734b0fca9bd56b4086bcded5f6327b8a14392422350426a669f564cd778519bdb5fd5f94d5e25bf546be52f733ec5549ac395caecf70a43bb79a28e259a2bfa209b8e86740a793c442135f7a54db5cb7f35c38921a051f70006bc2c16ea7e2bf09e46ae21c0c81a26ce4e7c656a8d06bfae484c7193280832a9f53e48dc5251d097fe1ee63195f578599af2498c8da9279d389005b5e3dc36160c75150e70dbb542671af54a119aa464821a5f45c7087b6e0f5dfc80b6ea7604f073afd00fff5360cfbcfb00b39a55dcde0cad94c17d2639db17dac04ee78a786e7bc37da690a09a68a97279e52fb018b89ef016bfc702407d7f0d2739a247d65850195ac17126a5e8326aa0e950ed9cd2d75a80ffefe9f13898b9ea63f57812598f47c08f3191cfffbbd0aacefb16029833730a3f8f33ef93602aba7cb787ba0bea4d08686a5145784db86ca1d352f1fad18eb5e16aa75053f2211d633aed8a4109edf8b46f615220ac0201021f47ec6682cbec40dc0d39744156d68031b632c4628c1d0630f8cf1577b49dc5882d068e99a09e1e1df1a74d8c8b6883a5b10ce55e0adfe7ac7a6bebd38190df64ed741f07704852c6f4312d0f5ef4ee4036a5d452abe63e56abf97c4d2f67af9905e5005065082d6dda78c797ccd263a642ae50e7c687109741c2fc65f460abb0e2fc0cbf25c35bcf1b07e35b1ce57cb2965d8cd1187823d90d8bc37f5968661e9e8609e378fc145dfb0b36d4180a6490bebdd8fd68a33638355c7e6a738b552fcf6924ea5f42cf2f26e1ddf93e3ad5672f99e90d80cba9c2a00e15909688f9bd403f210e1e749c9613490253a6b22ac5874d449ef5034c4722434f410608dfd43edd1433bb74e1377b1cdcfaf71c648b31ab8dd1a89a51ccfee0d222fa4340863dff4cb5c13401f2d85e4414cd641657319db368fcc251017b1d7325cf7f72834fbc56a22c2b74b81946b5112d605a21205355f3a425fb7310655c89dc5b3d4c18d2497911bb8f021594a18792138fc7b7e24e8dfec1c211ede1223420973c792ea360a4926bcd3bce09b46e295a0999955e6010cfeb62a104f566a0b825b5bc91402da338b8e32e4f5f98a49f1bf5ad0726bc2fc0e63cc5709e6a7867f7097fccd53e437b973896233ab567e76343ba2a9027ede1be089030e872de3628896e3233162a86579b93d4e640ba5efbf14ea6c438650a1033ebd4c62e529b556bd6b989ed1b8ecd1463886f419bd5915a055670df5d619d89b60417e41036afd598a43b437357b19035fb37c86463246de863ac51bf7b4903678b51d4e14ae165c9573284d86354b0f8cbad2dd86110f60162e43d97cad44e1a2623d45457abb78e6580419ffd5a541393d0a4a3390dc5d32080199e7e90166f806451103072ff0dcc5fb90f18b643054494608e0cb7b4402daeb91a641ae47af9c8fadf4dd7cac98df4e9dd1e9fa3022288f42f056e2e68063979aea41f6cb04d7fd703a322b391f7c86ded2fc42cca7ece9df7a7e79f694632f713dbb8d6186b8934384d3636e8d21c4b2cca35b51b4b6ab7a2054204e6bd0424b0295068d4c081ec26652066ba2e9134abc936f7cb408f5a3ed7a3f799a6b9ff8e758d94c5adfe64841e92f3c754a2496d6271c5ea6d983cbd5b66509d64a33fa043cedcf73e484fed3a46cc377137d554867cdf658f94db2e56192835f8469b874227136426cb50d99235724ce332b514d0c4f03df1aa4ad1105e08d9f4989c79ca27119cb31f36fb5af615c591b647e87ae8f07a067b5a576e0fcae7da5e9163bef8b4d69109b60222aadf4d0791d5c011ad8035740fc1af293521a2411ff9313e98807d8abd6a7cd0d58221c70e8b494d301de03886608ba7df77aa35b4a589fedf5b053c3f84e5f66dad259d0bbdb9afea3a43d9bbd67ed62055b0ef28825bc84159fe5963a6018a9de5b0c16c26e3b9f05d12b028a30e92218d81f941d1d3857a680b154c858441632183d569303b290f408c5ab3f2593afef697b269ca2b378f22b82d98e61b798dd1ccac5c1a2eb5fe7d9fefdcd10bc0914d510f3e532d4e5c2c863ab79935dc4e7e60ba0332b0d87d4ffa04f0fc66129ad263f96a14e3fc0d9c83743b9a1cc1c321a314d0c9c378485bb616864006948fc7e5b1fa31b45a2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请在此处输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">MDK KEIL添加自定义XXX</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL sct文件</title>
    <link href="https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%20sct%E6%96%87%E4%BB%B6/"/>
    <id>https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%20sct%E6%96%87%E4%BB%B6/</id>
    <published>2023-09-11T01:51:26.000Z</published>
    <updated>2023-09-11T02:47:02.174Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>sct:分散加载文件<br>分散加载文件主要由一个加载时域加多个运行时域组成；同一个文件中可以有多个载时域；</p><h5 id="加载时域格式如下所示："><a href="#加载时域格式如下所示：" class="headerlink" title="加载时域格式如下所示："></a>加载时域格式如下所示：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_region_name base_address max_size</span><br><span class="line">&#123;</span><br><span class="line">     execution_region_description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行时域格式如下："><a href="#运行时域格式如下：" class="headerlink" title="运行时域格式如下："></a>运行时域格式如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec_region_name base_address max_size</span><br><span class="line">&#123;</span><br><span class="line">     input_section_description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>load_region_name:为加载时域的名字，长度不超过31个字节</li><li>base_address:为加载时域的起始地址，即从该地址开始加载相关代码</li><li>max_size:为加载时域的最大范围，若实际大小超过该大小，链接器将会报错</li><li>execution_region_description:是对执行时域的描述</li><li>input_section_description:是对执行时域的描述</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00100000  &#123;    </span><br><span class="line">; 定义一个加载时域，域基址：0x08000000，域大小:0x00100000 ,对应实际 Flash 的大小</span><br><span class="line"></span><br><span class="line">ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address</span><br><span class="line">;定义一个运行时域，第一个运行时域必须和加载时域起始地址相同，否则库不能加载到该时域的</span><br><span class="line">;错误，其域大小一般也和加载时域大小相同</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">.ANY (+XO)</span><br><span class="line">&#125;</span><br><span class="line">RW_IRAM1 0x20000000 0x00020000  &#123;  ; RW data</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MDK KEIL sct文件</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>IAR Embedded学习笔记</title>
    <link href="https://goupos.top/2023/09/08/IAR%20Embedded/IAR%20Embedded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goupos.top/2023/09/08/IAR%20Embedded/IAR%20Embedded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-08T00:44:36.000Z</published>
    <updated>2023-10-25T06:52:18.572Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="IAR出现错误：Get-Alternative-File-解决办法"><a href="#IAR出现错误：Get-Alternative-File-解决办法" class="headerlink" title="IAR出现错误：Get Alternative File 解决办法"></a>IAR出现错误：Get Alternative File 解决办法</h4><ol><li>解决方法：点击 <code>Project</code> -&gt; <code>Rebuild All</code> </li><li>错误原因：出现这种错误的大多数原因是直接用例程，而例程在人家电脑上编译的，对应的路径文件也是人家电脑上的，所以必须重新rebuild一下对应到自己的电脑上。</li></ol><h4 id="Driver-Fatal-error-Failed-to-search-for-probes-ensure-that-the-USB-drivers-areinstallled-Session-aborted"><a href="#Driver-Fatal-error-Failed-to-search-for-probes-ensure-that-the-USB-drivers-areinstallled-Session-aborted" class="headerlink" title="Driver Fatal error: Failed to search for probes, ensure that the USB drivers areinstallled. Session aborted!"></a>Driver Fatal error: Failed to search for probes, ensure that the USB drivers areinstallled. Session aborted!</h4><ol><li>解决方法：点击 <code>Project</code> -&gt; <code>Options for node</code> -&gt; <code>Debugger</code> -&gt; <code>Driver</code> -&gt;选择对应烧入器</li><li>错误原因：烧入器选择错误。</li></ol><h4 id="IAR的警告-Warning-Pa050-non-native-end-of-line-sequence-detected-this-diagnostic-is-only-issued-once"><a href="#IAR的警告-Warning-Pa050-non-native-end-of-line-sequence-detected-this-diagnostic-is-only-issued-once" class="headerlink" title="IAR的警告: Warning[Pa050]: non-native end of line sequence detected (this diagnostic is only issued once)."></a>IAR的警告: Warning[Pa050]: non-native end of line sequence detected (this diagnostic is only issued once).</h4><p>先来说说这个警告产生的原因: 在Windows中换行符使用 <code>&lt;CR&gt;&lt;LF&gt;</code> 来表示换行, 在UNIX类系统中则使用 <code>&lt;LF&gt;</code>. 当一个文件从一个系统转换到另外一个系统, 因为换行符的定义不同, 就会产生问题<br>知道了原因, 但问题依然不好解决. 有时候可能有几百个上千个文件从Linux平台转到Windown平台编译, 总不能一个一个的改吧? 好在此警告对结果并没影响, 所以采取简单粗暴的方式, 将它屏蔽掉, 眼不见心不烦.</p><p>解决方法： 点击 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Diagnostics</code> -&gt; <code>Suppress these diagnostics</code> -&gt; <code>填写 Pa050</code> 警告就消失了</p><h4 id="IAR设置堆栈和进程内存布局"><a href="#IAR设置堆栈和进程内存布局" class="headerlink" title="IAR设置堆栈和进程内存布局"></a>IAR设置堆栈和进程内存布局</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>Linker</code>功能菜单 -&gt; <code>Config</code>选项 -&gt; <code>Linker configuration file</code>选项框 -&gt; <code>Edit</code></p><h4 id="IAR设置堆栈时出现：-Auxliary-file-path-xxx-is-missing-or-corrupt-The-linker-configuration-file-can-only-be-edited-in-a-text-editor"><a href="#IAR设置堆栈时出现：-Auxliary-file-path-xxx-is-missing-or-corrupt-The-linker-configuration-file-can-only-be-edited-in-a-text-editor" class="headerlink" title="IAR设置堆栈时出现： Auxliary file path:xxx is missing or corrupt.The linker configuration file can only be edited in a text editor."></a>IAR设置堆栈时出现： <code>Auxliary file path:xxx is missing or corrupt.The linker configuration file can only be edited in a text editor.</code></h4><p>解决方法： 暂时没有找到</p><h4 id="IAR窗口恢复默认"><a href="#IAR窗口恢复默认" class="headerlink" title="IAR窗口恢复默认"></a>IAR窗口恢复默认</h4><p>解决方法： 1. 关闭IAR； 2.定位到工程目录下的settings文件夹； 3. 找到扩展名为.wsdt的文件； 4. 删除该类型的文件； 5. 重新打开工程。</p><h4 id="IAR-添加目标头文件"><a href="#IAR-添加目标头文件" class="headerlink" title="IAR 添加目标头文件"></a>IAR 添加目标头文件</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Preprocessor</code> -&gt; <code>Additional include directories: (one per line)</code> -&gt; <code>···</code> 建议头文件转换成如下格式，方便后续人员使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$PROJ_DIR$\..\Cmsis</span><br><span class="line">$PROJ_DIR$\..\Lib\inc</span><br><span class="line">$PROJ_DIR$\..\Lib\src</span><br></pre></td></tr></table></figure><p>点击<code>···</code> 进入后，输入一下路径，后面有一个下拉按钮选择路劲格式</p><h4 id="IAR-添加全局宏定义"><a href="#IAR-添加全局宏定义" class="headerlink" title="IAR 添加全局宏定义"></a>IAR 添加全局宏定义</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Preprocessor</code> -&gt; <code>Defined symbols: (one per line)</code> 格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE_STDPERIPH_DRIVER</span><br><span class="line">USING_LOG</span><br></pre></td></tr></table></figure><h4 id="IAR-擦除FLASH"><a href="#IAR-擦除FLASH" class="headerlink" title="IAR 擦除FLASH"></a>IAR 擦除FLASH</h4><p>擦除全部存储空间：<code>Project</code> -&gt; <code>Download</code> -&gt; <code>Erase Memory</code></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <summary type="html">IAR Embedded学习笔记</summary>
    
    
    
    <category term="IAR Embedded" scheme="https://goupos.top/categories/IAR-Embedded/"/>
    
    
    <category term="IAR Embedded" scheme="https://goupos.top/tags/IAR-Embedded/"/>
    
  </entry>
  
  <entry>
    <title>ARM汇编语言(1)</title>
    <link href="https://goupos.top/2023/09/04/ARM%E5%86%85%E6%A0%B8/ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(1)/"/>
    <id>https://goupos.top/2023/09/04/ARM%E5%86%85%E6%A0%B8/ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(1)/</id>
    <published>2023-09-04T05:31:25.000Z</published>
    <updated>2023-09-15T09:16:04.118Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="哦，这些解密后的内容无法验证，不过你还是可以看看的。">  <script id="hbeData" type="hbeData" data-hmacdigest="0699c0fbcd07fc34b745ea1246eb1035c75d101e4053f77317a636b9c666f0d1">f496cd034c8aee30e043308baebb9aa1749c213bc84bf71ed4b391462c9cbd2439b82bd456529492e7e8a4b9ac0a7cd8512a27ca9804b21d779c2e61b3ce7f3a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请在此处输入密码">请在此处输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">ARM汇编语言(1)</summary>
    
    
    
    <category term="ARM内核" scheme="https://goupos.top/categories/ARM%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="ARM内核" scheme="https://goupos.top/tags/ARM%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>c语言关键字执行顺序</title>
    <link href="https://goupos.top/2023/09/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://goupos.top/2023/09/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2023-09-02T12:05:47.000Z</published>
    <updated>2023-09-02T12:30:30.088Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-for-关键字执行顺序。"><a href="#1-for-关键字执行顺序。" class="headerlink" title="1. for 关键字执行顺序。"></a>1. <code>for</code> 关键字执行顺序。</h4><figure class="highlight plaintext"><figcaption><span>for</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include  &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint8_t i = 0;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    for(i = 0 ,printf(&quot;for 1\t&quot;); i &lt; 3 ,printf(&quot;for 2\t&quot;); i++ ,printf(&quot;for 3\t&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">        if(i == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 1   for 2   i = 0 初始化时候</span><br><span class="line">for 3   for 2   i = 1 运行时候</span><br><span class="line">for 3   for 2   i = 2</span><br><span class="line">for 3   for 2   i = 3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">c语言关键字执行顺序</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c语言关键字执行顺序" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Office中文离线安装包下载地址合集</title>
    <link href="https://goupos.top/2023/08/31/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/Office%E4%B8%AD%E6%96%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%88%E9%9B%86/"/>
    <id>https://goupos.top/2023/08/31/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/Office%E4%B8%AD%E6%96%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%88%E9%9B%86/</id>
    <published>2023-08-31T04:14:29.000Z</published>
    <updated>2023-08-31T04:15:40.792Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <summary type="html">Office中文离线安装包下载地址合集</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>BAT文件</title>
    <link href="https://goupos.top/2023/08/29/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/BAT%E6%96%87%E4%BB%B6/"/>
    <id>https://goupos.top/2023/08/29/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/BAT%E6%96%87%E4%BB%B6/</id>
    <published>2023-08-29T13:48:28.000Z</published>
    <updated>2023-08-29T13:51:17.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>参考源<br>正在编写</p></blockquote>]]></content>
    
    
    <summary type="html">BAT文件</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>win纯净系统安装注册等</title>
    <link href="https://goupos.top/2023/08/27/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/win%E5%AE%89%E8%A3%85/"/>
    <id>https://goupos.top/2023/08/27/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/win%E5%AE%89%E8%A3%85/</id>
    <published>2023-08-26T23:03:27.000Z</published>
    <updated>2023-08-29T13:03:09.595Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>由于图库存在问题，暂时没有图片<br>需要准备的，需要准备一台电脑和一个U盘，建议选择USB3.0或以上的，这样插在USB3.0接口上，安装系统更快，U盘大小选择8G</p></blockquote><h1 id="1-原装-windows-点击此处进入：windows系统"><a href="#1-原装-windows-点击此处进入：windows系统" class="headerlink" title="1. 原装 windows 点击此处进入：windows系统"></a>1. 原装 <code>windows</code> 点击此处进入：<a href="https://www.microsoft.com/zh-cn/software-download/">windows系统</a></h1><ol><li>安装教程如下视频：（引用别人视频，可以登入bilbil账号查看高清）</li><li>选择想要安装的系统点击进入，选择立即下载工具，然后安装工具，根据安装提示操作，制作操作系统选择U盘制作，下面是视频(个别地方可以根据自己需求修改)<iframe src="//player.bilibili.com/player.html?aid=342656275&bvid=BV1e94y1y7zS&cid=752740223&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol><h1 id="2-windows注册"><a href="#2-windows注册" class="headerlink" title="2.windows注册"></a>2.windows注册</h1><ol><li>注册成专业版，以 <code>管理员身份</code> 启动 &#96;cmd.exe（命令提示符）,依次输入如下代码(注意一定要用管理员启动，否则可能注册失败)<br>下面两个注册码任选一个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ipk 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure></li><li>关于如何使用使用 <code>管理员身份</code> 启动 <code>cmd.exe（命令提示符）</code>：<br> 方法一、可以在win左下角搜索框中输入 <code>cmd.exe</code> 然后右击会提示管理员启动；<br> 方法二、按下<code>win</code> + <code>r</code>按键（如下视频中会有），然后在任务栏中找到 <code>cmd.exe（命令提示符）</code>鼠标右击可以看到命令提示符，然后选择命令提示符再次右击，就可以看到以管理员身份运行，然后再输入上面的命令。</li><li>相关参考视频可以参考如下<iframe src="//player.bilibili.com/player.html?aid=637362623&bvid=BV1jb4y1p7mr&cid=549239255&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol>]]></content>
    
    
    <summary type="html">win纯净系统安装注册等</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>娱乐C语言</title>
    <link href="https://goupos.top/2023/08/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/"/>
    <id>https://goupos.top/2023/08/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/</id>
    <published>2023-08-26T02:59:12.000Z</published>
    <updated>2023-09-01T06:43:04.063Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>收集娱乐C代码(只为了收集不做任何其他用)<br>点击 <code>0</code> 项，可以直接导航到在线编译器，可以验证下列代码以及猜想,欢迎提供更多娱乐代码</p></blockquote><h5 id="0-代码验证导航"><a href="#0-代码验证导航" class="headerlink" title="0.代码验证导航"></a>0.<a href="https://rextester.com/l/c_online_compiler_gcc"><code>代码验证导航</code></a></h5><h5 id="1-娱乐代码示例一：使用-替换所有-参考于网友给的截图-图一乐就好"><a href="#1-娱乐代码示例一：使用-替换所有-参考于网友给的截图-图一乐就好" class="headerlink" title="1. 娱乐代码示例一：使用 - 替换所有 (参考于网友给的截图,图一乐就好)"></a>1. 娱乐代码示例一：使用 <code>-</code> 替换所有 (参考于网友给的截图,图一乐就好)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define __ main</span><br><span class="line">#define _____ int</span><br><span class="line">#define ___ printf</span><br><span class="line">#define ____ &quot;TIME&quot;</span><br><span class="line">#define ______ return</span><br><span class="line">#define _______ 0</span><br><span class="line">#define _ ;</span><br><span class="line">#define ________ &quot;%s\n&quot;</span><br><span class="line">#define _________ &quot;test&quot;</span><br><span class="line">#define __________ (</span><br><span class="line">#define ___________ )</span><br><span class="line">#define ____________ ,</span><br><span class="line"></span><br><span class="line">_____ __()</span><br><span class="line">&#123;</span><br><span class="line">    ___ __________ ________ ____________ _________ ___________ _</span><br><span class="line">    ___ __________ ________ ____________ ____ ___________ _</span><br><span class="line">    ______ _______ _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>运行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">TIME</span><br></pre></td></tr></table></figure><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5>]]></content>
    
    
    <summary type="html">娱乐C语言</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="娱乐C语言" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>GD32芯片索引</title>
    <link href="https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%B4%A2%E5%BC%95/"/>
    <id>https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%B4%A2%E5%BC%95/</id>
    <published>2023-08-22T09:49:14.000Z</published>
    <updated>2023-08-22T09:57:12.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文件只是问题索引，不展示任何数据</p></blockquote><span id="more"></span><h1 id="1-问题索引"><a href="#1-问题索引" class="headerlink" title="1.问题索引"></a>1.问题索引</h1><h1 id="2-笔记索引"><a href="#2-笔记索引" class="headerlink" title="2.笔记索引"></a>2.笔记索引</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文件只是问题索引，不展示任何数据&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="FPGA" scheme="https://goupos.top/categories/FPGA/"/>
    
    
    <category term="FPGA" scheme="https://goupos.top/tags/FPGA/"/>
    
  </entry>
  
  <entry>
    <title>GD32芯片故障与原因</title>
    <link href="https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E6%95%85%E9%9A%9C%E4%B8%8E%E5%8E%9F%E5%9B%A0/"/>
    <id>https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E6%95%85%E9%9A%9C%E4%B8%8E%E5%8E%9F%E5%9B%A0/</id>
    <published>2023-08-22T09:48:41.000Z</published>
    <updated>2023-08-22T09:48:41.679Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>GD32芯片笔记</title>
    <link href="https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-08-22T09:48:17.000Z</published>
    <updated>2023-08-22T09:48:17.323Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>USB复合和组合设备</title>
    <link href="https://goupos.top/2023/05/27/USB%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91/USB%E5%A4%8D%E5%90%88%E5%92%8C%E7%BB%84%E5%90%88%E8%AE%BE%E5%A4%87/"/>
    <id>https://goupos.top/2023/05/27/USB%E8%AE%BE%E5%A4%87%E5%BC%80%E5%8F%91/USB%E5%A4%8D%E5%90%88%E5%92%8C%E7%BB%84%E5%90%88%E8%AE%BE%E5%A4%87/</id>
    <published>2023-05-26T21:22:10.000Z</published>
    <updated>2023-05-28T08:21:03.588Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章参考源<br>1.<a href="1">STM32 USB复合设备编写</a><br>2.<a href="2">USB组合设备 Interface Association Descriptor (IAD)</a><br>3.<a href="3">STM32 USB复合设备(VCP虚拟串口+HID键盘)详解</a></p></blockquote><p>Communication Device Class，简称CDC<br>USB Compound Device，USB复合设备<br>USB Composite Device，USB组合设备</p>]]></content>
    
    
    <summary type="html">USB复合和组合设备配置和描述</summary>
    
    
    
    <category term="USB" scheme="https://goupos.top/categories/USB/"/>
    
    
    <category term="USB" scheme="https://goupos.top/tags/USB/"/>
    
  </entry>
  
  <entry>
    <title>单片机hex和bin​文件有什么区别</title>
    <link href="https://goupos.top/2023/04/12/STM32/%E5%8D%95%E7%89%87%E6%9C%BAhex%E5%92%8Cbin%E2%80%8B%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://goupos.top/2023/04/12/STM32/%E5%8D%95%E7%89%87%E6%9C%BAhex%E5%92%8Cbin%E2%80%8B%E6%96%87%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2023-04-12T13:10:26.000Z</published>
    <updated>2023-08-21T02:04:10.256Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考源：<br><a href="https://developer.arm.com/search#q=intel%20hex%20file%20format&cf[navigationhierarchiesproducts]=Tools%20and%20Software">Hex文件格式</a><br><a href="https://developer.arm.com/search#q=axf%20file%20format&cf[navigationhierarchiesproducts]=Tools%20and%20Software">axf文件格式</a><br><a href="https://developer.arm.com/search#q=bin&cf[navigationhierarchiesproducts]=Tools%20and%20Software">Bin文件格式</a></p></blockquote><span id="more"></span><p>1.这里就不介绍Hex和bin文件了。</p><hr><h1 id="bin文件"><a href="#bin文件" class="headerlink" title="bin文件"></a>bin文件</h1><ol><li><p>bin 是 binary 的缩写，直白的翻译即为二进制文件，在这里理解为可执行的机器代码（程序）文件，因为计算机存储只有 0 和 1。</p></li><li><p>bin 除了是程序文件的含义，还有其他含义，比如虚拟光驱文件，我们下载的一个 Windows 镜像文件后缀就可能是bin。</p></li><li><p>bin 相对于hex、axf是一种最简单的程序文件，只有程序数据，程序文件有多大，程序也就多大。</p></li><li><p>因此，你下载 bin 程序文件的时候，必须要设置起始地址，比如：通过STM32 ST-LINK Utility工具下载bin文件：</p></li></ol><p><a href="https://mmbiz.qpic.cn/sz_mmbiz_png/ju1DzqX8iaOkMLjBwcVQ6LmJaqhEmLL6o6dwibeB5eDiceouM2qbhNugEltFZoAXFyPWjzFywviaLw0ianMvtCOvpKQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">STM32 ST-LINK</a></p><p>而hex则不可修改（文件中包含地址信息）：<br><a href="https://mmbiz.qpic.cn/sz_mmbiz_png/ju1DzqX8iaOkMLjBwcVQ6LmJaqhEmLL6oVnG0tjcX5pbDfnY0xh5ICRjOYqdaZ9a9iaxnzxDaWUFC3MzAvYylicvg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">STM32 ST-LINK</a></p><hr><h1 id="Hex文件"><a href="#Hex文件" class="headerlink" title="Hex文件"></a>Hex文件</h1><ol><li>hex 格式文件由 Intel 制定的一种十六进制标准文件格式，是由编译器转换而成的一种用于下载到处理器里面的ASCII文本文件。</li></ol><p><a href="https://en.wikipedia.org/wiki/Intel_HEX">维基百科解释</a></p><blockquote><p>Intel HEX is a file format that conveys binary information in ASCII text form. It is commonly used for programming microcontrollers, EPROMs, and other types of programmable logic devices. In a typical application, a compiler or assembler converts a program’s source code (such as in C or assembly language) to machine code and outputs it into a HEX file. The HEX file is then imported by a programmer to “burn” the machine code into a ROM, or is transferred to the target system for loading and execution.<br>IntelHEX 是一种以 ASCII 文本格式传递二进制信息的文件格式。它通常用于编程微控制器，EPROM 和其他类型的可编程逻辑器件。在典型的应用程序中，编译器或汇编器将程序的源代码(如 C 或汇编语言)转换为机器代码并输出到 HEX 文件中。HEX 文件然后由程序员导入，将机器代码“刻录”到 ROM 中，或者传输到目标系统进行加载和执行。</p></blockquote><p><a href="https://www.keil.com/support/docs/1584/">Keil官网解释</a></p><blockquote><p>The Intel HEX file is an ASCII text file with lines of text that follow the Intel HEX file format. Each line in an Intel HEX file contains one HEX record. These records are made up of hexadecimal numbers that represent machine language code and&#x2F;or constant data. Intel HEX files are often used to transfer the program and data that would be stored in a ROM or EPROM. Most EPROM programmers or emulators can use Intel HEX files.<br>英特尔十六进制文件是一个 ASCII 文本文件，文本行遵循英特尔十六进制文件格式。英特尔十六进制文件中的每一行都包含一条十六进制记录。这些记录由表示机器语言代码和&#x2F;或常量数据的十六进制数组成。英特尔十六进制文件往往是用来传输程序和数据，将存储在 ROM 或 EPROM。大多数 EPROM 程序员或模拟器可以使用 Intel HEX 文件。</p></blockquote><h2 id="Hex格式"><a href="#Hex格式" class="headerlink" title="Hex格式"></a>Hex格式</h2><p>:BBAAAATT 【D···D】CC</p><table><thead><tr><th align="center">行开始</th><th align="center">数据长度</th><th align="center">地址</th><th align="center">数据类型</th><th align="center">数据</th><th align="center">校验和</th></tr></thead><tbody><tr><td align="center">..</td><td align="center">BB</td><td align="center">AAAA</td><td align="center">TT</td><td align="center">【D···D】</td><td align="center">CC</td></tr><tr><td align="center"></td><td align="center">1字节</td><td align="center">2字节</td><td align="center">1字节</td><td align="center">n字节</td><td align="center">1字节</td></tr></tbody></table><dl><dt>其中：</dt><dd>代表行开始，固定为冒号:</dd></dl><p>BB代表Bytes，数据长度</p><p>AAAA代表Address，地址</p><p>TT代表Type，数据类型（标识）</p><p>D···D代表Date，数据</p><p>CC代表CheckSum，校验和</p><p>说明：</p><p>BB数据长度，也就是D···D这个字段的数据长度；</p><p>AAAA地址，起始地址、偏移地址，根据数据类型(TT)有关；</p><p>TT数据类型（标识）：</p><p>00：数据标识</p><p>01：文件结束标识</p><p>02：扩展段地址</p><p>04：线性地址</p><p>05：线性开始地址</p><p>（地址代表高16位地址，也就是要向左移16bit）这里指的是数据类型中 02 04 05中的地址。</p><p>CC校验和计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckSum = 0x100 - (Sum &amp; 0xFF)</span><br></pre></td></tr></table></figure><h1 id="实例描述Hex"><a href="#实例描述Hex" class="headerlink" title="实例描述Hex"></a>实例描述Hex</h1><p>下面通过一个例子来说明hex。<br>说明一下：不同数据类型的数据略有差异，先再看下00（数据类型）的格式：<br><a href="https://mmbiz.qpic.cn/sz_mmbiz_png/ju1DzqX8iaOkMLjBwcVQ6LmJaqhEmLL6og5Gw843S1aV9TgwuHcVuGyn6IG4hc4FD9kcbRasVo1yp5gb5JKAZlQ/640?wx_fmt=png">00数据类型格式</a></p><p>一个常见hex文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:020000040800F2</span><br><span class="line">:1000000000040020B1010008FD020008BD02000844</span><br><span class="line">:10001000F902000801020008350400080000000091</span><br><span class="line">:1000200000000000000000000000000021030008A4</span><br><span class="line">···省略数行</span><br><span class="line">:100470000000024084040008000000200004000086</span><br><span class="line">:040480004804000824</span><br><span class="line">:040000050800019955</span><br><span class="line">:00000001FF</span><br></pre></td></tr></table></figure><ol><li>04类型：线性地址行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:020000040800F2</span><br></pre></td></tr></table></figure><p>02：数据长度，这里是（0800）地址的2字节长度；<br>0000：偏移地址，这里数据其实无效；<br>04：线性地址数据类型；<br>0800：线性起始地址，左移16位，即：0x0800 0000；<br>F2：校验和<br>F2 &#x3D;  0x100 - (0x02 + 0x04 + 0x08)&amp;0xFF;</p><p>比如，修改起始地址为0600：<br><a href="https://mmbiz.qpic.cn/sz_mmbiz_png/ju1DzqX8iaOkMLjBwcVQ6LmJaqhEmLL6oPicDyjzRKRcKkPHXNIyo8jK4I2GPYgRoYvjNwDuJtJZqgYTyibVQnAWQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1">修改起始地址</a></p><ol start="2"><li>00类型：数据行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1000000000040020B1010008FD020008BD02000844</span><br></pre></td></tr></table></figure><p>10：数据长度，这里是16字节（程序）数据的长度；</p><p>0000：偏移地址，数据第一行偏移0000地址，第二行就是偏移0010，第二行就是偏移0020，依次偏移到FFF0；<br>如果偏移到FFF0，则会重新下一个起始地址，一段程序你就明白了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">:10FFD000D0C5CFA20D0A00003052010810B50A4862</span><br><span class="line">:10FFE00002F0FEFC09A002F0FBFC14A002F0F8FCF9</span><br><span class="line">:10FFF0001EA221A123A002F0F3FC2CA002F0F0FC31</span><br><span class="line">:020000040801F1</span><br><span class="line">:10000000394802F0EDFC10BD3C5301080D0A2A20CE</span><br><span class="line">:1000100020202020202020202020202020202020E0</span><br><span class="line">:100020002020202020202020202020414756D6C7F5</span><br></pre></td></tr></table></figure><p>00：线性地址数据类型；</p><p>00040020B1010008FD020008BD020008：程序数据，就是bin文件里面的纯程序数据；</p><p>44：校验和</p><p>44 &#x3D;  0x100 - (0x10 + 0x04 + 0x20 + 0xB1 + 0x01 + 0x08 + 0xFD + 0x02 + 0x08 + 0xBD + 0x02 + 0x08 + 0x44) &amp; 0xFF;</p><ol start="3"><li>01类型：文件结束行</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:00000001FF</span><br></pre></td></tr></table></figure><p>00：数据长度；</p><p>0000：偏移地址，这里数据其实无效；</p><p>01：代表文件结束；</p><p>FF：校验和</p><p>更多细节内容，可以参看链接：<br>[参考源][7]</p><h1 id="bin和Hex区别"><a href="#bin和Hex区别" class="headerlink" title="bin和Hex区别"></a>bin和Hex区别</h1><p>bin文件只是单纯的程序数据，hex除程序数据之外还有一定格式数据。<br>在hex之上，还有一种axf文件，而 axf 和 bin、 hex 同样也属于程序文件，差别在于 axf 具有更多的调试信息。<br>用一个表格来区分bin、hex和axf三者的关系：</p><table><thead><tr><th align="left">bin</th><th align="left">hex</th><th align="left">axf</th></tr></thead><tbody><tr><td align="left">程序数据</td><td align="left">程序数据</td><td align="left">程序数据</td></tr><tr><td align="left"></td><td align="left">地址、类型、校验等标记信息</td><td align="left">地址、类型、校验等标记信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left">调试信息</td></tr></tbody></table><hr><p>[7]:</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考源：&lt;br&gt;&lt;a href=&quot;https://developer.arm.com/search#q=intel%20hex%20file%20format&amp;cf[navigationhierarchiesproducts]=Tools%20and%20Software&quot;&gt;Hex文件格式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.arm.com/search#q=axf%20file%20format&amp;cf[navigationhierarchiesproducts]=Tools%20and%20Software&quot;&gt;axf文件格式&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://developer.arm.com/search#q=bin&amp;cf[navigationhierarchiesproducts]=Tools%20and%20Software&quot;&gt;Bin文件格式&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>磁珠</title>
    <link href="https://goupos.top/2023/03/17/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E7%A3%81%E7%8F%A0/"/>
    <id>https://goupos.top/2023/03/17/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E7%A3%81%E7%8F%A0/</id>
    <published>2023-03-17T14:46:14.000Z</published>
    <updated>2023-03-18T01:04:20.290Z</updated>
    
    <content type="html"><![CDATA[<h1 id="磁珠的主要参数："><a href="#磁珠的主要参数：" class="headerlink" title="磁珠的主要参数："></a>磁珠的主要参数：</h1><ol><li>阻抗：磁珠阻抗是在100MHz时测得的阻抗所确定的。常表示为22R@100MHz，即为磁珠在100MHz下，其阻抗为22Ω。阻抗越大，抑制噪声的效果越好，我理解为阻抗越大，消耗在阻抗上的能量则越大，更容易让噪声以热量形式散出，从而达到抑制效果。</li></ol><p> 100MHz在某种意义上只是一个标准，此频率并不是磁珠阻抗最大的时刻，因为磁珠在实际的应用中，随着频率的改变，随着电流的变化，阻抗都会相应的发生变化。</p><ol start="2"><li><p>DCR(直流电阻)：指直流电流通过磁珠时，磁珠呈现的电阻值，DCR一般越小越好，对有用信号的衰减越小。</p></li><li><p>额定电流：指磁珠正常工作时允许的最大电流。</p></li></ol><hr><h1 id="磁珠的选型"><a href="#磁珠的选型" class="headerlink" title="磁珠的选型"></a>磁珠的选型</h1><ol><li>磁珠频率阻抗曲线中 Z R X分别代表什么意义?<br> Z是阻抗曲线，R是直流电阻曲线，X是电抗曲线。磁珠主要用在高频滤波领域，主要关注阻抗和额定电流。在100MHz电抗达到峰值，阻抗越大，衰减越强滤波效果越好，但是直流损耗也就越大，这里主要看使用的效果，普通磁珠阻抗100到600欧姆，同时要保证电流不能超过额定值。</li></ol>]]></content>
    
    
    <summary type="html">磁珠</summary>
    
    
    
    <category term="硬件设计" scheme="https://goupos.top/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="磁珠" scheme="https://goupos.top/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E7%A3%81%E7%8F%A0/"/>
    
    
    <category term="硬件设计" scheme="https://goupos.top/tags/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>TVS选择</title>
    <link href="https://goupos.top/2023/03/15/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/TVS%E9%80%89%E6%8B%A9/"/>
    <id>https://goupos.top/2023/03/15/%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/TVS%E9%80%89%E6%8B%A9/</id>
    <published>2023-03-15T14:38:18.000Z</published>
    <updated>2023-03-15T17:17:41.722Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.icspec.com/news/article-details/2114340?type=prefecture">TVS文章参考源</a></p><hr><h1 id="加TVS"><a href="#加TVS" class="headerlink" title="加TVS"></a>加TVS</h1><ol><li><p>TVS(Transient Voltage Suppressor)，就是对电路中短暂存在的高电压进行抑制，以免此高电压对电路造成损害，或导致电路工作异常。</p></li><li><p>抗静电实验标准IEC61000-4-2，其中人体模型HBM(Human Body Model)用来模拟人体放电，机器模型MM(Machine Model)用来模拟金属等物体放电.</p></li></ol><p>对于电容 <strong>i&#x3D;c*du&#x2F;dt</strong> 电压的突变，会导致大的感生电流<br>对于电感 <strong>u&#x3D;L*di&#x2F;dt</strong> 电流的突变，会导致大的感生电压</p><hr><h1 id="如何选择防护器件"><a href="#如何选择防护器件" class="headerlink" title="如何选择防护器件"></a>如何选择防护器件</h1><p>我们设计一个产品，首先要明确，需要通过哪些标准，以及过什么等级。下面是最常采用的几个标准：<br>IEC 61000-4-2 静电放电抗扰度；<br>IEC 61000-4-4 电快速瞬变脉冲群抗扰度；<br>IEC 61000-4-5 浪涌抗扰度；</p><hr><h1 id="TVS主要参数"><a href="#TVS主要参数" class="headerlink" title="TVS主要参数"></a>TVS主要参数</h1><ol><li><p>Vrwm(Maximum continuous Reverse Working Voltage ) 最高工作电压，或者说截止电压。就是说，加这个电压时，管子仍然是截止的，或者说漏过去的电流非常小。那么超过这个最高工作电压，会怎么样呢？这里要注意，电压超过Vrwm后，TVS并不会马上动作，也不像有的文章说的会劣化，损坏，而是漏电流增加的速度快一些。</p></li><li><p>VBR(Breakdown Voltage) 击穿电压。当电压超过此电压，漏电流开始急剧增加。这里所谓击穿，不能理解为器件损坏，而是正常动作。</p></li><li><p>Vc(Clamping Voltage) 钳位电压。这也是一个重要指标，就是当一个电压很高的脉冲来了，TVS器件从截止状态，变为导通状态，电压被钳制在一个比较低的水平，电流从TVS通过，回流到地，从而保护了后级电路。</p></li><li><p>Ipp(Peak Pulse Current) 峰值脉冲电流。器件所能承受的最大脉冲电流。注意是脉冲，脉冲，脉冲，重要的事情说三遍。如果连续通过这么大的电流，马上死翘翘。Ipp乘上Vc 基本上等于器件峰值功率Ppp(Peak Pulse Power)。我们评估器件时，如果脉冲宽度比较窄，那么最大电流可以超过Ipp，相反，如果脉冲宽度比较宽，电流小于Ipp 也会造成器件损坏。</p></li><li><p>Cj(Junction Capacitor) 结电容。低速电路不用管，如果是高速电路，这个电容会导致信号变形。此电容越小越好。</p></li></ol><hr><h1 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h1><iframe src="//player.bilibili.com/player.html?aid=427304337&bvid=BV1w3411g7An&cid=742504168&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <summary type="html">TVS</summary>
    
    
    
    <category term="硬件设计" scheme="https://goupos.top/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="TVS" scheme="https://goupos.top/categories/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/TVS/"/>
    
    
    <category term="硬件设计" scheme="https://goupos.top/tags/%E7%A1%AC%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
