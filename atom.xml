<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  
  <link href="https://goupos.top/atom.xml" rel="self"/>
  
  <link href="https://goupos.top/"/>
  <updated>2023-12-21T09:43:15.339Z</updated>
  <id>https://goupos.top/</id>
  
  <author>
    <name>构造</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言算法</title>
    <link href="https://goupos.top/2023/12/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95/"/>
    <id>https://goupos.top/2023/12/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95/</id>
    <published>2023-12-19T03:15:03.000Z</published>
    <updated>2023-12-21T09:43:15.339Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>树的算法<br>树结构简介<br>度数（Degree）：每个节点所有子树的个数<br>层数（Level）：树的层数，<br>高度：树的最大层数</p><p>二叉树<br>存储方式：链表。对于n叉树，每个节点度数（子树）都不同，所以必须预留n个链接字段的最大空间，每个节点数据结构如下,浪费空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef node</span><br><span class="line">&#123;</span><br><span class="line">char data;</span><br><span class="line">node * link1;</span><br><span class="line">node * link2;</span><br><span class="line">...</span><br><span class="line">node * linkn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择排序法</p>]]></content>
    
    
    <summary type="html">C语言算法</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c语言关键字执行顺序" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>QT开发STL</title>
    <link href="https://goupos.top/2023/12/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/QT/QT%E5%BC%80%E5%8F%91STL/"/>
    <id>https://goupos.top/2023/12/19/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/QT/QT%E5%BC%80%E5%8F%91STL/</id>
    <published>2023-12-18T16:26:15.000Z</published>
    <updated>2023-12-18T16:29:41.049Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>容器类<br>Qt的容器类比STL（标准模板库）种的容器类更轻巧、安全和易于使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; aList;</span><br><span class="line">aList.append(&quot;Monday&quot;);</span><br><span class="line">aList.append(&quot;uesday&quot;);</span><br><span class="line">aList.append(&quot;Wednesday&quot;);</span><br><span class="line">QString str=aList[0];qDebug()&lt;&lt;str; //显示&quot;Monday&#x27;</span><br></pre></td></tr></table></figure><p>顺序容器通过元素在容器中的位置顺序存储和访问,没有key值概念的<br>关联容器通过键(key)存储和读取元素(有key值和value是同一个值，set的时候，只能看到一个值，这种就不存在关联；其他都有key值，找到value值)<br>Qt的容器类分为顺序容器和关联容器<br>顺序容器:QList（指针），QLinkedList（链表），QVector（），QStack（栈）和QQueue（队列）<br>关联容器QMap，QMultiMap，QHash，QMultiHash和QSet</p><p>QLis:数组列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QString&gt; list;</span><br><span class="line">list&lt;&lt;&quot;one&quot;&lt;&lt;&quot;two&quot;&lt;&lt;&quot;three&quot;;</span><br><span class="line">QString str1=list[1];//str1 == &quot;two&quot;</span><br><span class="line">QString str0=list.at(0);//str0 == &quot;one&quot;</span><br></pre></td></tr></table></figure><p>QLinkedList: 除了不提供下标索引的数据访问，和QList其他函数接口基本相同<br>QVector : 函数接口与QList几乎完全相同，访问性能更高，因为是连续存储.但是插入和删除不方便</p><p>QStack:LIFO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QStack&lt;int&gt; stack;</span><br><span class="line">stack.push(10);</span><br><span class="line">stack.push(20);</span><br><span class="line">stack.push(30);</span><br><span class="line">while(!stack.isEmpty())</span><br><span class="line">qDebug()&lt;&lt;stack.pop();</span><br></pre></td></tr></table></figure><p>Queue:FIFO 先进先出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QQueue&lt;int&gt; queue;</span><br><span class="line">queue.enqueue(10);</span><br><span class="line">queue.enqueue(20);</span><br><span class="line">queue.enqueue(30);</span><br><span class="line">while(!queue.isEmpty())</span><br><span class="line">qDebug()&lt;&lt;queue.dequeue();</span><br></pre></td></tr></table></figure><p>QSet:基于散列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QSet&lt;QString&gt; set;</span><br><span class="line">set&lt;&lt;&quot;dog&quot;&lt;&lt;&quot;cat&quot;&lt;&lt;&quot;tiger&quot;</span><br><span class="line">if(set.contains(&quot;cat&quot;))</span><br><span class="line">qDebug()&lt;&lt;&quot;the set has a cat&quot;;</span><br></pre></td></tr></table></figure><p>QMap:按键值的顺序存储（如果插入重复的值，就忽略，键值是唯一的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QMap&lt;QString,int&gt; map;</span><br><span class="line">map[&quot;one&quot;]=1;//如果不存在就会创建</span><br><span class="line">map[&quot;two&quot;]=2;</span><br><span class="line">map[&quot;three&quot;]=3;</span><br><span class="line">map.insert(&quot;four&quot;,4);</span><br><span class="line">map.remove(&quot;two&quot;);//删除&quot;two&quot;</span><br><span class="line">int num1=map[&quot;one&quot;];</span><br><span class="line">int num2=map.value[&quot;two&quot;];//没有&quot;two&quot;,就给默认值 0</span><br><span class="line">int num3=map[&quot;five&quot;];//没有&quot;five&quot;,就给默认值 0</span><br><span class="line">int timeout=map.value(&quot;TIMEOUT&quot;30);//没有TIMEOUT直接给个30</span><br><span class="line">qDebug()&lt;&lt;num1&lt;&lt;num2&lt;&lt;num3&lt;&lt;timeout;//1 0 0 30</span><br></pre></td></tr></table></figure><p>key:one two three four<br>value: 1 2-&gt;0 3 4</p><p>QMultiMap: QMap的子类，键值可以重复</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMultiMap&lt;QStringint&gt; map1,map2,map3;</span><br><span class="line">map1.insert(&quot;plenty&quot;,100);</span><br><span class="line">map1.insert(&quot;plenty&quot;,2000);</span><br><span class="line">map2.insert(&quot;plenty&quot;,5000);</span><br><span class="line">map3=map1+map2;//键值可以重复，所以这里map1和map2加在一起给map3</span><br><span class="line">qDebug()&lt;&lt;map3.size();//3</span><br><span class="line">QList&lt;int&gt; values=map3.values(&quot;plenty&quot;);//将plenty的值存储到values数组表中</span><br><span class="line">foreach(int i,values) //values 一个一个放入i中，然后打印出来</span><br><span class="line">qDebug()&lt;&lt;i; //5000 2000 100</span><br></pre></td></tr></table></figure><p>QHash必须提供”&#x3D;&#x3D;”于QMap用法类似，QMultiHash与QMultiMap用法类似</p><p>3.4容器类的迭代</p>]]></content>
    
    
    <summary type="html">QT开发</summary>
    
    
    
    <category term="QT" scheme="https://goupos.top/categories/QT/"/>
    
    
    <category term="QT" scheme="https://goupos.top/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>C++的STL容器</title>
    <link href="https://goupos.top/2023/12/18/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E7%9A%84STL%E5%AE%B9%E5%99%A8/"/>
    <id>https://goupos.top/2023/12/18/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E7%9A%84STL%E5%AE%B9%E5%99%A8/</id>
    <published>2023-12-18T04:30:20.000Z</published>
    <updated>2023-12-27T18:54:56.867Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="STL：标准模板库"><a href="#STL：标准模板库" class="headerlink" title="STL：标准模板库"></a>STL：标准模板库</h1><p>STL分为：容器、算法、迭代器<br>STL六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</p><p>1.容器: 各种数据结构，如vector、list、deque、set、map等,用来存放数据<br>2.算法: 各种常用的算法，如sort、find、copy、for_each等<br>3.迭代器: 扮演了容器与算法之间的胶合剂。<br>4.仿函数: 行为类似函数，可作为算法的某种策略<br>5.适配器:一种用来修饰容器或者仿函数或迭代器接口的东西<br>6.空间配置器:负责空间的配置与管理</p><p>序列式容器:强调值的排序，序列式容器中的每个元素均有固定的位置<br>关联式容器:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><h1 id="迭代器种类"><a href="#迭代器种类" class="headerlink" title="迭代器种类"></a>迭代器种类</h1><p>vector容器、存放内置数据类型（理解为数组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;//标准算法头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Myprint(int val)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;line:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;  value:&quot; &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//vector容器</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">//创建了一个vector容器，数组</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line"></span><br><span class="line">//向容器中插入数据</span><br><span class="line">v.push_back(10);</span><br><span class="line">v.push_back(20);</span><br><span class="line">v.push_back(30);</span><br><span class="line">v.push_back(40);</span><br><span class="line"></span><br><span class="line">//通过迭代器访问容器中的数据</span><br><span class="line">vector&lt;int&gt;::iterator itbegin = v.begin();//起始迭代器，指向容器中第一个元素</span><br><span class="line">vector&lt;int&gt;::iterator itend = v.end();//结束迭代器，指向容器中最后一个元素的下一个位置</span><br><span class="line"></span><br><span class="line">for (; itbegin &lt; itend; itbegin++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;line:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;  value:&quot; &lt;&lt; *itbegin &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第二种迭代器</span><br><span class="line">for (vector&lt;int&gt;::iterator itbegin = v.begin(); itbegin&lt; v.end(); itbegin++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;line:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;  value:&quot; &lt;&lt; *itbegin &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//第三种迭代器</span><br><span class="line">for_each(v.begin(), v.end(), Myprint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-容器中存放自定义数据类型"><a href="#vector-容器中存放自定义数据类型" class="headerlink" title="vector 容器中存放自定义数据类型"></a>vector 容器中存放自定义数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//vector 容器中存放自定义数据类型</span><br><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Person(string Name, int Age) :m_Name(Name), m_Age(Age)</span><br><span class="line">&#123;&#125;</span><br><span class="line">~Person()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">string m_Name;</span><br><span class="line">int m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line">Person P1(&quot;P1&quot;,10);</span><br><span class="line">Person P2(&quot;P2&quot;, 11);</span><br><span class="line">Person P3(&quot;P3&quot;, 12);</span><br><span class="line">Person P4(&quot;P4&quot;, 13);</span><br><span class="line">Person P5(&quot;P5&quot;, 14);</span><br><span class="line"></span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(P1);</span><br><span class="line">v.push_back(P2);</span><br><span class="line">v.push_back(P3);</span><br><span class="line">v.push_back(P4);</span><br><span class="line">v.push_back(P5);</span><br><span class="line">//遍历容器中数据 it指向一个Person的指针</span><br><span class="line">for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//cout &lt;&lt; &quot;name:&quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot;  age:&quot; &lt;&lt; (*it).m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot;  age:&quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//存放自定义数据类型的指针</span><br><span class="line">void test02(void)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line">Person P1(&quot;P1&quot;, 10);</span><br><span class="line">Person P2(&quot;P2&quot;, 11);</span><br><span class="line">Person P3(&quot;P3&quot;, 12);</span><br><span class="line">Person P4(&quot;P4&quot;, 13);</span><br><span class="line">Person P5(&quot;P5&quot;, 14);</span><br><span class="line"></span><br><span class="line">//向容器中添加数据</span><br><span class="line">v.push_back(&amp;P1);</span><br><span class="line">v.push_back(&amp;P2);</span><br><span class="line">v.push_back(&amp;P3);</span><br><span class="line">v.push_back(&amp;P4);</span><br><span class="line">v.push_back(&amp;P5);</span><br><span class="line"></span><br><span class="line">//遍历容器中数据 iterator it解引用</span><br><span class="line">for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">Person* p = (*it);</span><br><span class="line">//it -&gt; Person* it_TEMP = &amp;P1;</span><br><span class="line">//cout &lt;&lt; &quot;name:&quot; &lt;&lt; (*(*it)).m_Name &lt;&lt; &quot;  age:&quot; &lt;&lt; (*(*it)).m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;name:&quot; &lt;&lt; (*it)-&gt;m_Name &lt;&lt; &quot;  age:&quot; &lt;&lt; (*it)-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arv, char ** arg)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-容器嵌套容器"><a href="#vector-容器嵌套容器" class="headerlink" title="vector 容器嵌套容器"></a>vector 容器嵌套容器</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//容器嵌套容器</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; vv;</span><br><span class="line">//创建小容器</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">vector&lt;int&gt; v2;</span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">vector&lt;int&gt; v4;</span><br><span class="line">//向小容器中添加数据</span><br><span class="line">for (size_t i = 0; i &lt; 4; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back((i + 1) * 10);</span><br><span class="line">v2.push_back((i + 1) * 100);</span><br><span class="line">v3.push_back((i + 1) * 1000);</span><br><span class="line">v4.push_back((i + 1) * 10000);</span><br><span class="line">&#125;</span><br><span class="line">//小容器插入到大容器中</span><br><span class="line">vv.push_back(v1);</span><br><span class="line">vv.push_back(v2);</span><br><span class="line">vv.push_back(v3);</span><br><span class="line">vv.push_back(v4);</span><br><span class="line"></span><br><span class="line">//通过大容器，把所有数据遍历一遍</span><br><span class="line">for (vector&lt;vector&lt;int&gt;&gt;::iterator it = vv.begin(); it != vv.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//(*it)的值是一个 vector&lt;int&gt; 容器</span><br><span class="line">cout &lt;&lt; &quot;value:&quot;;</span><br><span class="line">for (vector&lt;int&gt;::iterator itt = (*it).begin();itt != (*it).end();itt++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (*itt) &lt;&lt; &quot;\t\t&quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arv, char ** arg)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-容器-构造函数"><a href="#string-容器-构造函数" class="headerlink" title="string 容器 构造函数"></a>string 容器 构造函数</h1><p>可以理解为字符串使用，本质是一个类,提供了很多的功能函数<br>构造函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string();//创建一个空的字符串 string str;</span><br><span class="line">string(const char * s);//使用字符串s初始化</span><br><span class="line">string(const string &amp;str);//用一个string对象创建另一个string对象</span><br><span class="line">string(int n,char c);//使用n个字符c初始化</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//string的构造函数</span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">char str[] = &#123; &quot;hello world&quot; &#125;;</span><br><span class="line">string s1;</span><br><span class="line">string s2(str);</span><br><span class="line">cout &lt;&lt; &quot;s2:&quot; &lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s3(s2);</span><br><span class="line">cout &lt;&lt; &quot;s3:&quot; &lt;&lt; s3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string s4(10, &#x27;a&#x27;);</span><br><span class="line">cout &lt;&lt; &quot;s4:&quot; &lt;&lt; s4 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arg,char** arv)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-赋值操作"><a href="#string-赋值操作" class="headerlink" title="string 赋值操作"></a>string 赋值操作</h1><p>给string字符串进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator=(const char*s);//char*类型字符串复制给当前的字符串</span><br><span class="line">string&amp; operator=(const string&amp;s);//把字符串s赋给当前的字符串</span><br><span class="line">string&amp; operator=(char c);//字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s);//把字符串s赋值给当前的字符串</span><br><span class="line">string&amp; assign(const char *s，int n);//把字符串s的前n个字符赋值给当前的字符串</span><br><span class="line">string&amp; assign(const string &amp;s);//把字符串s赋值给当前的字符串</span><br><span class="line">string&amp; assign(int n,char c);//用n个字符c赋值给当前字符串</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str1;</span><br><span class="line">str1 = &quot;hello world&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2;</span><br><span class="line">str2 = str1;</span><br><span class="line">cout &lt;&lt; &quot;str2=&quot; &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3;</span><br><span class="line">str3 = &#x27;a&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str4;</span><br><span class="line">str4.assign(&quot;hello C++&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str4=&quot; &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str5;</span><br><span class="line">str5.assign(&quot;hello C++&quot;,6);</span><br><span class="line">cout &lt;&lt; &quot;str5=&quot; &lt;&lt; str5 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str6;</span><br><span class="line">str6.assign(str4);</span><br><span class="line">cout &lt;&lt; &quot;str6=&quot; &lt;&lt; str6 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str7;</span><br><span class="line">str7.assign(50, &#x27;c&#x27;);</span><br><span class="line">cout &lt;&lt; &quot;str7=&quot; &lt;&lt; str7 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arv, char ** arg)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般 <code>=</code>赋值用的多</p><h1 id="string字符串拼接"><a href="#string字符串拼接" class="headerlink" title="string字符串拼接"></a>string字符串拼接</h1><p>实现在字符串末尾拼接字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string &amp;operator +=(const char *str);//重载+=操作符,str字符串连接到当前字符串结尾</span><br><span class="line">string &amp;operator +=(const char c);//重载+=操作符,c字符连接到当前字符串结尾</span><br><span class="line">string &amp;operator +=(const string &amp;str);//重载+=操作符,str字符串连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s);//把字符串s连接到当前字符串结尾</span><br><span class="line">string &amp;append(const char *s，int n);//把字符串s的前n个字符连接到当前字符串结尾</span><br><span class="line">string &amp;append(const string &amp;s);//把字符串s连接到当前字符串结尾,string &amp;operator +=(const string &amp;str)</span><br><span class="line">string &amp;append(const string &amp;s,int pos ,int n);//字符串s中从pos开始的后n个字符连接到字符串结尾</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str1(&quot;我&quot;);</span><br><span class="line">str1 += &quot;爱美女&quot;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str1 += &#x27;:&#x27;;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str2(&quot;xxxx&quot;);</span><br><span class="line">str1 += str2;</span><br><span class="line">cout &lt;&lt; &quot;str1=&quot; &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str3(&quot;I&quot;);</span><br><span class="line">str3.append(&quot; love&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str3.append(&quot; beautiful women: abcdef&quot;,17);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//str3.append(str2);</span><br><span class="line">//cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">str3.append(str2,0,2);</span><br><span class="line">cout &lt;&lt; &quot;str3=&quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arv, char ** arg)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-查找和替换"><a href="#string-查找和替换" class="headerlink" title="string 查找和替换"></a>string 查找和替换</h1><p>查找：查找指定字符串是否存在<br>替换：在指定的位置替换字符串</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int find(const string &amp;str ,int pos = 0)const;//查找str第一次出现位置，从pos开始查找</span><br><span class="line">int find(const char *s ,int pos= 0)const;//查找s第一次出现的位置，从pos开始查找</span><br><span class="line">int find(const char *s,int pos,int n)const;//从pos位置查找s的前n个字符第一次位置</span><br><span class="line">int find(const char c,int pos = 0)const;//查找字符c第一次出现的位置，从pos开始查找</span><br><span class="line">int rfind(const string&amp;str,int pos=npos)const;//查找str最后一次位置，从pos开始查找</span><br><span class="line">int rfind(const char *s ,int pos=npos)const;//查找s最后一次出现的位置，从pos开始查找</span><br><span class="line">int rfind(const char *s,int pos,int n)const;//从pos位置查找s的前n个字符最后一次位置</span><br><span class="line">int rfind(const char c,int pos =npos)const;//查找字符c最后一次出现的位置，从pos开始查找</span><br><span class="line">string &amp;replace(int pos ,int n,const string&amp;str);//替换从pos开始n个字符为字符串str</span><br><span class="line">string &amp;replace(int pos ,int n,const char *s);//替换从pos开始n个字符为字符串s</span><br></pre></td></tr></table></figure><p>字符在查找时候，我们是有一个起始的下标，指定开始从那开始查起<br>find与rfind区别<br>查到字符串：返回查找到字符串的首地址，否则返回-1<br>find查找是从左往右查找，如果指定位置，则从指定位置处往后查找； rfind是从右往左查找，如果指定位置，则从指定位置处往前查找</p><p>替换</p><p>如果替换字符长度在最后，会把需要替换的字符，合并到一起<br>replace在替换时，要指定从那个位置起（pos），多少个字符(n)，替换成什么样的字符串（str || s）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefghidede&quot;;</span><br><span class="line">int pos = str1.find(&quot;de&quot;,0);//查到字符串：返回查找到字符串的首地址，否则返回-1</span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到字符串，pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//find与rfind区别</span><br><span class="line">//find查找是从左往右查找，rfind是从右往左查找</span><br><span class="line">pos = str1.rfind(&quot;de&quot;,9);</span><br><span class="line">if (pos == -1)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;未找到字符串&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;找到字符串，pos = &quot; &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test02(void)</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;abcdefg&quot;;</span><br><span class="line">//从1号位置起3个字符替换为“1111”</span><br><span class="line">str1.replace(1,3,&quot;1111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str1 char * = &quot; &lt;&lt; str1 &lt;&lt; endl;//str1 char * = a1111efg</span><br><span class="line"></span><br><span class="line">string str2 = &quot;123456&quot;;</span><br><span class="line">str1.replace(str1.rfind(&#x27;g&#x27;,str1.size()),str2.size(),str2);</span><br><span class="line">//用str2替换g位置的数据，</span><br><span class="line">cout &lt;&lt; &quot;str1 string = &quot; &lt;&lt; str1 &lt;&lt; endl;//str1 string = a1111ef123456</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arg, char**arv)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-字符串的比较"><a href="#string-字符串的比较" class="headerlink" title="string 字符串的比较"></a>string 字符串的比较</h1><p>字符串之间的比较，两个字符串相等 返回0 ，第一个字符串大于第二个字符串 返回1 ，第二个字符串大于第一个字符串 返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int compare(const string &amp;s) const;//与字符串s比较</span><br><span class="line">int compare(const char *s) const;//与字符串s比较</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str1 = &quot;xello&quot;;</span><br><span class="line">string str2 = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">int compare = str1.compare(str2);</span><br><span class="line"></span><br><span class="line">switch (compare)</span><br><span class="line">&#123;</span><br><span class="line">case 0:</span><br><span class="line">cout &lt;&lt; &quot;str1 == str2&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case 1:</span><br><span class="line">cout &lt;&lt; &quot;str1 &gt; str2&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case -1:</span><br><span class="line">cout &lt;&lt; &quot;str1 &lt; str2&quot; &lt;&lt; endl;</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arg, char **arv)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-字符存取"><a href="#string-字符存取" class="headerlink" title="string 字符存取"></a>string 字符存取</h1><p>string 中单个字符存存取方式有两种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char &amp; operator[](int n);//通过[]方式取字符</span><br><span class="line">char &amp;at(int n);//通过at方法获取字符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">//</span><br><span class="line">//通过[] 访问单个字符</span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//修改单个字符</span><br><span class="line">str[0] = &#x27;x&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;//xello</span><br><span class="line">str.at(1) = &#x27;x&#x27;;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;//xxllo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arg, char **arv)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string-插入和删除"><a href="#string-插入和删除" class="headerlink" title="string 插入和删除"></a>string 插入和删除</h1><p>string 字符串进行插入和删除字符操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string &amp;insert(int pos const char *s);//插入字符串</span><br><span class="line">string &amp;insert(int pos ,string &amp;str);//插入字符串</span><br><span class="line">string &amp;insert(int pos ,int n,char c);//在指定位置插入n个字符c</span><br><span class="line">string %erase(int pos ,int n = npos);//删除从pos开始的n个字符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">//插入</span><br><span class="line">str.insert(1, &quot;111&quot;);</span><br><span class="line">cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl;//str = h111ello</span><br><span class="line">//删除</span><br><span class="line">str.erase(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;str = &quot; &lt;&lt; str &lt;&lt; endl;//str = hello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arg, char **arv)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="string子串"><a href="#string子串" class="headerlink" title="string子串"></a>string子串</h1><p>从字符串中获取想要的子串，使用子串可以获取到有用信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string &amp;substr(int pos = 0, int n = npos) const;//返回由pos开始的n个字符组成的字符串</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">string str = &quot;hello&quot;;</span><br><span class="line">string substr = str.substr(1, 3);</span><br><span class="line">cout &lt;&lt; &quot;substr = &quot; &lt;&lt; substr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实用操作</span><br><span class="line">void test02(void)</span><br><span class="line">&#123;</span><br><span class="line">string email = &quot;zhangsan@sina.com&quot;;</span><br><span class="line">//从邮件地址中获取用户名信息</span><br><span class="line">int pos = email.find(&#x27;@&#x27;, 0);</span><br><span class="line">//获取用户名称</span><br><span class="line">string userName = email.substr(0, pos);</span><br><span class="line">cout &lt;&lt; &quot;userName = &quot; &lt;&lt; userName &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int arv, char **arg)</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-容器-最常见的容器之一"><a href="#vector-容器-最常见的容器之一" class="headerlink" title="vector 容器 最常见的容器之一"></a>vector 容器 最常见的容器之一</h1><p>vector 数据结构和数组非常相似，也称为单端数组</p><p>vector 与普通数组区别：<br>不同之处在于数组是静态空间，而vector可以动态扩展<br>动态扩展：并不是在原空间之后续接新空间，而是找到更大的内存空间，然后将原数据拷贝新空间，释放原空间</p><p>vector 容器不会在前端插入数据，都是在尾部插入或删除数据 pusb_back pop_back<br>front()&#x2F;&#x2F;第一个元素<br>back()&#x2F;&#x2F;最后一个元素<br>常用的迭代器 begin() end()(指向最后一个元素的下一个位置)<br>rbegin:指向倒数第一个元素,rend()指向第一个元素的前一个位置 </p><p>vector 容器的迭代器是支持随机访问</p><h1 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;T&gt; V;//采用模板实现类实现，默认构造函数</span><br><span class="line">vector(v.begin(),v.end());//将v的begin()起始地址，到end()前一个地址数据拷贝给本身</span><br><span class="line">vector(n,elem);//构造函数将n个elem拷贝给本身,构造函数</span><br><span class="line">vector(const vector &amp;vec);//拷贝构造函数</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void test02(T begin,T end)</span><br><span class="line">&#123;</span><br><span class="line">for (T it = begin; it &lt; end; it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line"></span><br><span class="line">for (size_t i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;int &gt; v2(v1.begin(), v1.end() - 3);</span><br><span class="line">printVector(v2);</span><br><span class="line">test02(v2.begin(),v2.end());</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v3(10, 100);</span><br><span class="line">test02(v3.begin(), v3.end());</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v4(v3);</span><br><span class="line">test02(v4.begin(), v4.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#vector 赋值操作<br>给vector容器进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector &amp;operator=(const vector &amp;vec);//重载等号操作符(最简单的赋值方式)</span><br><span class="line">assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身</span><br><span class="line">assign(n,elem);//将n个elem拷贝赋值给本身</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt; &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01(void)</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">for (size_t i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end() - 3);</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; v4;</span><br><span class="line">v4.assign(10, 10);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-容量和大小"><a href="#vector-容量和大小" class="headerlink" title="vector 容量和大小"></a>vector 容量和大小</h1><p>对vector容器的容量和大小操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">empty();//判断容器是否为空 返回true表示容器为空，fasle表示容器不为空</span><br><span class="line">capacity();//容器的容量</span><br><span class="line">size();//返回容器中元素的个数 （capacity &gt;= size）</span><br><span class="line">resize(int num);//重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</span><br><span class="line">//如果容器变短，则末尾超出容器长度的元素被删除。</span><br><span class="line">resize(int num,elem);//重新指定容器的长度为num,若容器变长，则以elem值填充新位置</span><br><span class="line">//如果容器变短，则末尾超出容器长度的元素被删除。</span><br></pre></td></tr></table></figure><p>容器容量一定大于或等于元素个数，元素个数可能是不是满的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt; &amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test01()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">for (size_t i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">if (v1.empty())//为真 代表容器为空</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1 容器为空&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;v1 容器不为空&quot; &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v1的容量为: &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v1元素个数: &quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">//重新指定大小</span><br><span class="line">v1.resize(15);</span><br><span class="line">printVector(v1);//0 1 2 3 4 5 6 7 8 9 0 0 0 0 0</span><br><span class="line">//如果重新指定比的比原来长了，新增加的位置使用默认值0填充新的位置</span><br><span class="line">cout &lt;&lt; &quot;v1的容量为: &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v1元素个数: &quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1.resize(20,100);//指定默认填充值</span><br><span class="line">printVector(v1);//0 1 2 3 4 5 6 7 8 9 0 0 0 0 0 100 100 100 100 100</span><br><span class="line">//如果重新指定比的比原来长了，新增加的位置使用指定的值填充新的位置</span><br><span class="line">cout &lt;&lt; &quot;v1的容量为: &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v1元素个数: &quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">v1.resize(5);//如果重新指定的长度比原来短了，超出部分会删除掉</span><br><span class="line">printVector(v1);//0 1 2 3 4</span><br><span class="line">cout &lt;&lt; &quot;v1的容量为: &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;v1元素个数: &quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">test01();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vector-插入和删除"><a href="#vector-插入和删除" class="headerlink" title="vector 插入和删除"></a>vector 插入和删除</h1>]]></content>
    
    
    <summary type="html">C++学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>32位ARM芯片开发注意事项</title>
    <link href="https://goupos.top/2023/12/14/32%E4%BD%8DARM%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://goupos.top/2023/12/14/32%E4%BD%8DARM%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2023-12-14T03:00:31.000Z</published>
    <updated>2023-12-27T00:58:53.119Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>DMA配合串口传输数据相关问题<br>1.配置好传输数据数量和足够的时间，可能DMA无法传完成数据，导致下一次无法传输数据或错误数据，无法继续配置和传输数据<br>解决方法：第一开启错误检测中断，检测到错误，关闭传输，第二是每次传输数据前都可以检测上一次数据是否传输完成，第三是发送数据前，关闭DMA通道这样所有的配置数据可以写入到相关寄存器中</p><p>DMA配合ADC传输数据相关问题</p><p>DMA配合SPI传输数据相关问题</p><p>所有的不需要改动的配置尽量在使能前配置好，</p>]]></content>
    
    
    <summary type="html">32位ARM芯片开发</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>QT开发1</title>
    <link href="https://goupos.top/2023/12/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/QT/QT%E5%BC%80%E5%8F%911/"/>
    <id>https://goupos.top/2023/12/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/QT/QT%E5%BC%80%E5%8F%911/</id>
    <published>2023-12-02T03:18:32.000Z</published>
    <updated>2023-12-18T16:28:29.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>QT Windgets Application: 桌面平台的图形用户界面（GUI）应用程序<br>QT Console Application: 控制台应用程序，一般用于学习C&#x2F;C++<br>Qt Quick Application: 创建可部署的Qt Quick2应用程序。Qt Quick是Qt支持的一套GUI开发架构。采用QML设计界面，程序框架采用C++语言<br>Qt Quick Controls 2 Application: 创建基于Qt Quick Control2组件的可部署的Qt Quick 2 应用程序。<br>Qt Canvas 3D Application: 基于QML语言的界面设计，支持3D画布。</p><p>QMainWindow:主窗口类，具有主菜单、工具栏和状态栏，类似一般程序的主窗口<br>Qwidget:是所有具有可视化界面类的基类，各种界面组件都支持<br>QDialog:对话框类，建立基于对话框的界面</p><p>Action Editor:Action编辑器<br>Signals &amp; Slots Editor:信号与槽</p><p>Widget:Qwidget窗口：从上大小，继承关系（下面的都是派生类）</p><p>信号与槽<br>———————-发送者———–信号———–接受者———–槽———–<br>编写关闭Botton_closeclicked()Widget close()</p><p>很重要必须要看的文件<br>ui_widget.h:<br>ui_mainwindow.h:</p><p>项目中添加资源文件：<code>文件</code> -&gt; <code>新建文件或项目</code> -&gt; <code>QT</code> -&gt;<code>Qt Resource File</code>-&gt;输入名字，创建<code>*.qrc</code>文件<br>在项目中点击 ：<code>open in editor</code>可以打开文件<br><code>*.qrc</code>文件点击<code>Add Prefix</code>创建文件，修改相应的前缀, 点击<code>Add Files</code>添加相关文件</p><p>要在头文件中编写槽函数必须如下格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class XXX</span><br><span class="line">&#123;</span><br><span class="line">private slots://私有的槽函数如下</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>槽函数格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::connect(this-&gt;ui-&gt;radioButton_black, SIGNAL(clicked()), this, SLOT(setTextFontColor()));</span><br></pre></td></tr></table></figure><p>Action :非常有用的类，可以创建菜单项、工具栏按钮</p><p>快捷操作<br>——-功能————————快捷键————–解释————–<br>Switch Header&#x2F;Source F4在同名的头文件和源程序文件之间切换</p><p>Follow Symbol Under Cursor F2 变量：跳转到声明；函数：声明和定义切换</p><p>Switch Between FunctionShift+F2函数：声明和定义切换<br>Declartion and Definition</p><p>Refacetor\Rename SymbolCtrl+Shift+R 改名称，将替换所有用到这个符合的地方<br>Under Cursor</p><p>Refactor\Add Definitionin .cpp为函数原型在cpp文件中生成函数体</p><p>Auto-indent SelectionCtrl+I 为选择的文字自动进行缩进</p><p>Toggle Comment SelectionCtrl+&#x2F;注释或取消注释</p><p>ContextHelpF1为光标所在的符号显示帮助</p><p>Save AllCtrl+Shift+S 文件全部保存</p><p>qt核心特点<br>元对象编译器（meta-object Complier,MOC）是一个预处理器（所谓的元就是：meta在英文词中有超越、更上一层的含义。）<br>先将Qt的特性程序转换成标准C++程序，再由标准C++编译器进行编译<br>元对象的意义</p><p>使用信号与槽机制，只有添加Q_OBJECT宏，moc才能对类里的信号与槽进行预处理</p><p>Qt为C++语言增加的特性在Qt core模块里实现，由Qt的元对象系统实现包括:信号与槽机制、属性系统、动态类型转换等。</p><p>元对象系统 (Meta-Object System)<br>1.Qobject类是所有使用元对象系统的类的基类<br>2.在一个类的private部分声明Q_OBJECT宏<br>3.MOC(元对象编译器)为每个QObject的子类提供必要的代码</p><p>qobject_cast（类类型转换） 与 C++语言种 static_cast(数据类型之间转化) 、dynamic_cast</p><p>属性系统:<br>Q_PROPERTY宏定义一个返回类型为type!，名称为name的属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/516163795">https://zhuanlan.zhihu.com/p/516163795</a></p><p>信号与槽</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QMetaObject::Connection QObject::connect(const QObject *sender, const char *signal,const QObject *receiver, const char *member,Qt::ConnectionType = Qt::AutoConnection);</span><br><span class="line"></span><br><span class="line">//如果信号和槽函数带有参数，需要注明参数类型</span><br><span class="line">connect(spinNum,SIGNAL(valueChanged(int)),this,SLOT(updateStatus(int)));</span><br><span class="line"></span><br><span class="line">QMetaObject::Connection QObject::connect(cosnt QObject *sender,const OMetaMethod &amp;signal,const QObject *receivers,const QMetaMethod &amp;method,Qt::ConnectionType = Qt::AutoConnection)</span><br><span class="line">//对于信号名称唯一的(不能有重载，有重载函数只能用上面的)，没有参数不同而不同的信号函数</span><br><span class="line">connect(lineEdit,&amp;QLineEdit::textChanged,this,&amp;widget::on_textChanged);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一个参数: Qt::ConnectionType表示了信号与槽之间的关联方式<br>Qt::AutoConnection(缺省值):自动确定关联方式<br>Qt::DirectConnection: 信号被发射时，槽立即执行，槽函数与信号在同一线程<br>Qt::QueuedConnection: 事件循环回到接收者线程后执行槽，槽与信号在不同线程<br>Qt::BlockingQueueConnection: 与Qt::QueuedConnection相似，信号线程会被阻塞直到槽执行完毕。当槽函数与信号在同一线程，会造成死锁。</p><p>在槽函数里，使用QObject::sender()可以获取信号发射者的指针,下面代码是写在槽函数中的，槽函数知道发送信号得类型，可以使用动态类型转换拿到他的指针，然后设置发送者得值和使用值都是可以得</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QSpinBox*spinbox = qobject_cast&lt;QSpinBox *&gt; (sender())</span><br></pre></td></tr></table></figure><p>自定义信号及其使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class QPerson:public QObject</span><br><span class="line">&#123;</span><br><span class="line">Q_OBJECT</span><br><span class="line">private:</span><br><span class="line">int m_age = 10;</span><br><span class="line">public:</span><br><span class="line">void incAge();//是一个按钮，按下就触发</span><br><span class="line">signals:</span><br><span class="line">void ageChanged(int value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void QPerson::incAge()&#123;m_age++;emit ageChanged(m_age);//发射信号&#125;</span><br></pre></td></tr></table></figure><p>信号函数必须无返回值，但可以有输入参数信号函数无需实现，只需在某些条件下发射信号</p><p>QT全局定义（Global：全局的意思）<br><code>&lt;QtGlobal&gt;</code>头文件包含了qt类库的一些全局定义<br>1.基本数据类型2.函数 3.宏<br>因为太常用，所以不用显示的包含，QT类的头文件都会包含该文件（函数类型的定义必须使用这些变量定义，不要使用<code>#include&lt;cstdint&gt;</code>）</p><p>qreal 缺省是8字节double类型浮点数，如果Qt使用 -qreal float 选项进行配置，就是4字节float 类型的浮点数</p><p>qfloat16 是Qt5.9.0中新增的一个类用于表示16位的浮点数，要使用gfloat16，需要包含头文件<code>&lt;QFloat16&gt;</code></p><p>全局函数定义<br>————函数—————————————–功能———————–<br>T qAbs(const T &amp;value)返回变量value的绝对值</p><p>const T&amp;qBound(const T &amp;min,const T<br>&amp;value,const T &amp; max)返回value限定在min至max范围之内的值</p><p>bool qFuzzyCompare(double p1,double p2)若p1和P2近似相等，返回true<br>bool qFuzzyCompare(float p1,float p2)</p><p>bool qFuzzylsNull(double d)如果参数d约等于0，返回true</p><p>double qlnf()返回无穷大的数</p><p>bool qlsFinite(double d)若d是一个有限的数，返回true<br>bool qlslnf(double d)若d是一个无限大的数，返回true<br>bool qlsNaN(double d)若d不是一个数，返回true<br>const T&amp;qMax(const T&amp;value1,const T&amp;value2)返回value1和value2种最大的值<br>const T&amp;qMin(const T&amp;value1,const T&amp;value2)返回value1和value2种最小的值<br>qint64 qRound64(double value)将value近似为最接近的qint64整数<br>int qRound(double value)将value近似为最接近的int整数</p><p>还有一些基础的数学运算函数在 <code>&lt;QtMath&gt;</code> 头文件中定义，比如三角运算函数、弧度与角度之间的转换函数等。</p><p>QT_VERSION: 这个宏展开为数值形式0xMMNNPP (MM &#x3D; major, NN &#x3D; minor, PP &#x3D; patch) 表示Qt编译器版本，例如Qt编译器版本为Qt 5.9.1，则 QT_VERSION 为 0x050901。这个宏常用于条件编译设置，根据Qt版本不同，编译不同的代码段。</p><p>QT_VERSION_CHECK: 这个宏展开为 Qt 版本号的一个整数表示</p><p>源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   QT_VERSION is (major &lt;&lt; 16) + (minor &lt;&lt; 8) + patch.</span><br><span class="line">*/</span><br><span class="line">#define QT_VERSION      QT_VERSION_CHECK(QT_VERSION_MAJOR, QT_VERSION_MINOR, QT_VERSION_PATCH)</span><br><span class="line">/*</span><br><span class="line">   can be used like #if (QT_VERSION &gt;= QT_VERSION_CHECK(4, 4, 0))</span><br><span class="line">*/</span><br><span class="line">#define QT_VERSION_CHECK(major, minor, patch) ((major&lt;&lt;16)|(minor&lt;&lt;8)|(patch))</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if QT_VERSION &gt;= 0x051402</span><br><span class="line">/*code*/</span><br><span class="line">#else</span><br><span class="line">/*code*/</span><br><span class="line">#nedif</span><br></pre></td></tr></table></figure><p>QT_VERSION_STR: 这个宏展开为Qt版本号的字符串，如“5.9.0”</p><p>Q_BYTE_ORDER、Q_BIG_ENDIAN和Q_LTTLE_ENDIAN: Q_BYTE_ORDER表示系统内存中数据的字节序，Q_BIG_ENDIAN 表示大端字节序，Q_LITTLE_ENDIAN 表示小端字节序。在需要判断系统字节序时会用到</p><p>Q_DECL_IMPORT和Q_DECL_EXPORT:在使用或设计共享库时，用于导入或导出库的内容后续章节有其使用实例。</p><p>Q_DECL_OVERRIDE: 在类定义中，用于重载一个虚函数，例如在某个类中重载虚函数paintEvem()，可以定义如下: void paintEvent(QPaintEvent*) Q_DECL_OVERRIDE使用该宏后，如果重载的虚函数没有进行任何重载操作，编译器将会报错</p><p>Q_DECL_FINAL: 这个宏将一个虚函数定义为最终级别，不能再被重载，或定义一个类不能再被继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class QRect Q_DECL_FINAL//QRect 不能再被继承</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Q_UNUSED(name): 这个宏用于在函数中定义不在函数体里使用的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::on_imageSaved(int id, const QString &amp;fileName)</span><br><span class="line">&#123;</span><br><span class="line">Q_UNUSED(id);</span><br><span class="line">Lablnfo-&gt;setText(&quot;图片保存为:&quot;+fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach(variable,container): 用于容器类的遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foreach (const QString &amp;codecName, recorder-&gt;supportedAudioCodecs())</span><br><span class="line">ui-&gt;comboCodec-&gt;addltem(codecName);</span><br></pre></td></tr></table></figure><p>例如recorder有三个值遍历三次，每次的值都传给codeName</p><p>forever: 用于构造一个无限循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">forever</span><br><span class="line">&#123;</span><br><span class="line">//中间要退出要有相应代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>qDebug(const char* message,..) : 在debugger窗体显示信息，如果编译器设置了Qt_NO_DEBUG_OUTPUT，则不作任何输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qDebug(&quot;ltems in list: %d&quot;, myList.size());</span><br></pre></td></tr></table></figure><p>类似的宏还有 qWarning、gCritical、gFatal、glnfo 等，也是用于在 debugger 窗体显示信息</p>]]></content>
    
    
    <summary type="html">QT开发</summary>
    
    
    
    <category term="QT" scheme="https://goupos.top/categories/QT/"/>
    
    
    <category term="QT" scheme="https://goupos.top/tags/QT/"/>
    
  </entry>
  
  <entry>
    <title>C语言二叉树</title>
    <link href="https://goupos.top/2023/11/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://goupos.top/2023/11/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2023-11-25T21:18:25.000Z</published>
    <updated>2023-12-19T03:18:00.285Z</updated>
    
    
    <summary type="html">C语言二叉树</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c语言关键字执行顺序" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记0</title>
    <link href="https://goupos.top/2023/11/06/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/"/>
    <id>https://goupos.top/2023/11/06/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B00/</id>
    <published>2023-11-06T00:49:23.000Z</published>
    <updated>2023-11-22T16:28:41.225Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="C-关键字-C语言中有的关键字，删除了"><a href="#C-关键字-C语言中有的关键字，删除了" class="headerlink" title="C++关键字(C语言中有的关键字，删除了)"></a>C++关键字(C语言中有的关键字，删除了)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">asm ：允许在 C++ 程序中嵌入汇编代码&lt;C语言也可以嵌入&gt;</span><br><span class="line">auto：是存储类型标识符，表明变量&quot;自动&quot;具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。</span><br><span class="line">inline：（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。</span><br><span class="line">typeid:指出指针或引用指向的对象的实际派生类型。</span><br><span class="line">bool</span><br><span class="line">dynamic_cast</span><br><span class="line">typename</span><br><span class="line">mutable</span><br><span class="line">catch</span><br><span class="line">explicit</span><br><span class="line">namespace</span><br><span class="line">static_cast</span><br><span class="line">using</span><br><span class="line">export</span><br><span class="line">new</span><br><span class="line">virtual</span><br><span class="line">class</span><br><span class="line">operator</span><br><span class="line">false</span><br><span class="line">private</span><br><span class="line">template</span><br><span class="line">volatile</span><br><span class="line">const_cast</span><br><span class="line">protected</span><br><span class="line">this</span><br><span class="line">wchar_t</span><br><span class="line">continue:跳过当前循环</span><br><span class="line">public</span><br><span class="line">throw</span><br><span class="line">friend</span><br><span class="line">register</span><br><span class="line">true</span><br><span class="line">delete</span><br><span class="line">reinterpret_cast</span><br><span class="line">try</span><br></pre></td></tr></table></figure><p>C++之继承关系<br>继承关系可访问的类关系表示如下表格：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">继承方式基类的public成员基类的protected基类成员private</span><br><span class="line"></span><br><span class="line">public public protected 不可见</span><br><span class="line"></span><br><span class="line">protected变成protected成员protected 不可见</span><br><span class="line"></span><br><span class="line">private变成private成员private 不可见</span><br></pre></td></tr></table></figure><h4 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h4>]]></content>
    
    
    <summary type="html">C++学习笔记0</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记2</title>
    <link href="https://goupos.top/2023/11/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/"/>
    <id>https://goupos.top/2023/11/05/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02/</id>
    <published>2023-11-05T14:16:50.000Z</published>
    <updated>2023-11-27T16:20:07.591Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-类模板-模板类与友元"><a href="#1-类模板-模板类与友元" class="headerlink" title="1. 类模板-模板类与友元"></a>1. 类模板-模板类与友元</h4><p>模板类的友元函数有三类：<br>1）非模板友元:友元函数不是模板函数，而是利用模板类参数生成的函数。只能在类中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">friend void show(AA&lt;T1, T2&gt;&amp; a)//编译器利用模板参数生成了友元函数，但是，这个函数不是模板函数</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;show(AA&lt;T1, T2&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//编译器会利用友元函数模板生成实例，和下面这些代码冲突了，所以出现了重定义</span><br><span class="line">//函数模板具体化</span><br><span class="line">//friend void show(AA&lt;int, string&gt;&amp; a);//这样就很麻烦了，要为每一个类型创建一个友元函数</span><br><span class="line">//friend void show(AA&lt;char, string&gt;&amp; a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA&lt;int, string&gt; aa_1(8,&quot;我是一只快乐鸟&quot;);</span><br><span class="line"></span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;x= &quot; &lt;&lt; aa_1.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; aa_1.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//void show(AA&lt;int,string&gt;&amp; a)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot;show(AA&lt;int,string&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line">//</span><br><span class="line">//void show(AA&lt;char, string&gt;&amp; a)</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;x= &quot; &lt;&lt; a.m_x &lt;&lt; &quot; , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; &quot;show(AA&lt;char, string&gt;&amp; a)&quot; &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_2(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line">AA&lt;char, string&gt; aa_3(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line">AA&lt;double, string&gt; aa_4(8, &quot;我是一只快乐鸟&quot;);</span><br><span class="line"></span><br><span class="line">show();</span><br><span class="line">show(aa_2);</span><br><span class="line">show(aa_3);</span><br><span class="line">show(aa_4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方案的本质是：编译器利用模板参数帮我生成了友元函数。方便使用，注意：编译器利用模板参数生成了友元函数，但是，这个函数不是模板函数，而是友元函数实体<br>这样对我们写程序有什么影响：如果我们想为某种数据类型创建特别版本的友元函数（具体化）这种方法是无法做到，用该方法生成的友元函数只能用于这个模板类，不能用于其他的模板类.</p><p>2）约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。(最好的友元函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T&amp; a);//第一步：在模板类的定义前面声明友元函数模板</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)//通用类型函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)//具体化函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好的友元方案，该方案的友元函数是函数模板，为模板设置友元分三个步骤<br>第一步：在模板类的定义前面，声明友元函数模板；目的是为了让模板类AA知道友元函数模板的存在<br>第二步：在模板类中再次声明友元函数模板；目的是让编译知道需要实例化的友元函数模板 ，类模板与函数模板本来是没有关系的，如下（1）代码让他们有关系,编译器在实例化某种数据类型的模板类时，也会实例化这种数据类型的模板函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1) friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);</span><br></pre></td></tr></table></figure><p>第三步：友元函数模板的定义，放在模板类的下面;因为友元函数是函数模板，可以有具体化的版本。</p><p>这种友元的函数模板可以用于多个模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)//通用类型函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T&amp; a);//第一步：在模板类的定义前面声明友元函数模板</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(AA&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">friend void show&lt;&gt;(BB&lt;T1, T2&gt;&amp; a);//第二步：在模板类中，再次声明友元函数模板</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~BB() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//第三步：友元函数模板定义</span><br><span class="line">void show(T&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//第三步：具体化版本</span><br><span class="line">void show(BB&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">BB&lt;int, string&gt; bb_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(bb_1);</span><br><span class="line"></span><br><span class="line">BB&lt;char, string&gt; bb_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(bb_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以具体化、支持多个模板类</p><p>3）非约束模板类友元：模板类实例化时，如果实例化了n个类，也会实例化n个友元函数，每个实例化的类都拥有n个有缘函数。(它不科学)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">template&lt;typename T&gt; friend void show(T&amp; a);</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;//通用的函数模板</span><br><span class="line">void show(T&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;通用：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;&gt;//函数模板的具体版本</span><br><span class="line">void show(AA&lt;int, string &gt;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;具体化&lt;int, string &gt;：x = &quot; &lt;&lt; a.m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; a.m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(88, &quot;我是小明&quot;);</span><br><span class="line">show(aa_1);</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(88, &quot;我是小婷&quot;);</span><br><span class="line">show(aa_2);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-类模板-模板类的成员模板"><a href="#2-类模板-模板类的成员模板" class="headerlink" title="2. 类模板-模板类的成员模板"></a>2. 类模板-模板类的成员模板</h4><p>意思是在模板类中创建模板类和函数模板，开发中，模板类中有类模板和函数模板的情况很常见；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_x=&quot; &lt;&lt; m_x &lt;&lt; &quot;  , m_y=&quot; &lt;&lt; m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;//里面这个类模板参数可以和外面的类模板相同，也可以不同</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T m_a;</span><br><span class="line">T1 m_b;//可以用AA的模参数T1和T2创建成员变量</span><br><span class="line">T1 m_c;</span><br><span class="line">//BB() &#123;&#125;</span><br><span class="line">BB() &#123;&#125;</span><br><span class="line">~BB() &#123;&#125;</span><br><span class="line">//void show()</span><br><span class="line">//&#123;</span><br><span class="line">//cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; m_a &lt;&lt; &quot;  , m_b=&quot; &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">void show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BB&lt;string&gt; m_bb;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T tt)//是类模板AA的成员函数，也是函数模板</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;tt=&quot; &lt;&lt; tt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;m_x=&quot; &lt;&lt; m_x &lt;&lt; &quot;  , m_y=&quot; &lt;&lt; m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void AA&lt;T1,T2&gt;::BB&lt;T&gt;::show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a=&quot; &lt;&lt; m_a &lt;&lt; &quot;  , m_b=&quot; &lt;&lt; m_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; a(88, &quot;我是小明&quot;);</span><br><span class="line">a.show();</span><br><span class="line">a.m_bb.m_a = &quot;小婷&quot;;</span><br><span class="line">a.m_bb.m_b = 66;</span><br><span class="line">a.m_bb.show();</span><br><span class="line">a.show(&quot;结束行&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-类模板-将模板类用作参数"><a href="#3-类模板-将模板类用作参数" class="headerlink" title="3. 类模板-将模板类用作参数"></a>3. 类模板-将模板类用作参数</h4><p>链表数组，为了支持任意类型数据，最好的方法是用类模板来实现（物理结构不相同，但是逻辑结构是相同的）<br>模板的目的就是代码重用。链表和数组的逻辑结构是一样的，是否可以做成一个模板类呢？可以的。<br>链表这个模板类模板化目的为了兼容各种数据类型<br>C++支持模板的模板:把模板名当成一种特殊的类型，实例化对象的时候，可以用模板名作为参数，传给模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">class LinkList//链表类模板 被称为容器 </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1* m_head;</span><br><span class="line">int m_len = len;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">LinkList();</span><br><span class="line">~LinkList();</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中插入一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ddelete()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中删除了一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void update()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中更新一条记录&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">LinkList&lt;T1, len&gt;::LinkList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">LinkList&lt;T1, len&gt;::~LinkList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1* m_data;//数组指针</span><br><span class="line">int m_len = len;//表长</span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line">void insert()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中插入一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void ddelete()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中删除了一条记录。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void update()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;向链表中更新一条记录&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">Array&lt;T1, len&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, int len&gt;</span><br><span class="line">Array&lt;T1, len&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线性表模板类：tabletype-线性表类型  datetype-线性表数据类型</span><br><span class="line">//template&lt;class, int&gt;class 模板类</span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">class LinearList</span><br><span class="line">&#123;</span><br><span class="line">/*线性表模板类的代码实现，特别地方有：</span><br><span class="line">那就是它的参数</span><br><span class="line">*/</span><br><span class="line">public:</span><br><span class="line">tabletype&lt;datatype, len&gt; m_table;//创建线性表对象</span><br><span class="line"></span><br><span class="line">LinearList();</span><br><span class="line">~LinearList();</span><br><span class="line"></span><br><span class="line">void insert()//线性表插入操作</span><br><span class="line">&#123;</span><br><span class="line">m_table.insert();</span><br><span class="line">&#125;</span><br><span class="line">void ddelete() &#123; m_table.ddelete(); &#125;//线性表删除操作</span><br><span class="line">void updata() &#123; m_table.update(); &#125;//线性表更新操作</span><br><span class="line">void oper()//按业务要求操作线性表</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;len=&quot; &lt;&lt; m_table.m_len &lt;&lt; endl;</span><br><span class="line">m_table.insert();</span><br><span class="line">m_table.update();</span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">LinearList&lt;tabletype, datatype, len&gt;::LinearList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br><span class="line">LinearList&lt;tabletype, datatype, len&gt;::~LinearList()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建线性表对象,容器类型为链表，链表的数据类型为int,表长为20</span><br><span class="line">LinearList&lt;LinkList, int, 20&gt;a;</span><br><span class="line">//LinearList:线性表的类模板名，创建线性表对象</span><br><span class="line">//LinkList：线性表第一个参数是容器的类型，容器都是类模板，所以填写类模板名</span><br><span class="line">//第二个参数用于指定容器的数据类型，意思是容器中存放的是什么类型的数据</span><br><span class="line">//第三个参数是指定容器的大小</span><br><span class="line">a.insert(); </span><br><span class="line">a.ddelete(); </span><br><span class="line">a.updata();</span><br><span class="line"></span><br><span class="line">//创建线性表对象,容器类型为链表，链表的数据类型为string,表长为20</span><br><span class="line">LinearList&lt;Array, string, 20&gt;b;</span><br><span class="line">b.insert(); </span><br><span class="line">b.ddelete(); </span><br><span class="line">b.updata();</span><br><span class="line"></span><br><span class="line">/*他们选择不同容器 LinkList 和 Array 容器，容器可以不同，但是操作数据的方法是相同的*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性表模板类的代码实现，特别地方有：那就是它的参数<br><code>template&lt;class, int&gt;class tabletype</code>的意思：表示 <code>tabletype</code> 不是一个普通的参数，而是模板，意思是这个参数要填写模板名，不要填写普通类型（int、string）;<br>填什么样的模板名呢？填有两个参数的类模板名，一个参数的类模板名是不可以的。并且要求类模板的第一个参数是通用类型，第二个是非通用类型。<br>在如下代码中 class 也可以用 typename 代替,类模板更习惯用 class 而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class, int&gt;class tabletype</span><br><span class="line">template&lt;typename, int&gt;class tabletype</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;template&lt;class, int&gt;class tabletype, class datatype, int len&gt;</span><br></pre></td></tr></table></figure><p>模板名通过参数 tabletype 传入到了类中，类中可以用 tabletype 创建对象；<code>tabletype</code> 是一个模板名， 用<code>tabletype</code>创建对象的时候，还需要指定具体的数据类型；<code>tabletype</code>应该用什么数据类型。<br>最常见的做法是：用模板参数从外面传进来，例如 把 datatype 填这里，len 填在这里<br>这个一般用于数据处理中</p><h4 id="4-编译预处理"><a href="#4-编译预处理" class="headerlink" title="4. 编译预处理"></a>4. 编译预处理</h4><p>C++程序编译的过程：预处理 -&gt; 编译（优化、汇编） -&gt; 链接<br>预处理指令主要有以下三种：<br>包含头文件:#include<br>宏定义:#define #undef<br>条件编译：#if #else #elif #end #ifnedf #if defined</p><h4 id="5-编译和链接"><a href="#5-编译和链接" class="headerlink" title="5. 编译和链接"></a>5. 编译和链接</h4><p>1）分开编译的好处：每次只编译修改过的源文件，然后在再链接，效率最高。<br>2）编译单个<code>*.cpp</code> 文件的时候，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误。<br>3）编译单个<code>*.cpp</code> 文件的时候，编译器只需要知道名称的存在，不会把他们的定义一起编译。<br>4）如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令<br>5）链接的时候、变量、函数和类的定义只能有一个，否则会出现重定义错误。(如果把变量、函数和类的定义放在<code>*.h</code> 文件中，<code>*.h</code> 会被多次包含，链接前会存在多个副本，如果放在<code>*.cpp</code> 文件中，<code>*.cpp</code> 文件不会被包含，只会被编译一次，链接前只存在一个版本)(如果加上 <code>static</code> 可以避免被重复包含)<br>6）把变量、函数和类的定义放在<code>*.h</code>中是不规范的做法，如果<code>*.h</code>被多个<code>*.cpp</code>包含，会出现重定义。头文件加上防止重定义编译的宏定义<br>7）用 <code>#include</code> 包含 <code>*.cpp</code> 是不规范的做饭，原理同上<br>8）尽可能不使用全局变量，如果一定要用，要在 <code>*.h</code> 文件中声明（需要加 <code>extern</code>）, <code>*.cpp</code> 中定义。<br>9）全局的<code>const</code>常量在头文件中定义 (<code>const</code>常量仅在文件内有效)<br>10）<code>*.h</code> 重复包含的处理方法只对单个的<code>*.cpp</code>文件有效，不是整个项目.<br>11）函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在<code>*.h</code>文件中;函数模板和类模板的具体化版本的代码是真实的定义，所以放在<code>*.cpp</code> 文件中。<br>12) Linux下C++编译和链接的原理与VS一样。</p><h4 id="6-C-命名空间"><a href="#6-C-命名空间" class="headerlink" title="6. C++命名空间"></a>6. C++命名空间</h4><p>实际开发中，较大型的项目会使用大量的全局名字，如类、函数、模板、变量等，很容易出现名字冲突的情况。<br>命名空间分割了全局空间，每个命名空间是一个作用域，防止名字冲突<br>语法<br>创建命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace 命名空间的名字</span><br><span class="line">&#123;</span><br><span class="line">//类、函数、模板、变量的声明和定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建命名空间的别名<br>namespace 别名 &#x3D; 原名;</p><p>要使用命名空间的数据类型有三种方法：<br>第一种方法：在名字前面加上命名空间的名字和两个冒号,这种方法简单明了，不会造成任何冲突，但是使用起来比较繁琐，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果想使用命名空间中的变量</span><br><span class="line">cout&lt;&lt;AA::aa&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>第二种方法：用using声明,使用using声明要注意这样一个问题，如果再同一个区域出现了相同的名字，那么编译会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//如果想用 AA 命名空间的 aa ,但是在下面代码中不能再出现 aa 变量名</span><br><span class="line">using AA::aa;</span><br><span class="line">using AA::func;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;aa&lt;&lt;endl;</span><br><span class="line">func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法：用using编译指令，使用using编译指令要注意这样一个问题，如果再同一个区域出现了相同的名字，虽然编译不会报错，但是会屏蔽之前创建的变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">namespace AA//自定义命名空间</span><br><span class="line">&#123;</span><br><span class="line">int aa = 1;</span><br><span class="line">void func()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">using namespace AA;//有了这行代码后，main函数中，AA命名空间中的全部名字都可以用 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项<br>1）命名空间是全局的，可以分布再多个文件中(有命名空间和没有命名空间代码组织一样的，函数和类的声明在头文件中，函数和类的定义在源文件中；全局变量在头文件中声明，在源文件中定义)</p><figure class="highlight plaintext"><figcaption><span>namespace_new.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">int ab = 1; //全局变量</span><br><span class="line"></span><br><span class="line">void A1::show()//类成员函数的类外实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A1::show()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func1()//调用了全局函数定义</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">extern int ab;</span><br><span class="line"></span><br><span class="line">void func1();//全局函数声明</span><br><span class="line"></span><br><span class="line">class A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show();//类的成员函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace aa;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">A1 a1;</span><br><span class="line">a1.show();</span><br><span class="line">func1();</span><br><span class="line">cout &lt;&lt; ab &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有同一个命名空间的代码可以分散在不同的文件中,例如把命名空间AA代码分开，如下所示</p><figure class="highlight plaintext"><figcaption><span>namespace_new.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">void A1::show()//类成员函数的类外实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A1::show()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func1()//调用了全局函数定义</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func()函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">void func1();//全局函数声明</span><br><span class="line"></span><br><span class="line">class A1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">void show();//类的成员函数</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new2.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#include &quot;namespace_new2.h&quot;</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">int ab = 1; //全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>namespace_new2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#pragma once</span><br><span class="line"></span><br><span class="line">namespace aa</span><br><span class="line">&#123;</span><br><span class="line">extern int ab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，组织代码的方法，和没有命名空间相比，只是在代码外面，套了一个命名空间而已</p><p>2）命名空间可以嵌套。<br>3）在命名空间中声明变量，而不是使用外部全局变量和静态全局变量（应用经验。静态变量不适用原因：例如上面全局变量 ab 在源文件中定义，头文件中声明，不在头文件中声明，那么外部就不知道有该变量，效果和静态变量一样）<br>4）对于using声明，首选将其作用域设置为局部而不是全局 ；将这个代码放在main函数作用域中<code>using AA::aa;</code>，不要放置外面<br>5）不要在头文件中使用using编译指令，如果非要使用，应将它放在所有的 #include 之后。<br>6）匿名的命名空间，在当前文件中从创建的位置到文件结束有效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">namespace //匿名的命名空间</span><br><span class="line">&#123;</span><br><span class="line">int ii = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ii&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-C-类型转换-static-cast"><a href="#7-C-类型转换-static-cast" class="headerlink" title="7. C++类型转换 static_cast"></a>7. C++类型转换 static_cast</h4><p>风格的类型转换很容易理解:<br>C语法:(目标类型)表达式或目标类型(表达式);<br>C++认为C风格的类型转换过于散，可能会带来隐患，不够安全。<br>C++推出了新的类型转换来替代C风格的类型转换，采用更严格的语法检查，降低使用风险。<br>C++新增四个关键字<code>static_cast、const_cast、reinterpret_cast、dynamic_cast</code>,用于支持C++风格的类型转换。<br>C++的类型转换只是语法上的解释本质上与C风格的类型转换没什么不同，C语言做不到事情的C++也做不到<br>语法<br>static_cast&lt;目标类型&gt;(表达式);实际开发中，这个用的多<br>const_cast&lt;目标类型&gt;(表达式);<br>reinterpret_cast&lt;目标类型&gt;(表达式);<br>dynamic_cast&lt;目标类型&gt;(表达式);</p><p>static_cast<br>1）用于内置数据类型之间的转换，除了语法不同，C和C++没有区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double dd = 1.23;</span><br><span class="line">long ll ;</span><br><span class="line">ll = static_cast&lt;long&gt;(dd);\\C++风格</span><br></pre></td></tr></table></figure><p>2）用于指针之间转换C风格可以把不同类型的指针进行转换。C++不可以，需要借助 void *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ii = 10;</span><br><span class="line">void *pv = &amp;ii;</span><br><span class="line">double * pd4 =  static_cast&lt;double*&gt;(pv);</span><br></pre></td></tr></table></figure><p>reinterpret_cast<br>static_cast不能用于转换不同类型的指针(引用) (不考虑有继承关系的情况)，reinterpret_cast可以。<br>reinterpret_cast的意思是重新解释，能够将一种对象类型转换为另一种类型，不管他们是否有关系。（就是想怎么转就怎么转）<br>语法：reinterpret_cast&lt;目标类型&gt;(表达式);<br><code>&lt;目标类型&gt;</code>和<code>(表达式)</code>中必须有一个是指针(引用)类型。为什么会这么要求，因为它只为转换指针的应用场景而设计的<br><code>reinterpret_cast</code>不能丢掉<code>(表达式)</code>的<code>const</code>或<code>volitale</code>属性。</p><p>static_cast转换指针受到一些限制，C++设计的目标是:让static_cast满是程序员普通的需求;非常规的、特别的应用场景用reinterpret_cast；<br>应用场景<br>1）<code>reinterpret_cast</code>的第一种用途是改变指针（引用）的类型.<br>例如:把<code>int*</code>型指针直接转换成<code>double*</code>型指针，中间不借助<code>void*</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int ii= 10；</span><br><span class="line">double * pd = reinterpret_cast&lt;double*&gt;(&amp;ii);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">double aa = 100.23;</span><br><span class="line">int *aa_int = reinterpret_cast&lt;int *&gt;(&amp;aa);</span><br><span class="line">double * aa_double = reinterpret_cast&lt;double*&gt;(aa_int);</span><br><span class="line"></span><br><span class="line">printf(&quot;%f\n&quot;,*aa_double);</span><br><span class="line">cout &lt;&lt; *aa_double &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>2）<code>reinterpret_cast</code>的第二种用途是将指针(引用)转换成整型变量。整型与指针占用的字节数必须一致，否则转换可能损失精度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void func(void * ptr)</span><br><span class="line">&#123;</span><br><span class="line">long long ii = reinterpret_cast&lt;long long&gt;(ptr);</span><br><span class="line">cout &lt;&lt; &quot;ii=&quot; &lt;&lt; ii &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">long long ii = 10;</span><br><span class="line">func(reinterpret_cast&lt;void *&gt;(ii));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）<code>reinterpret_cast</code> 的第三种用途是将一个整型变量转换成指针 (引用)</p><p>const_cast<br><code>static_cast</code>不能丢掉指针(引用)的<code>const</code>和<code>volitale</code>属性<code>const_cast</code>可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int * aa = nullptr;</span><br><span class="line">int *cc = const_cast&lt;int *&gt;(aa);</span><br></pre></td></tr></table></figure><p>在实际开发中为什么要丢掉指针const呢？<br>如下定义一个函数<code>funca()</code>,形参用整形指针，那就用<code>const_cast</code>转换，把指针<code>aa</code>的<code>const</code>丢掉</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void funca(int *ii)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">const int * aa = nullptr;</span><br><span class="line">funca(const_cast&lt;int*&gt;(aa));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-C-的String容器"><a href="#7-C-的String容器" class="headerlink" title="7. C++的String容器"></a>7. C++的String容器</h4><p><code>string</code>是字符容器，内部维护了一个动态的字符数组。<br>与普通的字符数组相比，string 容器有三个优点:<br>1)使用的时候，不必考虑内存分配和释放的问题<br>2)动态管理内存(可扩展)<br>3)提供了大量操作容器的API。缺点是效率略有降低。</p><p><code>string</code>类是<code>std:basic_string</code>类模板的一个具体化版本的别名。<br><code>using std:string=std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt;&gt;</code></p><p>构造和析构<br>静态常量成员string::npos为字符数组的最大长度（通常为unsigned int 的最大值）；<br>NBTS (null-terminated string): C风格的字符串 (以空字符0结束的字符串)<br>string 类有七个构造函数(C++11新增了两个):<br>1）<code>string()</code>:创建一个长度为0的<code>string</code>对象(默认构造函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1;//创建一个长度为0的string对象</span><br><span class="line">cout &lt;&lt; &quot;s1=&quot; &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s1.capacity()=&quot; &lt;&lt; s1.capacity() &lt;&lt; endl;//返回当前容器容量，可以存放字符的总数</span><br><span class="line">cout &lt;&lt; &quot;s1.size() = &quot; &lt;&lt; s1.size() &lt;&lt; endl;//返回当前容器中数据的大小</span><br></pre></td></tr></table></figure><p>2)<code>string(const char *s)</code>: 将<code>string</code>对象初始化为<code>s</code>指的<code>NBTS</code>(转换函数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>3)<code>string(const string &amp;str)</code>: 将<code>string</code>对象初始化为<code>str</code>(拷贝构造函数)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4)<code>string(const char *s,size_t n)</code>: 将<code>string</code>对象初始化为<code>s</code>指的<code>NBTS</code>的前n个字符，即使超过了(C风格)<code>NBTS</code>结尾，这里不判断结尾标志（这里的第一个参数不要理解为字符串，理解为一个地址<code>string(const void *s,size_t n)</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s6(&quot;hello world&quot;, 5);</span><br><span class="line">cout &lt;&lt; &quot;s6=&quot; &lt;&lt; s6.c_str() &lt;&lt; endl;</span><br><span class="line">string s7(&quot;hello world&quot;, 50);//会从这条字符串向后复制50个字符</span><br><span class="line">cout &lt;&lt; &quot;s7=&quot; &lt;&lt; s7.c_str() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>5）<code>string(const string &amp;str,size_t pos=0,size_t n=npos):</code>将<code>sring</code>对象初始化为<code>str</code> 从位置<code>pos</code>开始到结尾的字符，或从位置<code>pos</code>开始的<code>n</code>个字符。会判断字符串结尾标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1 = &quot;hello world&quot;;</span><br><span class="line">string s8(s1, 3, 5);</span><br><span class="line">cout &lt;&lt; &quot;s8=&quot; &lt;&lt; s8.c_str() &lt;&lt; endl;</span><br><span class="line">string s9(s1, 3);//从第三个位置开始，截取后面全部内容 lo world</span><br><span class="line">cout &lt;&lt; &quot;s9=&quot; &lt;&lt; s9.c_str() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s9.capacity()=&quot; &lt;&lt; s9.capacity() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;s9.size()=&quot; &lt;&lt; s9.size() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>6）<code>template&lt;class T&gt; string(T begin,T end)</code>:将<code>string</code>对象初始化为区间[begin,end]内的字符,其中 begin 和 end 的行为就像指针，用于指定位置，范围包括 begin 在内，但不包括 end<br>7）string(size_t n,char c): 创建一个由 n 个字符 c 组成的 string 对象。</p><p>C++11新增的构造函数:<br> 1)string(string &amp;&amp; str) noexcept: 它将一个 string 对象初始化为 string 对象 str,并可能修改str(移动构造函数)。(要学习了右值引用之后才知道它)<br>2)<code>string(initializer_list&lt;char&gt; il)</code>: 它将一个<code>string</code>对象初始化为初始化列表il中的字符。例如: string ss &#x3D;{‘h’,’e’,’l’,’l’,’o’}; </p><h4 id="8-string容器设置目标"><a href="#8-string容器设置目标" class="headerlink" title="8. string容器设置目标"></a>8. string容器设置目标</h4><p>弄清楚string容器设计目标<br>char cc[8];&#x2F;&#x2F;是使用了连续的8个存储空间，<br>是以字节为最小存储单元的动态容器<br>用于存储放过字符串（不存放空字符0，空字符0是C风格字符串）<br>用于存放数据的内存空间（缓冲器），在这种情况下，什么样的数据都可以放到容器中</p><p>string内部的三个指针<br><code>char *start_</code>;动态分配内存块开始的地址<br><code>char *end_</code>;动态分配内存块最后的地址<br><code>char *finish_</code>;已使用空间的最后的地址<br>因为有这三个指针，所以，用它存放字符串的时候，不需要空字符0</p><h4 id="9-string容器设置目标"><a href="#9-string容器设置目标" class="headerlink" title="9. string容器设置目标"></a>9. string容器设置目标</h4><h4 id="10-vector-容器"><a href="#10-vector-容器" class="headerlink" title="10. vector 容器"></a>10. vector 容器</h4><p>vector容器封装了动态数组<br>包含头文件：<code>#include&lt;vector&gt;</code><br>vector类模板的声明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class Alloc = allocator&lt;T&gt;&gt;</span><br><span class="line">class vector</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">T *start_;</span><br><span class="line">T *finish_;</span><br><span class="line">T *end_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配器<br>各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存如果省略该模板参数的值，将默认使用<code>allocator&lt;T&gt;</code>，用<code>new</code>和<code>delete</code>分配和释放内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//创建一个空的 vector 容器</span><br><span class="line">vector&lt;int&gt; v1;</span><br><span class="line">cout &lt;&lt; &quot;v1.capacity()=&quot; &lt;&lt; v1.capacity() &lt;&lt; &quot;  , v1.size()=&quot; &lt;&lt; v1.size() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">//创建 vector 容器，元素个数为8（容量和实际大小都是n）</span><br><span class="line">vector&lt;int&gt; v2(8);</span><br><span class="line">cout &lt;&lt; &quot;v2.capacity()=&quot; &lt;&lt; v2.capacity() &lt;&lt; &quot;  , v2.size()=&quot; &lt;&lt; v2.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-迭代器-其实就是像数组一样的访问他的元素"><a href="#11-迭代器-其实就是像数组一样的访问他的元素" class="headerlink" title="11. 迭代器(其实就是像数组一样的访问他的元素)"></a>11. 迭代器(其实就是像数组一样的访问他的元素)</h4><p>为什么要使用迭代器<br>迭代器是访问容器中元素的通用方法。<br>如果使用迭代器，不同的容器，访问元素的方法是相同的。<br>迭代器支持的基本操作:赋值 <code>(=)</code>、解引用<code>(*)</code>、比较 <code>(==和!=)</code>、从左向右遍历 <code>(++)</code><br>一般情况下，迭代器是指针和移动指针的方法</p><p>迭代器有五种分类:<br>1）正向迭代器<br>只能使用++运算符来遍历容器，每次沿容器向右移动一个元素。<br>容器名&lt;元素类型&gt;::iterator 迭代器名;&#x2F;&#x2F; 正向迭代器<br>容器名&lt;元素类型&gt;::const_iterator 迭代器名; &#x2F;&#x2F; 常正向选代器</p><p>迭代器失效问题</p><p>迭代器的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">//自定义一个数组类型，实现元素的添加，修改，移除，遍历</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//迭代器 ：遍历容器，获取容器中的元素数据 ,进行某些操作 * ++ -- !=  </span><br><span class="line">class IntIterator </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">IntIterator(int*p)</span><br><span class="line">&#123;</span><br><span class="line">ptr = p;</span><br><span class="line">&#125;</span><br><span class="line">int&amp; operator*()</span><br><span class="line">&#123;</span><br><span class="line">return *ptr;</span><br><span class="line">&#125;</span><br><span class="line">void operator++()//前置</span><br><span class="line">&#123;</span><br><span class="line">++ptr;</span><br><span class="line">&#125;</span><br><span class="line">bool operator!=(const IntIterator&amp;it)</span><br><span class="line">&#123;</span><br><span class="line">return ptr != it.ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int*ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//在不考虑任何意外的情况下实现</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">//行为</span><br><span class="line">Array(int capacity = 1)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;capacity = capacity;</span><br><span class="line">_size = 0;</span><br><span class="line">data = new int[this-&gt;capacity];</span><br><span class="line">&#125;</span><br><span class="line">~Array()</span><br><span class="line">&#123;</span><br><span class="line">delete []data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void append(int value)//从后面添加一个元素</span><br><span class="line">&#123;</span><br><span class="line">data[_size++] = value;</span><br><span class="line">&#125;</span><br><span class="line">void pop_back()//从后面移除一个元素</span><br><span class="line">&#123;</span><br><span class="line">_size--;</span><br><span class="line">&#125;</span><br><span class="line">void replace(int index,int value)//修改指定位置的值</span><br><span class="line">&#123;</span><br><span class="line">//不能越界</span><br><span class="line">data[index] = value;</span><br><span class="line">&#125;</span><br><span class="line">int size()const</span><br><span class="line">&#123;</span><br><span class="line">return _size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IntIterator begin()//返回首元素的地址</span><br><span class="line">&#123;</span><br><span class="line">return IntIterator(data);//创建了一个迭代器</span><br><span class="line">&#125;</span><br><span class="line">IntIterator end()//返回最后一个元素的下一个位置的地址</span><br><span class="line">&#123;</span><br><span class="line">return IntIterator(data+_size);//创建了一个迭代器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">int capacity;//容量，最多能够容纳的元素个数</span><br><span class="line">int*data;</span><br><span class="line">int _size;//已经存储的元素个数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Array arr&#123;10&#125;;</span><br><span class="line"></span><br><span class="line">arr.append(10);</span><br><span class="line">arr.append(20);</span><br><span class="line">arr.append(30);</span><br><span class="line"></span><br><span class="line">//cout &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">arr.pop_back();</span><br><span class="line"></span><br><span class="line">//用迭代器对数组进行遍历</span><br><span class="line">for(IntIterator it = arr.begin();it != arr.end();++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it &lt;&lt; endl;//</span><br><span class="line">&#125;</span><br><span class="line">//auto :根据对象的值，自动去推导其类型</span><br><span class="line">for(auto it = arr.begin();it != arr.end();++it)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;*it = &quot; &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-基于范围的for循环"><a href="#12-基于范围的for循环" class="headerlink" title="12.基于范围的for循环"></a>12.基于范围的for循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; vv = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line"></span><br><span class="line">for(auto it = vv.begin(); it!= vv.end(); it++)//迭代器遍历容器vv</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; *it &lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">for(auto val:vv)//用基于范围的for循环遍历容器vv.</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; val &lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>for(int val:vv)</code> 相当于把容器vv中的元素逐个赋值给变量val<br>对于一个有范围的集合来说，在程序代码中指定循环的范围有时候是多余的，还可能犯错误。<br>C++11中引入了基于范围的for 循环。<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(迭代的变量：迭代的范围)</span><br><span class="line">&#123;</span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）迭代的范围：可以填数组名、容器名、统一初始化列表或者其它可迭代的对象（支持begin()、end0、++、&#x3D;&#x3D;）<br>迭代的变量：一般用<code>auto</code>关键字声明<br>2）数组名传入函数后，已退化成指针，不能作为容器名。<br>3）如果容器中的元素是结构体和类，迭代器变量应该申明为引用，加const约束表示只读。<br>4）注意迭代器失效的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(const auto &amp;val:vv)//用基于范围的for循环遍历容器vv.</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; val &lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="13-list容器"><a href="#13-list容器" class="headerlink" title="13.list容器"></a>13.list容器</h4><p>list容器封装了双链表。<br>包含头文件 <code>#include &lt;list&gt;</code><br>统一初始化列表的语法：构造函数的形参是这个<code>initializer list&lt;T&gt; il</code>,完整语法<code>list(initializer list&lt;T&gt; il)</code>就有三种初始化写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用统一初始化列表创建list容器</span><br><span class="line">list&lt;int&gt; l2(&#123;1,2,3,4,5,6,7,8,9,10&#125;);</span><br><span class="line">list&lt;int&gt; l3 = &#123;1,2,3,4,5,6,7,8,9,10&#125;；</span><br><span class="line">list&lt;int&gt; l4 &#123;1,2,3,4,5,6,7,8,9,10&#125;</span><br></pre></td></tr></table></figure><h4 id="14-list容器的操作"><a href="#14-list容器的操作" class="headerlink" title="14.list容器的操作"></a>14.list容器的操作</h4><h4 id="15-pair键值对"><a href="#15-pair键值对" class="headerlink" title="15.pair键值对"></a>15.pair键值对</h4><p>pair是类模板，一般用于表示key&#x2F;value数据，其实现是结构体<br>pair结构模板的定义如下：（C++中类和模板是同一种，类可以做成模板，结构体也可以做成模板）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">teamplate&lt;class T1, class T2&gt;</span><br><span class="line">struct pair</span><br><span class="line">&#123;</span><br><span class="line">T1 first;//第一个成员，一般表示KEY.</span><br><span class="line">T2 second;//第二个成员，一般表示value</span><br><span class="line"></span><br><span class="line">pair();//默认构造函数</span><br><span class="line">pair(const T1 &amp;val,const T2 &amp;val2);//有两个参数的构造函数</span><br><span class="line"></span><br><span class="line">pair(const pair&lt;T1,T2&gt; &amp;p);// 拷贝构造函数</span><br><span class="line">void swap(pair&lt;T1,T2&gt; &amp;p);// 交换两个 pair。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>make_pair函数模板的定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">teamplate&lt;class T1, class T2&gt;</span><br><span class="line">make_pair(const T1 &amp;first,const T2 &amp;second)</span><br><span class="line">&#123;</span><br><span class="line">return pair&lt;T1,T2&gt;(first,second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>STL定义了pair结构体模板和make_pair函数模板</p><p>下面两个函数，每个只会调用一次构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto p4 = make_pair&lt;int,string&gt;(6,&quot;西施&quot;);//make_pair返回临时对象</span><br><span class="line">auto p5 = pair&lt;int,string&gt;(5,&quot;西施&quot;);//匿名对象</span><br><span class="line">auto p6 = make_pair(6,&quot;西施&quot;);//慎用，make_pair()函数自动推导，再调用拷贝构造，再调用拷贝构造</span><br><span class="line">pair&lt;int,string&gt; p7 = make_pair(7,&quot;西施&quot;)；//慎用，make_pair()函数自动推导，再调用拷贝构造，在转换</span><br></pre></td></tr></table></figure><p>注意：<br><code>auto p5 = pair&lt;int,string&gt;(5,&quot;西施&quot;);</code>这行代码不要理解为先创建匿名对象，然后再调用拷贝构造函数创建对象p5；可以理解为先创建匿名对象，然后用了p5的名字；或者直接理解为：创建对象p5时，显式的调用了构造函数。<br><code>auto p4 = make_pair&lt;int,string&gt;(6,&quot;西施&quot;);</code>：不要理解为，make_pair创建了临时对象，函数返回后，P4使用拷贝函数；可以理解为和上面一样，是编译器做了优化处理<br>不同编译器可能会有点不同</p><p>pair键值对得value还可以用结构体和类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct data_info</span><br><span class="line">&#123;</span><br><span class="line">T data1;</span><br><span class="line">T data2;</span><br><span class="line">T data3;</span><br><span class="line"></span><br><span class="line">data_info(T data1, T data2, T data3) :data1(data1), data2(data2), data3(data3)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;data_info&lt;int&gt;, string&gt;p4(&#123;43,9,03&#125;,&quot;西施&quot;);</span><br><span class="line">cout &lt;&lt; p4.first.data1 &lt;&lt; p4.first.data2 &lt;&lt; p4.first.data3 &lt;&lt; p4.second &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-红黑树"><a href="#15-红黑树" class="headerlink" title="15.红黑树"></a>15.红黑树</h4><p>二叉链表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct BTNode</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;K,V&gt;P;//键值对。</span><br><span class="line">BTNode*parent;//父节点</span><br><span class="line">BTNode*lchirld;//左子树</span><br><span class="line">BTNode*rchild;//右子树 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-map容器"><a href="#16-map容器" class="headerlink" title="16.map容器"></a>16.map容器</h4><p>map容器封装了红黑树(平衡二排序树)，用于查找。<br>包含头文件: <code>#ihclude&lt;map&gt;</code><br>map容器的元素是pair键值对。<br>map类模板的声明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class K, class V, class P = less&lt;K&gt;, class Alloc = allocator&lt;pair&lt;const K, V &gt;&gt;&gt;</span><br><span class="line">class map : public _Tree&lt;Tmap_traits&lt; K, V, P,_ Alloc, false&gt;&gt; </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个模板参数K:key的数据类型(pair.first)<br>第二个模板参数V: value 的数据类型 (pair.second)。<br>第三个模板参数P:排序方法，缺省按 key升序。<br>第四个模板参数 <code>_Alloc</code>:分配器，缺省用 new和 delete。<br>红黑树使用二叉链表，map可以提供双向迭代器</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//map() 创建一个空的map容器</span><br><span class="line">map&lt;int, string&gt; m1;</span><br><span class="line"></span><br><span class="line">//map(initializer_list&lt;pair&lt;k,v&gt;&gt;il) 使用统一初始化列表</span><br><span class="line">map&lt;int, string&gt; m2(&#123; &#123;8,&quot;西施&quot;&#125;,&#123;3,&quot;冰冰&quot;&#125;,&#123;4,&quot;晶晶&quot;&#125; ,&#123;5,&quot;欢欢&quot;&#125; &#125;);</span><br><span class="line">//map&lt;int, string&gt; m2 = &#123; &#123;8,&quot;西施&quot;&#125;,&#123;3,&quot;冰冰&quot;&#125;,&#123;4,&quot;晶晶&quot;&#125; ,&#123;5,&quot;欢欢&quot;&#125;&#125;;</span><br><span class="line">//map&lt;int, string&gt; m2&#123; &#123;8,&quot;西施&quot;&#125;,&#123;3,&quot;冰冰&quot;&#125;,&#123;4,&quot;晶晶&quot;&#125; ,&#123;5,&quot;欢欢&quot;&#125;&#125;;</span><br><span class="line">for ( auto &amp;val:m2)//map正向遍历</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; val.first &lt;&lt; &quot;=&quot; &lt;&lt; val.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器一般有的操作：<br>构造函数、特性操作、元素操作、复制操作、交换操作、比较操作、查找操作、插入和删除操作</p><h4 id="16-哈希-x2F-散列表"><a href="#16-哈希-x2F-散列表" class="headerlink" title="16.哈希&#x2F;散列表"></a>16.哈希&#x2F;散列表</h4><p>哈希表：数组+链表<br>哈希表长（桶的个数）：数组的长度<br>哈希函数：size_t hash(const T&amp;key)<br>{<br>    &#x2F;&#x2F;key%小于哈希表长的最大质数<br>}<br>装填因子：元素总数&#x2F;表长，其值越大，效率越低。</p><h4 id="17-unordered-map容器-C-11标准新增加的-无序的容器"><a href="#17-unordered-map容器-C-11标准新增加的-无序的容器" class="headerlink" title="17.unordered_map容器(C++11标准新增加的) 无序的容器"></a>17.unordered_map容器(C++11标准新增加的) 无序的容器</h4><p>实际开发中数据量只有几万，用红黑树也不错。如果数据量达到上千万，必须用哈希表<br>unordered_map 容器封装了哈希表，查找、插入和删除元素时，只需要比较几次 key 的值。<br>包含头文件: <code>#include&lt;unordered_map&gt;</code><br>unordered_map 容器的元素是 pair键值对。<br>unordered_map 类模板的声明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class K, class V, class _Hasher = hash&lt;K&gt;, class _Keyeq = equal_to&lt;K&gt;,class _Alloc = allocator&lt;pair&lt;const K, V&gt;&gt;&gt;</span><br><span class="line">class unordered_map : public _Hash&lt; Umap_traits&lt;K, V,_Uhash_compare&lt;K,_Hasher,_Keyeq&gt;,_Alloc,false&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个模板参数K:key的数据类型(pair.first)。<br>第二个模板参数V: value 的数据类型(pair.second)<br>第三个模板参数_Hasher: 哈希函数，默认值为 <code>std::hash&lt;K&gt;</code><br>第四个模板参数_Keyeq:比较函数，用于判断两个 key 是否相等，默认值是 <code>std:equal to&lt;K&gt;</code><br>第五个模板参数_Alloc: 分配器，缺省用 new 和delete。</p><p>创建std::unordered_map 类模板的别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class K,class V&gt;</span><br><span class="line">using umap = std::unordered_map&lt;K, V&gt;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">C++学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL创建多项目-多工程编译</title>
    <link href="https://goupos.top/2023/10/31/MDK%20KEIL/MDK%20KEIL%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/"/>
    <id>https://goupos.top/2023/10/31/MDK%20KEIL/MDK%20KEIL%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/</id>
    <published>2023-10-31T03:30:34.000Z</published>
    <updated>2023-11-01T09:29:07.305Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li><p>首先说明一下多工程的作用：<br>假如你写了一个boot和一个app等好几个工程，当如果这几个工程同用一个文件，你修改了以后，意味着所有的工程都需要重新编译，一个一个工程编译就带来了困难。</p></li><li><p>开始创建多工程</p></li></ol><p>1)你已经创建了两个以及以上的前提上<br>2)创建多工程（多工程其实也是一个工程）<br>方法：点击 <code>Project</code> -&gt; <code>New Multi-Project Workspace...</code> -&gt; 填写工程名字，放置在选择的文件夹,然后保存 -&gt; 会弹出提示框 <code>Create New xxxx-Project Workspace </code> 在 <code>uVision Projects</code>添加项目路径（如果不添加路径无法保存） -&gt; 点击 <code>OK</code><br>3)如果还想继续添加工程到当前项目中，可以找到界面上这个图标，如下是路径：<br>方法：点击 <code>Project</code> -&gt; <code>manage</code> -&gt; <code>New Multi-Project Workspace...</code><br>4）所有工程全编译<br>方法：找到界面中 <code>Batch Build</code> 下拉 -&gt; <code>Batch Setup</code> -&gt; <code>Select All</code> -&gt; <code>Close</code><br>再次点击<code>Batch Build</code> 下拉 -&gt; <code>Batch Rebuild</code><br>5）选择工程目录<br>方法：界面中点击 <code>Project</code> 目录中需要选中的项目，右击鼠标 -&gt; <code>Set as Active Project</code>  </p>]]></content>
    
    
    <summary type="html">MDK KEIL创建多工程-多工程编译</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-21T09:15:14.000Z</published>
    <updated>2023-11-22T16:42:12.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>没什么可看的，都是我不会记录一下</p></blockquote><span id="more"></span><h4 id="0-关于为什么要用-new-创建变量"><a href="#0-关于为什么要用-new-创建变量" class="headerlink" title="0. 关于为什么要用 new 创建变量"></a>0. 关于为什么要用 <code>new</code> 创建变量</h4><p>原因是分给程序的栈空间一般很小，<code>8M</code> 空间 ,当有很大的数组或者变量的时候，栈空间不足，但是堆空间很大，可以使用堆空间。</p><h4 id="1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数"><a href="#1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数" class="headerlink" title="1. 成员初始化表中成员初始化列表格式 如下形式，Student(string name,int age) 参数初始化对象中的参数"></a>1. 成员初始化表中成员初始化列表格式 如下形式，<code>Student(string name,int age)</code> 参数初始化对象中的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Student(string name,int age):name(Name),age(Age)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">private:</span><br><span class="line">string Name;</span><br><span class="line">int Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-new-创建数组，要使用如下方式删除数组-delete-数组名"><a href="#2-new-创建数组，要使用如下方式删除数组-delete-数组名" class="headerlink" title="2. new 创建数组，要使用如下方式删除数组 delete []数组名"></a>2. <code>new</code> 创建数组，要使用如下方式删除数组 <code>delete []数组名</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64_t *arr = new uint64_t[10];</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        *arr = 5;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] =*(arr+(i-1))*10;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *(arr + i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete[]arr;</span><br><span class="line">cout &lt;&lt; &quot;结束任务&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h4 id="3-对象的赋值和复制"><a href="#3-对象的赋值和复制" class="headerlink" title="3. 对象的赋值和复制"></a>3. 对象的赋值和复制</h4><p>（1）对象的赋值 如果两个对象都已存在，这种叫赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(&quot;yuyu&quot;,56);</span><br><span class="line">t1 = t2;</span><br></pre></td></tr></table></figure><p>（2）对象的复制（拷贝）用一个已存在的对象去创建一个新的对象，叫拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(t1);//Student t2 = t1;调用了一个拷贝构造函数</span><br></pre></td></tr></table></figure><h4 id="4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"><a href="#4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors" class="headerlink" title="4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"></a>4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）<code>-fno-elide-constructors</code></h4><h4 id="5-拷贝构造函数-copy-constructor"><a href="#5-拷贝构造函数-copy-constructor" class="headerlink" title="5. 拷贝构造函数(copy constructor)"></a>5. 拷贝构造函数(copy constructor)</h4><p>当一个类中没有显式的去声明拷贝构造函数时候，编译器会自动生成。自动生成的拷贝构造函数执行：逐成员赋值</p><h4 id="6-不可重载运算符以及只能被成员函数重载运算符"><a href="#6-不可重载运算符以及只能被成员函数重载运算符" class="headerlink" title="6. 不可重载运算符以及只能被成员函数重载运算符"></a>6. 不可重载运算符以及只能被成员函数重载运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不可重载运算符</span><br><span class="line">sizeof        sizeof运算符</span><br><span class="line">.             成员运算符</span><br><span class="line">.*            成员指针运算符</span><br><span class="line">::            作用域解析运算符</span><br><span class="line">?:            条件运算符</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只能被成员函数重载运算符</span><br><span class="line">=        赋值运算符</span><br><span class="line">()       函数调用运算符</span><br><span class="line">[]       下标运算符</span><br><span class="line">-&gt;       通过指针访问成员的运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-访问修饰符"><a href="#7-访问修饰符" class="headerlink" title="7. 访问修饰符"></a>7. 访问修饰符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private    私有的    只能在类的内部访问，外界不能直接访问</span><br><span class="line">public     公有的    在任意地方都可以访问</span><br><span class="line">protected  保护的    只能在类的内部访问，外界不能直接访问，其子类可以访问</span><br></pre></td></tr></table></figure><h4 id="8-浅拷贝与深拷贝"><a href="#8-浅拷贝与深拷贝" class="headerlink" title="8.浅拷贝与深拷贝"></a>8.浅拷贝与深拷贝</h4><p>浅拷贝：多个指针指向同一段内存<br>深拷贝：每个指针指向单独的内存</p><h4 id="9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。"><a href="#9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。" class="headerlink" title="9. new和delete重载函数，编译器默认加上了 static 是静态成员，该关键字可以是类成员也可以是全局成员。"></a>9. <code>new</code>和<code>delete</code>重载函数，编译器默认加上了 <code>static</code> 是静态成员，该关键字可以是类成员也可以是全局成员。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="10-using-使用using-关键字可以改变基类成员在派生类中的访问权限"><a href="#10-using-使用using-关键字可以改变基类成员在派生类中的访问权限" class="headerlink" title="10. using 使用using 关键字可以改变基类成员在派生类中的访问权限"></a>10. using 使用using 关键字可以改变基类成员在派生类中的访问权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">using A::m_b;//把m_b的权限修改为共有的</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">using A::m_a;//把m_a的权限修改为私有的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明"><a href="#11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明" class="headerlink" title="11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明"></a>11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showA(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_d;</span><br><span class="line">B():m_d(0),A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void showB(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因"><a href="#12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因" class="headerlink" title="12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)"></a>12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void showA(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_d;</span><br><span class="line">B():m_d(0),A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数1,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的构造函数2,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~B()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void showB(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">B b(10, 20, 30, 40);</span><br><span class="line">b.showA();</span><br><span class="line">b.showB();</span><br><span class="line">b.A::show();//重点</span><br><span class="line">b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-虚函数关键字：-virtual"><a href="#13-虚函数关键字：-virtual" class="headerlink" title="13. 虚函数关键字： virtual"></a>13. 虚函数关键字： virtual</h4><p>类中如果有虚函数，那么会创建虚函数列表，虚函数列表保存着虚函数地址，正常类成员函数，是在链接中放入类中<br>类中的成员变量。如果存在菱形的虚继承，也会出现虚成员表保存类成员，出现虚基类<br>如果要使用基类对象析构派生类对象时，需要对基类析构函数使用虚函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点"><a href="#14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点" class="headerlink" title="14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点"></a>14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~a()&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"><a href="#15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用" class="headerlink" title="15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"></a>15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">virtual void func() = 0;//基类中定义，但是继承类中一定要实现，才能实例化，</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_a = 10;</span><br><span class="line">A()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">virtual ~A() = 0</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual void showA(void) = 0//一定要有代码实现</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">protected:</span><br><span class="line">int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">int m_c = 30;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类"><a href="#16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类" class="headerlink" title="16. dynamic_cast 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)"></a>16. <code>dynamic_cast</code> 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)</h4><p>派生类指针 &#x3D; dynamic_cast&lt;派生类类型<code>*</code>&gt;(基类指针)<br>可以正确生成，则返回具体之，否则返回 <code>nullptr</code> ;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="17-typeid运算符和type-info类"><a href="#17-typeid运算符和type-info类" class="headerlink" title="17. typeid运算符和type_info类"></a>17. typeid运算符和type_info类</h4><p>typeid 用于获取数据类型的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// expre_typeid_Operator.cpp</span><br><span class="line">// compile with: /GR /EHsc</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void vvfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">   Derived* pd = new Derived;</span><br><span class="line">   Base* pb = pd;</span><br><span class="line">   cout &lt;&lt; typeid( pb ).name() &lt;&lt; endl;   //prints &quot;class Base *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pb ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   cout &lt;&lt; typeid( pd ).name() &lt;&lt; endl;   //prints &quot;class Derived *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pd ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   delete pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Base *</span><br><span class="line">class Derived</span><br><span class="line">class Derived *</span><br><span class="line">class Derived</span><br></pre></td></tr></table></figure><h4 id="18-关于-auto-的一些用法"><a href="#18-关于-auto-的一些用法" class="headerlink" title="18. 关于 auto 的一些用法"></a>18. 关于 <code>auto</code> 的一些用法</h4><p>方法一：代替冗长复杂的变量声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">double func(int a,int b , char *c ,int d)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;&quot;  b = &quot; &lt;&lt; b &lt;&lt;&quot;  c = &quot;&lt;&lt; c &lt;&lt; &quot;   d = &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">return 1.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">auto funcp = func;</span><br><span class="line">funcp(10,20,&quot;小婷&quot;,40); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="19-函数模板概念"><a href="#19-函数模板概念" class="headerlink" title="19. 函数模板概念"></a>19. 函数模板概念</h4><p>在对一个数据进行交换时，可能重载很多数据的交换类型，每增加一种数据类型，就要增加一个重载函数，这样始终不是很好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void Swap(int &amp;a , int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">int &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(double &amp;a , double &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">double &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(char &amp;a , char &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">char &amp;temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数模板是通用的函数描述，使用任意类型（泛型）来描述函数<br>编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。<br>生成函数定义的过程被称为实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//template模板</span><br><span class="line">//typename类型名称</span><br><span class="line">//template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">anytype temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">double temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10;</span><br><span class="line">int b = 20;</span><br><span class="line">Swap(a,b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不想让编译器自动推导，可以手工指定市场的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//template模板</span><br><span class="line">//typename类型名称</span><br><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">anytype temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">double temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str_a = &quot;小婷&quot;, str_b = &quot;小明&quot;;</span><br><span class="line">Swap&lt;string&gt;(str_a, str_b);//&lt;&gt;中强制指定类型</span><br><span class="line">cout &lt;&lt; &quot;str_a = &quot; &lt;&lt; str_a &lt;&lt; &quot;  str_b = &quot; &lt;&lt; str_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++98添加关键字typename之前，C++使用关键字class来创建模板；建议使用 <code>typename</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">template&lt;class anytype&gt;</span><br></pre></td></tr></table></figure><p>可以为类的成员函数创建模板，但是不能是虚函数和析构函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class template_class</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">template_class(T perem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void show(T perem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">template_class temp_class(&quot;小婷&quot;);</span><br><span class="line">temp_class.show(&quot;小婷&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数模板，必须明确数据类型，确保实参与函数模板能匹配上；函数模板多个变量时候，一定要保证<code>T</code>是相同类型，否则无法匹配，还有一个特殊类，函数模板没有参数，必须明确类型，如果没有参数，只能显示的指定类型了；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;shou函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">show&lt;int&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()//这种就不适用函数模板中的代码</span><br><span class="line">&#123;</span><br><span class="line">CGil a, b;</span><br><span class="line">add_vlaue(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用函数模板，如果是自动类型推导，不会发生隐式类型转换，如果显示指定了函数模板的数据类型，可以发生隐式类型转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">int a = 10; </span><br><span class="line">char b = 20;</span><br><span class="line">int c= add_vlaue&lt;int&gt;(a,b);//显式制定了函数模板的数据类型，编译器就可以对实参惊醒隐式类型转换</span><br><span class="line">cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; c &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数模板可以被重载，可以有非通用数据类型的参数（T Multi_type(T a, T2 b, int c)）；支持多个通用数据类型的参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b, int c)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2, typename T3, typename T4, typename T5&gt;</span><br><span class="line">T Multi_type(T a, T2 b, T3 c, T4 d, T5 e)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a + b + c + d + e;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = Multi_type((unsigned int)b, (unsigned char)f);</span><br></pre></td></tr></table></figure><h4 id="20-函数模板的具体化"><a href="#20-函数模板的具体化" class="headerlink" title="20. 函数模板的具体化"></a>20. 函数模板的具体化</h4><p>可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板；具体化（特丽化、特化）的语法；就是函数通用版本以外的一个特殊版本：<br>具体函数的返回值、函数名和形参列表与函数模板相同，但是对具体化函数来说，不管是函数的声明还是函数体中，都是具体的数据类型，没有通用的数据类型了，函数体中代码随意写，满足要求就可以<br>编译器推导实参数据类型匹配，会直接使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_rank;</span><br><span class="line">CGil(int a):m_rank(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show(string str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">CGil g1(10),g2(20);</span><br><span class="line">Swap(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">Swap(g1,g2);</span><br><span class="line">g1.show(&quot;g1&quot;);</span><br><span class="line">g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数模板声明和定义都可以分开写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b);</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; \</span><br><span class="line">void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; </span><br><span class="line">void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于给定的函数名，有普通函数、函数模板、具体化函数模板、重载函数<br>如果多种函数都可以匹配上，编译器使用规则<br>普通函数(重载函数) &gt; 具体化函数模板 &gt; 函数模板<br>如果希望使用函数模板，可以使用空模板参数强制使用函数模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//空模板函数示例</span><br><span class="line">Swap&lt;&gt;(1,2);//使用具体化函数模板示例</span><br></pre></td></tr></table></figure><p>如果函数模板能产生更好的匹配，将优先于普通函数</p><h4 id="21-函数模板-函数模板份文件编写"><a href="#21-函数模板-函数模板份文件编写" class="headerlink" title="21. 函数模板-函数模板份文件编写"></a>21. 函数模板-函数模板份文件编写</h4><p>函数模板只是函数的描述，没有实体(函数模板只是模型，并没有直接写入可执行文件中，有点宏定义特性)<br>《C++ P P》 函数模板一般放在头文件中<br>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中。<br>函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件，定义在源文件中</p><figure class="highlight plaintext"><figcaption><span>xxx.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_rank;</span><br><span class="line">CGil(int a):m_rank(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">void show(string str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数模板具体化</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>xxx.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#Include &quot;xxx.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">int temp = g1.m_rank;</span><br><span class="line">g1.m_rank = g2.m_rank;</span><br><span class="line">g2.m_rank = temp;</span><br><span class="line">cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">CGil g1(10),g2(20);</span><br><span class="line">Swap(a, b);</span><br><span class="line">cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Swap(g1,g2);</span><br><span class="line">g1.show(&quot;g1&quot;);</span><br><span class="line">g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通函数和函数模板具体化，在头文件声明，源文件中定义，函数模板都在头文件中（其他函数模板形式无意义）；</p><figure class="highlight plaintext"><figcaption><span>函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"><a href="#22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）" class="headerlink" title="22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"></a>22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）</h4><p><code>decltype</code> 关键字，在C++11中，decltype 操作符，用于查询表达式的的数据类型<br>语法 decltype(expression) var; expression:填写表达式 var:是变量<br><code>decltype</code> 分析表达式并得到他的类型，不会计算执行表达式。函数调用也是一种表达式，因此不必担心在使用 decltype 时执行了函数。<br><code>decltype</code> 返回值是数据类型，可以用它定义变量，后面直接写变量名就行了；如果表达式中有函数，不用担心会被调用执行<br>decltype 规则<br>（1）如果 <code>expression</code> 是没有用括号括起来的标识符(decltype本身括号不算括号,要在decltype内部再加一个括号)，则var的类型与该标识符的类型相同，包括const等限定符。</p><figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">short a = 5;</span><br><span class="line">decltype(a) da;//`da`变量类型与变量`a`相同，`a` `da`都是short</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）如果 <code>expression</code> 是函数调用，则var的类型与函数的返回值类型相同(函数不能返回 <code>void</code> ,但可以返回<code>（void *）</code> ;这是因为 <code>void</code> 无法声明变量)</p><figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int func_main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a = 100;</span><br><span class="line"></span><br><span class="line">//如下两个格式变量不相同 decltype表达式中，填函数调用和填函数名是两回事，</span><br><span class="line">//只填写函数名，得到的是函数的类型，不是返回值的类型 </span><br><span class="line">//函数返回值类型</span><br><span class="line">decltype(func_main())func_main_value = a;</span><br><span class="line"></span><br><span class="line">decltype(func_main) func_main_value_g;//无用 void 无法声明变量</span><br><span class="line"></span><br><span class="line">//函数名类型 :int()(),对变量名加入 * 号，转换为函数指针</span><br><span class="line">decltype(func_main) *pfunc_main_value = func;// void * 声明变量</span><br><span class="line">pfunc_main_value_g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果 <code>expression</code> 是左值（能取地址）（排除第一种可能）、或者用括号括起来的标识符，那么var的类型是<code>expression</code>的引用<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int func_main()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">return 10;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = 10;</span><br><span class="line"></span><br><span class="line">//注意：没有用括号和用了括号不一样</span><br><span class="line">decltype(b) copy_b; //int copy_b;</span><br><span class="line">//加了括号都变成了引用</span><br><span class="line">decltype((b)) yingyong1_b = b; // int &amp;yingyong1_b = b;</span><br><span class="line"></span><br><span class="line">decltype((func_main)) yingyong_func_main = func_main;// int (&amp;yingyong_func_main)() = func_main;</span><br><span class="line">//引用一定要初始化</span><br><span class="line">yingyong_func_main();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>（4）如果上面的条件都不满足，则var的类型与 <code>expression</code> 的类型相同；<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><br>decltype：关键字不是应用就是，就是变量<br>如果需要多次使用decltype,可以结合 <code>typedef</code> 和 <code>using</code><br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;//释放某个变量到当前作用域</span><br><span class="line">using namespace std;//释放这个命名空间到当前作用域</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><br>函数后置返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x ,int y);</span><br><span class="line">//等同</span><br><span class="line">auto func(int x,int y) -&gt; int;//C++11中有的，不管是函数声明还是定义都可以这么写</span><br></pre></td></tr></table></figure><p>将返回类型移到了函数声明后面。<br><code>auto</code> 是一个占位符（c++11给 <code>auto</code> 新增的角色），为函数返回值占了一个位置。<br>这种语法也可以用户函数定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) -&gt; int </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) -&gt; decltype(x+y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++14的 <code>auto</code> 关键字：C++14标准对函数返回类型推导规则做了优化，函数的返回值可以用 <code>auto</code> ,不必尾随返回类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , typename T2&gt;</span><br><span class="line">auto func(T x,T2 y)</span><br><span class="line">&#123;</span><br><span class="line">decltype(x+y) temp = x+y;</span><br><span class="line">return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="23-类模板-模板类的基本概念"><a href="#23-类模板-模板类的基本概念" class="headerlink" title="23. 类模板-模板类的基本概念"></a>23. 类模板-模板类的基本概念</h4><p>类模板与模板类都是同一个；函数模板和模板函数都是同一个。<br>类模板是通用类的描述，使用任意类型(泛型)来描述类的定义。<br>使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义</p><figure class="highlight plaintext"><figcaption><span>语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class 类模板名</span><br><span class="line">&#123;</span><br><span class="line">类的定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 2;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int, double &gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.m_a = &quot; &lt;&lt; a.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.m_b = &quot; &lt;&lt; a.m_b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用类模板，数据类型必须适应类模板中的代码；<br>类模板可以为通用类型指定缺省值的数据类型（C++11标准的才支持函数模板缺省值设置，以前不可以）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt; //如果T2没有指定类型，那么就会使用缺省值double</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 2;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板类的成员函数可以在类外实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">Tm_a;//通用类型用于成员变量</span><br><span class="line">T2m_b;//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的参数</span><br><span class="line">AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">~AA()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//通用类型用于成员函数的返回值</span><br><span class="line">T geta()</span><br><span class="line">&#123;</span><br><span class="line">T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">return m_a + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T2 getb();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">T2 AA&lt;T, T2&gt;::getb()</span><br><span class="line">&#123;</span><br><span class="line">T2 b = 1;</span><br><span class="line">return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">a.m_a = 10;</span><br><span class="line">a.m_b = 10.5;</span><br><span class="line">cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>new</code>创建模板类对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AA&lt;int ,double&gt; * p_a1 = new AA&lt;int ,double&gt;;</span><br><span class="line">AA&lt;int, double&gt;* p_a2 = new AA&lt;int, double&gt;(10, 10.5);</span><br><span class="line"></span><br><span class="line">delete p_a1;</span><br><span class="line">delete p_a2;</span><br></pre></td></tr></table></figure><p>模板类的成员函数和模板函数相同，都是使用了才会创建，不使用不会创建。</p><h4 id="24-模板类的示例-栈"><a href="#24-模板类的示例-栈" class="headerlink" title="24.模板类的示例-栈"></a>24.模板类的示例-栈</h4><p>模板类最常用的就是作为容器类<br>C++标准库:栈、数组、链表、二叉树和哈希表</p><h4 id="25-模板类的示例-数组"><a href="#25-模板类的示例-数组" class="headerlink" title="25.模板类的示例-数组"></a>25.模板类的示例-数组</h4><p>定长数组:array容器（C++11标准）<br>可变数组:vector容器<br>类模板的非通用类型参数</p><figure class="highlight plaintext"><figcaption><span>定长数组:array容器（C++11标准）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T items[MAXLEN];//数组元素</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T &amp;Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T &amp;Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Array&lt;int&gt; array;</span><br><span class="line">array[3] = 10;</span><br><span class="line">cout &lt;&lt; array[3] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板的非通用类型参数；非通用类型参数可以有缺省值，创建类型的时候，可以不用填写</p><figure class="highlight plaintext"><figcaption><span>类模板的非通用类型参数（定长类数组容器）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T,int len&gt;//类模板可以支持非通用类</span><br><span class="line">//template&lt;class T,int len = 10&gt;//类模板可以支持非通用类，非通用类添加缺省值</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T items[len];//数组元素</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Array();</span><br><span class="line">~Array();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">const T &amp;Array&lt;T,len&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">T &amp;Array&lt;T,len&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//如下是三个类</span><br><span class="line">Array&lt;string,100&gt; array;</span><br><span class="line">Array&lt;string,101&gt; array1;</span><br><span class="line">Array&lt;string,102&gt; array2;</span><br><span class="line"></span><br><span class="line">array[0] = &quot;小0&quot;;</span><br><span class="line">array[1] = &quot;小1&quot;;</span><br><span class="line">array[2] = &quot;小2&quot;;</span><br><span class="line">array[3] = &quot;小3&quot;;</span><br><span class="line">array[4] = &quot;小4&quot;;</span><br><span class="line">array[5] = &quot;小5&quot;;</span><br><span class="line">array[6] = &quot;小6&quot;;</span><br><span class="line">array[7] = &quot;小7&quot;;</span><br><span class="line">array[8] = &quot;小8&quot;;</span><br><span class="line">array[9] = &quot;小9&quot;;</span><br><span class="line">array[10] = &quot;小10&quot;;</span><br><span class="line">array[11] = &quot;小11&quot;;</span><br><span class="line">array[12] = &quot;小12&quot;;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 13; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; array[i].c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板可以有非通用类型参数：1.通常是整型(C++20标准可以用其它)；2.实例化模板必须用常量表达式；3.模板中不能修改参数的值<br>优点：在栈上分配内存，以维护，执行速度快，合适小型数组<br>缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类,导致程序的二进制代码会更大，运行的时候，占用的内存空间也更多，Vector_Array容器效率虽然不如Array容器，但是更通用，还可以自动扩展，也不会存在Array容器创建多个类定义的情况.<br>构造函数的方法更通用，因为数据的大小是类的成员(而不是硬编码)，可以创建数组大小可变的类。</p><figure class="highlight plaintext"><figcaption><span>变长数组容器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 10);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Vector_Array&lt;string&gt;array(5);</span><br><span class="line">array[0] = &quot;小11&quot;;</span><br><span class="line">array[1] = &quot;小12&quot;;</span><br><span class="line">array[2] = &quot;小13&quot;;</span><br><span class="line">array[3] = &quot;小14&quot;;</span><br><span class="line">array[4] = &quot;小15&quot;;</span><br><span class="line">array[5] = &quot;小16&quot;;</span><br><span class="line">array[6] = &quot;小17&quot;;</span><br><span class="line">array[7] = &quot;小18&quot;;</span><br><span class="line">array[8] = &quot;小19&quot;;</span><br><span class="line">array[9] = &quot;小110&quot;;</span><br><span class="line">array[10] =&quot;小111&quot;;</span><br><span class="line">array[11] =&quot;小112&quot;;</span><br><span class="line">array[12] =&quot;小113&quot;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;array.size_Array() = &quot; &lt;&lt; array.size_Array() &lt;&lt; endl;</span><br><span class="line">for (int i = 0; i &lt; array.size_Array(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;array[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; array[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="26-类模板-嵌套和递归使用模板类"><a href="#26-类模板-嵌套和递归使用模板类" class="headerlink" title="26.类模板-嵌套和递归使用模板类"></a>26.类模板-嵌套和递归使用模板类</h4><p>1.容器中有容器<br>2.数组的元素可以是栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DataType *items;</span><br><span class="line">int top;</span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Stack(int size = 3);</span><br><span class="line">~Stack();</span><br><span class="line">bool isempty();//判断栈是否为空。</span><br><span class="line">bool isfull();//判断栈是否以满</span><br><span class="line">bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;top = 0;</span><br><span class="line">this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">item = this-&gt;items[--this-&gt;top];</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;//释放原内存</span><br><span class="line">this-&gt;stacksize = v.stacksize;//栈实际的大小</span><br><span class="line">this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">this-&gt;top = v.top;//栈顶指针</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 2);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;len = v.len;</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">Vector_Array&lt; Stack&lt;string&gt; &gt; vs;</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">vs[0].push(&quot;小婷0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小明0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小雯0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[1].push(&quot;小婷1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小明1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小雯1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[2].push(&quot;小婷2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小明2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小雯2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[3].push(&quot;小婷3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小明3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小雯3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[4].push(&quot;小婷4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小明4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小雯4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[5].push(&quot;小婷5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小明5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小雯5&quot;);//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">&#123;</span><br><span class="line">while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">vs[ii].pop(item);</span><br><span class="line">cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.栈中的元素可以是数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DataType *items;</span><br><span class="line">int top;</span><br><span class="line">int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Stack(int size = 3);</span><br><span class="line">~Stack();</span><br><span class="line">bool isempty();//判断栈是否为空。</span><br><span class="line">bool isfull();//判断栈是否以满</span><br><span class="line">bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;top = 0;</span><br><span class="line">this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">if (this-&gt;top &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">item = this-&gt;items[--this-&gt;top];</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;//释放原内存</span><br><span class="line">this-&gt;stacksize = v.stacksize;//栈实际的大小</span><br><span class="line">this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">this-&gt;top = v.top;//栈顶指针</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int len;</span><br><span class="line">T* items;//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">Vector_Array(int size = 2);</span><br><span class="line">~Vector_Array();</span><br><span class="line">void resize(int size);//扩展数组内存空间</span><br><span class="line">int size_Array(void) const;//数组长度</span><br><span class="line">const T&amp; operator[](int idenx) const;//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">T&amp; operator[](int idenx);//重载操作符[], 可以修改数组中的元素</span><br><span class="line">/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">T* temp = nullptr;</span><br><span class="line">int i = 0;</span><br><span class="line">if (size &lt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">temp = new T[size];</span><br><span class="line">for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i] = this-&gt;items[i];</span><br><span class="line">&#125;</span><br><span class="line">delete[] this-&gt;items;</span><br><span class="line">this-&gt;items = temp;</span><br><span class="line">this-&gt;len = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">if (index &gt;= this-&gt;len)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;resize(index + 2);//扩展数组长度</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">delete[]this-&gt;items;</span><br><span class="line">this-&gt;len = v.len;</span><br><span class="line">this-&gt;items = new T[this-&gt;len];</span><br><span class="line">for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">&#123;</span><br><span class="line">this-&gt;items[ii] = v.items[ii];</span><br><span class="line">&#125;</span><br><span class="line">return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">Vector_Array&lt; Stack&lt;string&gt; &gt; vs;//数组中有栈</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">vs[0].push(&quot;小婷0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小明0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[0].push(&quot;小雯0&quot;);//vs容器中的第0个栈</span><br><span class="line">vs[1].push(&quot;小婷1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小明1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[1].push(&quot;小雯1&quot;);//vs容器中的第1个栈</span><br><span class="line">vs[2].push(&quot;小婷2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小明2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[2].push(&quot;小雯2&quot;);//vs容器中的第2个栈</span><br><span class="line">vs[3].push(&quot;小婷3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小明3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[3].push(&quot;小雯3&quot;);//vs容器中的第3个栈</span><br><span class="line">vs[4].push(&quot;小婷4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小明4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[4].push(&quot;小雯4&quot;);//vs容器中的第4个栈</span><br><span class="line">vs[5].push(&quot;小婷5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小明5&quot;);//vs容器中的第5个栈</span><br><span class="line">vs[5].push(&quot;小雯5&quot;);//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">&#123;</span><br><span class="line">while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">&#123;</span><br><span class="line">string item;</span><br><span class="line">vs[ii].pop(item);</span><br><span class="line">cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Stack容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">Stack&lt;Vector_Array&lt;string&gt;&gt;sv;//栈中有数组</span><br><span class="line"></span><br><span class="line">Vector_Array&lt;string&gt; temp;//栈的元素，临时Vector&lt;string&gt;容器</span><br><span class="line">//第一个入栈的元素</span><br><span class="line">temp[0] = &quot;西施1&quot;; temp[1] = &quot;西施2&quot;;sv.push(temp);</span><br><span class="line">//第二个入栈的元素</span><br><span class="line">temp[0] = &quot;西瓜1&quot;; temp[1] = &quot;西瓜2&quot;;sv.push(temp);</span><br><span class="line">//第三个入栈的元素</span><br><span class="line">temp[0] = &quot;冰冰1&quot;; temp[1] = &quot;冰冰2&quot;; temp[2] = &quot;冰冰3&quot;; temp[3] = &quot;冰冰4&quot;; sv.push(temp);</span><br><span class="line"></span><br><span class="line">Vector_Array&lt;string&gt; temp_pop;</span><br><span class="line">while (sv.isempty() == false)</span><br><span class="line">&#123;</span><br><span class="line">sv.pop(temp_pop);//出栈一个元素，放在临时容器中</span><br><span class="line"></span><br><span class="line">for (int ii = 0; ii &lt; temp_pop.size_Array(); ii++)//遍历临时Vector_Array&lt;string&gt;容器，显示容器中每个元素的值</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;vt[&quot; &lt;&lt; ii &lt;&lt; &quot;] = &quot; &lt;&lt; temp_pop[ii].c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建Vector_Array容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">Vector_Array&lt;Vector_Array&lt;string&gt;&gt; vv;//递归使用模板类</span><br><span class="line">//char a[][]//二维指针，是连续内存</span><br><span class="line">//char *a[] -&gt; char b[]递归模板类 是先创建一个指针数组，指针数组元素再指向一个数组</span><br><span class="line">//二维数组大小固定，这一个大小是可变的</span><br><span class="line">vv[0][0] = &quot;西施1&quot;; vv[0][1] = &quot;西施2&quot;; vv[0][2] = &quot;西施3&quot;;</span><br><span class="line">vv[1][0] = &quot;西瓜1&quot;; vv[1][1] = &quot;西瓜2&quot;;</span><br><span class="line">vv[2][0] = &quot;冰冰1&quot;; vv[2][1] = &quot;冰冰2&quot;; vv[2][2] = &quot;冰冰3&quot;; vv[2][3] = &quot;冰冰4&quot;;</span><br><span class="line"></span><br><span class="line">for (int ii = 0; ii &lt; vv.size_Array(); ii++)</span><br><span class="line">&#123;</span><br><span class="line">for (int jj = 0; jj &lt; vv[ii].size_Array(); jj++)</span><br><span class="line">&#123;</span><br><span class="line">//cout &lt;&lt; &quot;vv[&quot; &lt;&lt; ii &lt;&lt; &quot;][&quot; &lt;&lt; jj &lt;&lt; &quot;]= &quot; &lt;&lt; vv[ii][jj].c_str() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; vv[ii][jj].c_str() &lt;&lt; &quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++11 之前 嵌套使用模板类的时候 &gt; &gt;之间要加空格。</p><h4 id="27-类模板-模板类具体化"><a href="#27-类模板-模板类具体化" class="headerlink" title="27.类模板-模板类具体化"></a>27.类模板-模板类具体化</h4><p>模板类具体化(特化、特例化)有两种：完全具体化和部分具体化。</p><p>完全具体化：语法和函数模板集体化是相似的，template关键字，一对空的尖括号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(const T1 x, const T2 y):m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板完全具体化 模板类AA的一个完全具体化版本*/</span><br><span class="line">template&lt;&gt; </span><br><span class="line">class AA&lt;int, string&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">int m_x;</span><br><span class="line">string m_y;</span><br><span class="line">AA(int x, string y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;完全具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void AA&lt;int,string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;完全具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部分具体化：函数模板没有部分具体化说法，只有类模板才有,<br>部分具体化的意思是：为多个模板参数的部分参数指定具体的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">AA(T1 x, T2 y):m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板部分具体化 模板类AA的一个部分具体化版本*/</span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">class AA&lt;T1, string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">string m_y;</span><br><span class="line">AA(const T1 x, const string y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;部分具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">void AA&lt;T1, string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;部分具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>调用示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int, string&gt; aa_1(8, &quot;完全具体化类模板&quot;);</span><br><span class="line">aa_1.show();</span><br><span class="line"></span><br><span class="line">AA&lt;char, string&gt; aa_2(8, &quot;部分具体化类模板&quot;);</span><br><span class="line">aa_2.show();</span><br><span class="line"></span><br><span class="line">AA&lt;char, int&gt; aa_3(8, 8);</span><br><span class="line">aa_3.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板规则：具体化程度高 &gt; 集体化程度低 &gt; 没有具体化的类；主要看匹配</p><h4 id="28-类模板-模板类与继承"><a href="#28-类模板-模板类与继承" class="headerlink" title="28.类模板-模板类与继承"></a>28.类模板-模板类与继承</h4><p>1）模板类继承普通类（常见）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a):m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1,class T2&gt;</span><br><span class="line">class BB :public AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y, int a);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1,T2&gt;::BB(T1 x,T2 y,int a):AA(a),m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;, 9);</span><br><span class="line">bb_1.func2();</span><br><span class="line">bb_1.func1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）普通类继承模板类的实例版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AA: public BB&lt;int,string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, int x, string y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a,int x,string y):m_a(a),BB(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">//bb_1.func2();</span><br><span class="line"></span><br><span class="line">AA aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">aa_1.func1();</span><br><span class="line">aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）普通类继承模板类（常见） 要把普通类也变成模板类：注意的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, const T1 x, const T2 y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;int,string&gt; aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">aa_1.func1();</span><br><span class="line">aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）模板类继承模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">BB(T1 x, T2 y);</span><br><span class="line">~BB();</span><br><span class="line">void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA(int a, const T1 x, const T2 y);</span><br><span class="line">~AA();</span><br><span class="line">void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2,class T3&gt;</span><br><span class="line">class CC : public BB&lt;T2, T3&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_a;</span><br><span class="line">public:</span><br><span class="line">CC(T1 a, T2 x, T3 y);</span><br><span class="line">~CC();</span><br><span class="line">void func3();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1,T2 ,T3&gt;::CC(T1 a,T2 x,T3 y):m_a(a), BB&lt;T2,T3&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了CC的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1, T2, T3&gt;::~CC()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了CC析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">void CC&lt;T1, T2, T3&gt;::func3()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;调用了func3()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">CC&lt;int ,int ,string&gt; cc_1(4,5,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">cc_1.func2();</span><br><span class="line">cc_1.func3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）模板类继承模板类参数给出的基类（不能是模板类）关注 <code>EE</code> 类 EE既是模板类，也是派生类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">AA() &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">AA(int a) &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">BB() &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">BB(int a) &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~BB() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CC</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">CC() &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">CC(int a) &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~CC() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class DD</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">DD() &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">DD(int a) &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD(T a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">~DD() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class EE:public T//模板类继承模板阐述给出的基类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">EE():T() &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">EE(int a):T(a) &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE(int a)&quot; &lt;&lt; endl; &#125;//模板参数T调用基类构造函数</span><br><span class="line">~EE() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">EE&lt;AA&gt;ea1;//AA作为基类</span><br><span class="line">EE&lt;BB&gt;eb1;//BB作为基类</span><br><span class="line">EE&lt;CC&gt;ec1;//CC作为基类</span><br><span class="line">EE&lt;DD&lt;int&gt;&gt; ed1;//DD&lt;int&gt;作为基类 看上去像容器嵌套</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EE继承模板T，也就是他继承的是可以改变的，</p><h4 id="29-类模板-模板类与函数"><a href="#29-类模板-模板类与函数" class="headerlink" title="29.类模板-模板类与函数"></a>29.类模板-模板类与函数</h4><p>模板类可以用于函数的参数和返回值，有三种形式<br>1）普通函数，参数和返回值是模板类的实例化版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA&lt;int ,string&gt; func(AA&lt;int,string&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(AA&lt;int,string&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）函数模板，参数和返回值是某种模板类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板，参数和返回值的是模板类AA，这种不是通用的</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt; func(AA&lt;T1, T2&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(AA&lt;T1, T2&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）函数模板，参数和返回值是任意类型（支持普通类和米板类和其它类型）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">T1 m_x;</span><br><span class="line">T2 m_y;</span><br><span class="line">public:</span><br><span class="line">AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">~AA() &#123;&#125;;</span><br><span class="line">void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板类，参数和返回值都是任意类型</span><br><span class="line">template&lt;typename T1&gt;</span><br><span class="line">T1 func(T1 &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">aa.show();</span><br><span class="line">cout &lt;&lt; &quot;调用func(T1 &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种方法更规范，支持所有的类或者普通函数，第二种方法只支持AA这一种模板类，函数模板不管传入什么，只要符合函数内部程序就可以</p>]]></content>
    
    
    <summary type="html">C++学习笔记</summary>
    
    
    
    <category term="C++" scheme="https://goupos.top/categories/C/"/>
    
    
    <category term="C++" scheme="https://goupos.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL添加自定义XXX</title>
    <link href="https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89XXX/"/>
    <id>https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89XXX/</id>
    <published>2023-09-11T06:44:55.000Z</published>
    <updated>2023-09-13T09:13:19.549Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="哦，这些解密后的内容无法验证，不过你还是可以看看的。">  <script id="hbeData" type="hbeData" data-hmacdigest="da79ac6a7feec0eba324834689bb30212634e26506091f56cdea35ed465fd846">22af57287ee59bb36a4c5a3674ae7175e9ba87d1b08e855353ff04e6b3f142ed3fe92962bd9945ad32baab4a86d2aeaf890858386b4c8561844fb391a78ccac21f7c3f4524d4d35e347f2581cd69cefc3ea69f65e84c8eb6d827fcf6ae1e43637778d9e26aea85307bb31afd4dddd5d9b8694e46b51f72bd6c6b8688a253ee0c9acd2ba1ccdfeb7a87c53fcab56529bee2ae650f4dd8750dd5979f0d3945bd878d8f8ce02626f1a1d316fbe8908f1fcce813454d89fa26802c40a7b572ec30c63119db6d50c65dc80a6f2b8fb910f3104617a624ba832acd702911354aafa7106f3c5a2ddfea5515c5475499a182883cd94734f21eadfcd1ab5541d6c31245fdbccce44d2cc76301d5d89801cbb62c4264fd9b01085922af3fc1c6cb21c72d0b76ac1033154353644e37827794f878424b70e436ad0600d4226042eb5eb536f0d44b19033313e2803a06234640fe0a37265831d86c8e308a165d1235c768d48b819fd3f409eaac31de435ccc232b9e7c4a077c219a74813d19829d740b1732eb47218bf98b9f4fc03cf9148dff09e07669d5a7b7848c6d440ae396b9e42e830969c902c20dd18aea5fab907b779cb3207850a424b05a826beb91f939a94acdacdb10a2dca847f78dff8241a8a02c46d8081cf167aabab773106128a1dd3d61e8a368e8fdd64700005a3b3b5a52f51885d6da93b8d0522e1c518b25eb0f5e5dc181ded6684b33f196b57499579943cac5c8fdcb190c603f369fd15d5093fc8c504ecba220182dcff20ff946d540b2a71fe6e963e8d7ee8acaa4eee180d61e2ac3130f1120143e9df8ee5466c471693a836289415491076d8a1ff3ec1e87c9a5e1325d5a0ed9dd4a8659dab27b1e988cdb03bc3b9acaee07f090afd37d5cbfa15f835694ed226fa7e0faf4efce2f678895c03b7a53f154c0dc98cea3fbd95822036f3fb94a6d077b6306529f33f78d2f37e8608d6f08ffd61ba84668b7e9c94bc9bbbcda32604a0540cba108bc72faf5fbebb18b234744fdd7f683ffacf1e656a5a743a51271864535fb1f87587515e60833fc6c0afc6ef73b4e244da406bc2ac476146687a580ef1c804c90293959969f5026b2e3172afdfa403d7e25a8fadc4fff9aa6554efbab5f70cb9b695ca6588a15053042efad3d048acd66a50e6614fa46afe9351bdd462d81e157d8e6070a4f9fa1f9bf6b523e4a993cc5835aa9c7733eb7ff8404d124cae3f6376822f0c116daa9f9f869f7014830739256e73cfe944710f1ffe47b279e921a4a6e20bee2beb7ffb0ff518539c4a52a06f63c4ecd3fa4eee852ea8ad1766d03670de06c9102185e661fbeb2e0c78025259ba87446142a23ef81008ad923678376d0228729cf8005451ee54357e5dd428708f706d0f05fdb1a3a5489d433adce12b08721164baf31167b712a53bb532865d25486a6be50c85ba829b7d55789c5d00b0ebbbcd4ab091fa6dbaeab5d008e55ae30740d3089133c29596e475c4cdc48ee0995ed4c5a59f4cb1dff4a3f6fe65c019d4aa2e2f966bc6628eeb8f4955c205504cd50d3b7c376a42583f5de45128d5a1bf32fcdbe3066eb1d24daa7de21e3c36bde3c2f270b488ec35b4484c6108dc66db1cd011f6a21b8f64ebb61d68725de08d74f59fcd55dc24265b2e77ab5e801abe77a1ac7c2d03974e6b7d5b8bd72d94787dfa67d54bd84474ea11fa227ef7eac3075bcac90baacbf40efb4d719f383817d5b0047e280daa808ea75db5e260a70f534900c8e3292c46127caa2354949e8f00ea30f26e5734b0fca9bd56b4086bcded5f6327b8a14392422350426a669f564cd778519bdb5fd5f94d5e25bf546be52f733ec5549ac395caecf70a43bb79a28e259a2bfa209b8e86740a793c442135f7a54db5cb7f35c38921a051f70006bc2c16ea7e2bf09e46ae21c0c81a26ce4e7c656a8d06bfae484c7193280832a9f53e48dc5251d097fe1ee63195f578599af2498c8da9279d389005b5e3dc36160c75150e70dbb542671af54a119aa464821a5f45c7087b6e0f5dfc80b6ea7604f073afd00fff5360cfbcfb00b39a55dcde0cad94c17d2639db17dac04ee78a786e7bc37da690a09a68a97279e52fb018b89ef016bfc702407d7f0d2739a247d65850195ac17126a5e8326aa0e950ed9cd2d75a80ffefe9f13898b9ea63f57812598f47c08f3191cfffbbd0aacefb16029833730a3f8f33ef93602aba7cb787ba0bea4d08686a5145784db86ca1d352f1fad18eb5e16aa75053f2211d633aed8a4109edf8b46f615220ac0201021f47ec6682cbec40dc0d39744156d68031b632c4628c1d0630f8cf1577b49dc5882d068e99a09e1e1df1a74d8c8b6883a5b10ce55e0adfe7ac7a6bebd38190df64ed741f07704852c6f4312d0f5ef4ee4036a5d452abe63e56abf97c4d2f67af9905e5005065082d6dda78c797ccd263a642ae50e7c687109741c2fc65f460abb0e2fc0cbf25c35bcf1b07e35b1ce57cb2965d8cd1187823d90d8bc37f5968661e9e8609e378fc145dfb0b36d4180a6490bebdd8fd68a33638355c7e6a738b552fcf6924ea5f42cf2f26e1ddf93e3ad5672f99e90d80cba9c2a00e15909688f9bd403f210e1e749c9613490253a6b22ac5874d449ef5034c4722434f410608dfd43edd1433bb74e1377b1cdcfaf71c648b31ab8dd1a89a51ccfee0d222fa4340863dff4cb5c13401f2d85e4414cd641657319db368fcc251017b1d7325cf7f72834fbc56a22c2b74b81946b5112d605a21205355f3a425fb7310655c89dc5b3d4c18d2497911bb8f021594a18792138fc7b7e24e8dfec1c211ede1223420973c792ea360a4926bcd3bce09b46e295a0999955e6010cfeb62a104f566a0b825b5bc91402da338b8e32e4f5f98a49f1bf5ad0726bc2fc0e63cc5709e6a7867f7097fccd53e437b973896233ab567e76343ba2a9027ede1be089030e872de3628896e3233162a86579b93d4e640ba5efbf14ea6c438650a1033ebd4c62e529b556bd6b989ed1b8ecd1463886f419bd5915a055670df5d619d89b60417e41036afd598a43b437357b19035fb37c86463246de863ac51bf7b4903678b51d4e14ae165c9573284d86354b0f8cbad2dd86110f60162e43d97cad44e1a2623d45457abb78e6580419ffd5a541393d0a4a3390dc5d32080199e7e90166f806451103072ff0dcc5fb90f18b643054494608e0cb7b4402daeb91a641ae47af9c8fadf4dd7cac98df4e9dd1e9fa3022288f42f056e2e68063979aea41f6cb04d7fd703a322b391f7c86ded2fc42cca7ece9df7a7e79f694632f713dbb8d6186b8934384d3636e8d21c4b2cca35b51b4b6ab7a2054204e6bd0424b0295068d4c081ec26652066ba2e9134abc936f7cb408f5a3ed7a3f799a6b9ff8e758d94c5adfe64841e92f3c754a2496d6271c5ea6d983cbd5b66509d64a33fa043cedcf73e484fed3a46cc377137d554867cdf658f94db2e56192835f8469b874227136426cb50d99235724ce332b514d0c4f03df1aa4ad1105e08d9f4989c79ca27119cb31f36fb5af615c591b647e87ae8f07a067b5a576e0fcae7da5e9163bef8b4d69109b60222aadf4d0791d5c011ad8035740fc1af293521a2411ff9313e98807d8abd6a7cd0d58221c70e8b494d301de03886608ba7df77aa35b4a589fedf5b053c3f84e5f66dad259d0bbdb9afea3a43d9bbd67ed62055b0ef28825bc84159fe5963a6018a9de5b0c16c26e3b9f05d12b028a30e92218d81f941d1d3857a680b154c858441632183d569303b290f408c5ab3f2593afef697b269ca2b378f22b82d98e61b798dd1ccac5c1a2eb5fe7d9fefdcd10bc0914d510f3e532d4e5c2c863ab79935dc4e7e60ba0332b0d87d4ffa04f0fc66129ad263f96a14e3fc0d9c83743b9a1cc1c321a314d0c9c378485bb616864006948fc7e5b1fa31b45a2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请在此处输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">MDK KEIL添加自定义XXX</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>MDK KEIL sct文件</title>
    <link href="https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%20sct%E6%96%87%E4%BB%B6/"/>
    <id>https://goupos.top/2023/09/11/MDK%20KEIL/MDK%20KEIL%20sct%E6%96%87%E4%BB%B6/</id>
    <published>2023-09-11T01:51:26.000Z</published>
    <updated>2023-09-11T02:47:02.174Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>sct:分散加载文件<br>分散加载文件主要由一个加载时域加多个运行时域组成；同一个文件中可以有多个载时域；</p><h5 id="加载时域格式如下所示："><a href="#加载时域格式如下所示：" class="headerlink" title="加载时域格式如下所示："></a>加载时域格式如下所示：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load_region_name base_address max_size</span><br><span class="line">&#123;</span><br><span class="line">     execution_region_description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="运行时域格式如下："><a href="#运行时域格式如下：" class="headerlink" title="运行时域格式如下："></a>运行时域格式如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exec_region_name base_address max_size</span><br><span class="line">&#123;</span><br><span class="line">     input_section_description</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>load_region_name:为加载时域的名字，长度不超过31个字节</li><li>base_address:为加载时域的起始地址，即从该地址开始加载相关代码</li><li>max_size:为加载时域的最大范围，若实际大小超过该大小，链接器将会报错</li><li>execution_region_description:是对执行时域的描述</li><li>input_section_description:是对执行时域的描述</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LR_IROM1 0x08000000 0x00100000  &#123;    </span><br><span class="line">; 定义一个加载时域，域基址：0x08000000，域大小:0x00100000 ,对应实际 Flash 的大小</span><br><span class="line"></span><br><span class="line">ER_IROM1 0x08000000 0x00100000  &#123;  ; load address = execution address</span><br><span class="line">;定义一个运行时域，第一个运行时域必须和加载时域起始地址相同，否则库不能加载到该时域的</span><br><span class="line">;错误，其域大小一般也和加载时域大小相同</span><br><span class="line">*.o (RESET, +First)</span><br><span class="line">*(InRoot$$Sections)</span><br><span class="line">.ANY (+RO)</span><br><span class="line">.ANY (+XO)</span><br><span class="line">&#125;</span><br><span class="line">RW_IRAM1 0x20000000 0x00020000  &#123;  ; RW data</span><br><span class="line">.ANY (+RW +ZI)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MDK KEIL sct文件</summary>
    
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/categories/MDK-KEIL/"/>
    
    
    <category term="MDK KEIL" scheme="https://goupos.top/tags/MDK-KEIL/"/>
    
  </entry>
  
  <entry>
    <title>IAR Embedded学习笔记</title>
    <link href="https://goupos.top/2023/09/08/IAR%20Embedded/IAR%20Embedded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://goupos.top/2023/09/08/IAR%20Embedded/IAR%20Embedded%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2023-09-08T00:44:36.000Z</published>
    <updated>2023-10-25T06:52:18.572Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="IAR出现错误：Get-Alternative-File-解决办法"><a href="#IAR出现错误：Get-Alternative-File-解决办法" class="headerlink" title="IAR出现错误：Get Alternative File 解决办法"></a>IAR出现错误：Get Alternative File 解决办法</h4><ol><li>解决方法：点击 <code>Project</code> -&gt; <code>Rebuild All</code> </li><li>错误原因：出现这种错误的大多数原因是直接用例程，而例程在人家电脑上编译的，对应的路径文件也是人家电脑上的，所以必须重新rebuild一下对应到自己的电脑上。</li></ol><h4 id="Driver-Fatal-error-Failed-to-search-for-probes-ensure-that-the-USB-drivers-areinstallled-Session-aborted"><a href="#Driver-Fatal-error-Failed-to-search-for-probes-ensure-that-the-USB-drivers-areinstallled-Session-aborted" class="headerlink" title="Driver Fatal error: Failed to search for probes, ensure that the USB drivers areinstallled. Session aborted!"></a>Driver Fatal error: Failed to search for probes, ensure that the USB drivers areinstallled. Session aborted!</h4><ol><li>解决方法：点击 <code>Project</code> -&gt; <code>Options for node</code> -&gt; <code>Debugger</code> -&gt; <code>Driver</code> -&gt;选择对应烧入器</li><li>错误原因：烧入器选择错误。</li></ol><h4 id="IAR的警告-Warning-Pa050-non-native-end-of-line-sequence-detected-this-diagnostic-is-only-issued-once"><a href="#IAR的警告-Warning-Pa050-non-native-end-of-line-sequence-detected-this-diagnostic-is-only-issued-once" class="headerlink" title="IAR的警告: Warning[Pa050]: non-native end of line sequence detected (this diagnostic is only issued once)."></a>IAR的警告: Warning[Pa050]: non-native end of line sequence detected (this diagnostic is only issued once).</h4><p>先来说说这个警告产生的原因: 在Windows中换行符使用 <code>&lt;CR&gt;&lt;LF&gt;</code> 来表示换行, 在UNIX类系统中则使用 <code>&lt;LF&gt;</code>. 当一个文件从一个系统转换到另外一个系统, 因为换行符的定义不同, 就会产生问题<br>知道了原因, 但问题依然不好解决. 有时候可能有几百个上千个文件从Linux平台转到Windown平台编译, 总不能一个一个的改吧? 好在此警告对结果并没影响, 所以采取简单粗暴的方式, 将它屏蔽掉, 眼不见心不烦.</p><p>解决方法： 点击 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Diagnostics</code> -&gt; <code>Suppress these diagnostics</code> -&gt; <code>填写 Pa050</code> 警告就消失了</p><h4 id="IAR设置堆栈和进程内存布局"><a href="#IAR设置堆栈和进程内存布局" class="headerlink" title="IAR设置堆栈和进程内存布局"></a>IAR设置堆栈和进程内存布局</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>Linker</code>功能菜单 -&gt; <code>Config</code>选项 -&gt; <code>Linker configuration file</code>选项框 -&gt; <code>Edit</code></p><h4 id="IAR设置堆栈时出现：-Auxliary-file-path-xxx-is-missing-or-corrupt-The-linker-configuration-file-can-only-be-edited-in-a-text-editor"><a href="#IAR设置堆栈时出现：-Auxliary-file-path-xxx-is-missing-or-corrupt-The-linker-configuration-file-can-only-be-edited-in-a-text-editor" class="headerlink" title="IAR设置堆栈时出现： Auxliary file path:xxx is missing or corrupt.The linker configuration file can only be edited in a text editor."></a>IAR设置堆栈时出现： <code>Auxliary file path:xxx is missing or corrupt.The linker configuration file can only be edited in a text editor.</code></h4><p>解决方法： 暂时没有找到</p><h4 id="IAR窗口恢复默认"><a href="#IAR窗口恢复默认" class="headerlink" title="IAR窗口恢复默认"></a>IAR窗口恢复默认</h4><p>解决方法： 1. 关闭IAR； 2.定位到工程目录下的settings文件夹； 3. 找到扩展名为.wsdt的文件； 4. 删除该类型的文件； 5. 重新打开工程。</p><h4 id="IAR-添加目标头文件"><a href="#IAR-添加目标头文件" class="headerlink" title="IAR 添加目标头文件"></a>IAR 添加目标头文件</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Preprocessor</code> -&gt; <code>Additional include directories: (one per line)</code> -&gt; <code>···</code> 建议头文件转换成如下格式，方便后续人员使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$PROJ_DIR$\..\Cmsis</span><br><span class="line">$PROJ_DIR$\..\Lib\inc</span><br><span class="line">$PROJ_DIR$\..\Lib\src</span><br></pre></td></tr></table></figure><p>点击<code>···</code> 进入后，输入一下路径，后面有一个下拉按钮选择路劲格式</p><h4 id="IAR-添加全局宏定义"><a href="#IAR-添加全局宏定义" class="headerlink" title="IAR 添加全局宏定义"></a>IAR 添加全局宏定义</h4><p>解决方法： 右键点击项目工程或 <code>Project</code> -&gt; <code>Options...</code> -&gt; <code>C/C++ Compiler</code> -&gt; <code>Preprocessor</code> -&gt; <code>Defined symbols: (one per line)</code> 格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE_STDPERIPH_DRIVER</span><br><span class="line">USING_LOG</span><br></pre></td></tr></table></figure><h4 id="IAR-擦除FLASH"><a href="#IAR-擦除FLASH" class="headerlink" title="IAR 擦除FLASH"></a>IAR 擦除FLASH</h4><p>擦除全部存储空间：<code>Project</code> -&gt; <code>Download</code> -&gt; <code>Erase Memory</code></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
    <summary type="html">IAR Embedded学习笔记</summary>
    
    
    
    <category term="IAR Embedded" scheme="https://goupos.top/categories/IAR-Embedded/"/>
    
    
    <category term="IAR Embedded" scheme="https://goupos.top/tags/IAR-Embedded/"/>
    
  </entry>
  
  <entry>
    <title>ARM汇编语言(1)</title>
    <link href="https://goupos.top/2023/09/04/ARM%E5%86%85%E6%A0%B8/ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(1)/"/>
    <id>https://goupos.top/2023/09/04/ARM%E5%86%85%E6%A0%B8/ARM%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80(1)/</id>
    <published>2023-09-04T05:31:25.000Z</published>
    <updated>2023-09-15T09:16:04.118Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误" data-whm="哦，这些解密后的内容无法验证，不过你还是可以看看的。">  <script id="hbeData" type="hbeData" data-hmacdigest="0699c0fbcd07fc34b745ea1246eb1035c75d101e4053f77317a636b9c666f0d1">f496cd034c8aee30e043308baebb9aa1749c213bc84bf71ed4b391462c9cbd2439b82bd456529492e7e8a4b9ac0a7cd8512a27ca9804b21d779c2e61b3ce7f3a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-flip">      <input class="hbe hbe-input-field hbe-input-field-flip" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-flip" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-flip" data-content="请在此处输入密码">请在此处输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">ARM汇编语言(1)</summary>
    
    
    
    <category term="ARM内核" scheme="https://goupos.top/categories/ARM%E5%86%85%E6%A0%B8/"/>
    
    
    <category term="ARM内核" scheme="https://goupos.top/tags/ARM%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>c语言关键字执行顺序</title>
    <link href="https://goupos.top/2023/09/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>https://goupos.top/2023/09/02/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</id>
    <published>2023-09-02T12:05:47.000Z</published>
    <updated>2023-09-02T12:30:30.088Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h4 id="1-for-关键字执行顺序。"><a href="#1-for-关键字执行顺序。" class="headerlink" title="1. for 关键字执行顺序。"></a>1. <code>for</code> 关键字执行顺序。</h4><figure class="highlight plaintext"><figcaption><span>for</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include  &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint8_t i = 0;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    for(i = 0 ,printf(&quot;for 1\t&quot;); i &lt; 3 ,printf(&quot;for 2\t&quot;); i++ ,printf(&quot;for 3\t&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">        if(i == 3)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 1   for 2   i = 0 初始化时候</span><br><span class="line">for 3   for 2   i = 1 运行时候</span><br><span class="line">for 3   for 2   i = 2</span><br><span class="line">for 3   for 2   i = 3</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">c语言关键字执行顺序</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="c语言关键字执行顺序" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/c%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Office中文离线安装包下载地址合集</title>
    <link href="https://goupos.top/2023/08/31/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/Office%E4%B8%AD%E6%96%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%88%E9%9B%86/"/>
    <id>https://goupos.top/2023/08/31/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/Office%E4%B8%AD%E6%96%87%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%90%88%E9%9B%86/</id>
    <published>2023-08-31T04:14:29.000Z</published>
    <updated>2023-08-31T04:15:40.792Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span>]]></content>
    
    
    <summary type="html">Office中文离线安装包下载地址合集</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>BAT文件</title>
    <link href="https://goupos.top/2023/08/29/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/BAT%E6%96%87%E4%BB%B6/"/>
    <id>https://goupos.top/2023/08/29/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/BAT%E6%96%87%E4%BB%B6/</id>
    <published>2023-08-29T13:48:28.000Z</published>
    <updated>2023-08-29T13:51:17.032Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>参考源<br>正在编写</p></blockquote>]]></content>
    
    
    <summary type="html">BAT文件</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>win纯净系统安装注册等</title>
    <link href="https://goupos.top/2023/08/27/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/win%E5%AE%89%E8%A3%85/"/>
    <id>https://goupos.top/2023/08/27/win%E7%94%B5%E8%84%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/win%E5%AE%89%E8%A3%85/</id>
    <published>2023-08-26T23:03:27.000Z</published>
    <updated>2023-08-29T13:03:09.595Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>由于图库存在问题，暂时没有图片<br>需要准备的，需要准备一台电脑和一个U盘，建议选择USB3.0或以上的，这样插在USB3.0接口上，安装系统更快，U盘大小选择8G</p></blockquote><h1 id="1-原装-windows-点击此处进入：windows系统"><a href="#1-原装-windows-点击此处进入：windows系统" class="headerlink" title="1. 原装 windows 点击此处进入：windows系统"></a>1. 原装 <code>windows</code> 点击此处进入：<a href="https://www.microsoft.com/zh-cn/software-download/">windows系统</a></h1><ol><li>安装教程如下视频：（引用别人视频，可以登入bilbil账号查看高清）</li><li>选择想要安装的系统点击进入，选择立即下载工具，然后安装工具，根据安装提示操作，制作操作系统选择U盘制作，下面是视频(个别地方可以根据自己需求修改)<iframe src="//player.bilibili.com/player.html?aid=342656275&bvid=BV1e94y1y7zS&cid=752740223&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol><h1 id="2-windows注册"><a href="#2-windows注册" class="headerlink" title="2.windows注册"></a>2.windows注册</h1><ol><li>注册成专业版，以 <code>管理员身份</code> 启动 &#96;cmd.exe（命令提示符）,依次输入如下代码(注意一定要用管理员启动，否则可能注册失败)<br>下面两个注册码任选一个<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ipk 33PXH-7Y6KF-2VJC9-XBBR8-HVTHH</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure></li><li>关于如何使用使用 <code>管理员身份</code> 启动 <code>cmd.exe（命令提示符）</code>：<br> 方法一、可以在win左下角搜索框中输入 <code>cmd.exe</code> 然后右击会提示管理员启动；<br> 方法二、按下<code>win</code> + <code>r</code>按键（如下视频中会有），然后在任务栏中找到 <code>cmd.exe（命令提示符）</code>鼠标右击可以看到命令提示符，然后选择命令提示符再次右击，就可以看到以管理员身份运行，然后再输入上面的命令。</li><li>相关参考视频可以参考如下<iframe src="//player.bilibili.com/player.html?aid=637362623&bvid=BV1jb4y1p7mr&cid=549239255&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol>]]></content>
    
    
    <summary type="html">win纯净系统安装注册等</summary>
    
    
    
    <category term="windows" scheme="https://goupos.top/categories/windows/"/>
    
    
    <category term="windows" scheme="https://goupos.top/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>娱乐C语言</title>
    <link href="https://goupos.top/2023/08/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/"/>
    <id>https://goupos.top/2023/08/26/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/</id>
    <published>2023-08-26T02:59:12.000Z</published>
    <updated>2023-09-01T06:43:04.063Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>收集娱乐C代码(只为了收集不做任何其他用)<br>点击 <code>0</code> 项，可以直接导航到在线编译器，可以验证下列代码以及猜想,欢迎提供更多娱乐代码</p></blockquote><h5 id="0-代码验证导航"><a href="#0-代码验证导航" class="headerlink" title="0.代码验证导航"></a>0.<a href="https://rextester.com/l/c_online_compiler_gcc"><code>代码验证导航</code></a></h5><h5 id="1-娱乐代码示例一：使用-替换所有-参考于网友给的截图-图一乐就好"><a href="#1-娱乐代码示例一：使用-替换所有-参考于网友给的截图-图一乐就好" class="headerlink" title="1. 娱乐代码示例一：使用 - 替换所有 (参考于网友给的截图,图一乐就好)"></a>1. 娱乐代码示例一：使用 <code>-</code> 替换所有 (参考于网友给的截图,图一乐就好)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define __ main</span><br><span class="line">#define _____ int</span><br><span class="line">#define ___ printf</span><br><span class="line">#define ____ &quot;TIME&quot;</span><br><span class="line">#define ______ return</span><br><span class="line">#define _______ 0</span><br><span class="line">#define _ ;</span><br><span class="line">#define ________ &quot;%s\n&quot;</span><br><span class="line">#define _________ &quot;test&quot;</span><br><span class="line">#define __________ (</span><br><span class="line">#define ___________ )</span><br><span class="line">#define ____________ ,</span><br><span class="line"></span><br><span class="line">_____ __()</span><br><span class="line">&#123;</span><br><span class="line">    ___ __________ ________ ____________ _________ ___________ _</span><br><span class="line">    ___ __________ ________ ____________ ____ ___________ _</span><br><span class="line">    ______ _______ _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>运行结果</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test</span><br><span class="line">TIME</span><br></pre></td></tr></table></figure><h5 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h5>]]></content>
    
    
    <summary type="html">娱乐C语言</summary>
    
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
    <category term="娱乐C语言" scheme="https://goupos.top/categories/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/%E5%A8%B1%E4%B9%90C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言与编译器关键字以及宏和代码" scheme="https://goupos.top/tags/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8%E5%85%B3%E9%94%AE%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%AE%8F%E5%92%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>GD32芯片索引</title>
    <link href="https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%B4%A2%E5%BC%95/"/>
    <id>https://goupos.top/2023/08/22/GD32/GD32%E8%8A%AF%E7%89%87%E7%B4%A2%E5%BC%95/</id>
    <published>2023-08-22T09:49:14.000Z</published>
    <updated>2023-08-22T09:57:12.027Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此文件只是问题索引，不展示任何数据</p></blockquote><span id="more"></span><h1 id="1-问题索引"><a href="#1-问题索引" class="headerlink" title="1.问题索引"></a>1.问题索引</h1><h1 id="2-笔记索引"><a href="#2-笔记索引" class="headerlink" title="2.笔记索引"></a>2.笔记索引</h1>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此文件只是问题索引，不展示任何数据&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="FPGA" scheme="https://goupos.top/categories/FPGA/"/>
    
    
    <category term="FPGA" scheme="https://goupos.top/tags/FPGA/"/>
    
  </entry>
  
</feed>
