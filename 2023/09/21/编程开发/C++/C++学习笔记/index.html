<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="https://s2.loli.net/2022/05/05/gBXlLUE2i9YxOuT.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://s2.loli.net/2022/05/05/gBXlLUE2i9YxOuT.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://s2.loli.net/2022/05/05/gBXlLUE2i9YxOuT.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"goupos.top","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="C++学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="C++学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-09-21T09:15:14.000Z">
<meta property="article:modified_time" content="2023-11-22T16:42:12.083Z">
<meta property="article:author" content="构造">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","path":"2023/09/21/编程开发/C++/C++学习笔记/","title":"C++学习笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++学习笔记 | 个人博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">个人博客</p>
      <i class="logo-line"></i>
    </a>
      <img class="custom-logo-image" src="https://s2.loli.net/2023/02/13/HuK2GO4lL76ZEFQ.gif" alt="个人博客">
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#0-%E5%85%B3%E4%BA%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-new-%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F"><span class="nav-text">0. 关于为什么要用 new 创建变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A1%A8%E4%B8%AD%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%A0%BC%E5%BC%8F-%E5%A6%82%E4%B8%8B%E5%BD%A2%E5%BC%8F%EF%BC%8CStudent-string-name-int-age-%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-text">1. 成员初始化表中成员初始化列表格式 如下形式，Student(string name,int age) 参数初始化对象中的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-new-%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84%EF%BC%8C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A6%82%E4%B8%8B%E6%96%B9%E5%BC%8F%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84-delete-%E6%95%B0%E7%BB%84%E5%90%8D"><span class="nav-text">2. new 创建数组，要使用如下方式删除数组 delete []数组名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="nav-text">3. 对象的赋值和复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%8C%E9%82%A3%E4%B9%88%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%B0%83%E7%94%A8%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%EF%BC%88%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%9C%89%E4%BA%9B%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%9A%E8%A2%AB%E4%BC%98%E5%8C%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%8D%E5%B8%8C%E6%9C%9B%E8%A2%AB%E4%BC%98%E5%85%88%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%89%E9%A1%B9%EF%BC%89-fno-elide-constructors"><span class="nav-text">4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-copy-constructor"><span class="nav-text">5. 拷贝构造函数(copy constructor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%8F%8A%E5%8F%AA%E8%83%BD%E8%A2%AB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">6. 不可重载运算符以及只能被成员函数重载运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">7. 访问修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-text">8.浅拷贝与深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-new%E5%92%8Cdelete%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%EF%BC%8C%E7%BC%96%E8%AF%91%E5%99%A8%E9%BB%98%E8%AE%A4%E5%8A%A0%E4%B8%8A%E4%BA%86-static-%E6%98%AF%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%EF%BC%8C%E8%AF%A5%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%AF%E4%BB%A5%E6%98%AF%E7%B1%BB%E6%88%90%E5%91%98%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%85%A8%E5%B1%80%E6%88%90%E5%91%98%E3%80%82"><span class="nav-text">9. new和delete重载函数，编译器默认加上了 static 是静态成员，该关键字可以是类成员也可以是全局成员。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-using-%E4%BD%BF%E7%94%A8using-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-text">10. using 使用using 关键字可以改变基类成员在派生类中的访问权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E5%A6%82%E6%9E%9C%E8%A6%81%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%B1%BB-%E7%88%B6%E7%B1%BB-%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB-%E5%AD%90%E7%B1%BB-%E4%B8%AD%E6%8C%87%E6%98%8E"><span class="nav-text">11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E5%90%8D%E5%AD%97%E5%B1%8F%E8%94%BD%E5%92%8C%E7%B1%BB%E8%A7%A3%E6%9E%90%E7%AC%A6-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E4%B8%AD%E4%B8%8E%E7%88%B6%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%8A%A0%E4%B8%8A%E7%B1%BB%E5%90%8D%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%8C%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E4%B8%AD%E5%90%8C%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%9B%E5%BD%93%E5%AD%98%E5%9C%A8%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E6%97%B6%EF%BC%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B5%8C%E5%A5%97%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%90%E5%91%98%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%B7%B2%E7%BB%8F%E6%89%BE%E5%88%B0%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%BB%A7%E7%BB%AD%E6%9F%A5%E6%89%BE%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%89%BE%E5%88%B0%EF%BC%8C%E5%88%99%E7%BB%A7%E7%BB%AD%E5%9C%A8%E5%9F%BA%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E6%9F%A5%E6%89%BE%EF%BC%9B%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%8E%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E4%B8%8D%E8%83%BD%E6%9E%84%E6%88%90%E9%87%8D%E8%BD%BD%E4%B9%9F%E6%98%AF%E8%BF%99%E4%B8%AA%E5%8E%9F%E5%9B%A0"><span class="nav-text">12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E8%99%9A%E5%87%BD%E6%95%B0%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A-virtual"><span class="nav-text">13. 虚函数关键字： virtual</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E5%9F%BA%E7%B1%BB%E4%B8%AD%E5%8D%B3%E4%BD%BF%E4%B8%8D%E9%9C%80%E8%A6%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B9%9F%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E5%9C%A8%E6%9C%89%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="nav-text">14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%9F%BA%E7%B1%BB%E4%B8%AD%E6%9C%89%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%97%A0%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E6%88%96%E5%BC%95%E7%94%A8%EF%BC%9B%E5%90%AB%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A2%AB%E7%A7%B0%E4%B8%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E4%B8%8D%E9%A5%BF%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8"><span class="nav-text">15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-dynamic-cast-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%94%A8%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%E6%9D%A5%E7%94%9F%E6%88%90%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88%E3%80%82%E4%BB%96%E4%B8%8D%E8%83%BD%E5%9B%9E%E7%AD%94%E2%80%9C%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BD%86%E8%83%BD%E5%9B%9E%E7%AD%94%E2%80%9C%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%89%E5%85%A8%E7%9A%84%E5%B0%86%E5%AF%B9%E8%B1%A1%E5%9C%B0%E5%9D%80%E8%B5%8B%E7%BB%99%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88%E2%80%9D%E9%97%AE%E9%A2%98-%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8C%85%E5%90%AB%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-text">16. dynamic_cast 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-typeid%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8Ctype-info%E7%B1%BB"><span class="nav-text">17. typeid运算符和type_info类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-%E5%85%B3%E4%BA%8E-auto-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="nav-text">18. 关于 auto 的一些用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%A6%82%E5%BF%B5"><span class="nav-text">19. 函数模板概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%85%B7%E4%BD%93%E5%8C%96"><span class="nav-text">20. 函数模板的具体化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%BB%BD%E6%96%87%E4%BB%B6%E7%BC%96%E5%86%99"><span class="nav-text">21. 函数模板-函数模板份文件编写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E9%AB%98%E7%BA%A7%EF%BC%88%E5%BD%93%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%AD%EF%BC%8C%E6%9C%89%E5%A4%9A%E4%B8%AA%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="nav-text">22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">23. 类模板-模板类的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%A4%BA%E4%BE%8B-%E6%A0%88"><span class="nav-text">24.模板类的示例-栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#25-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%A4%BA%E4%BE%8B-%E6%95%B0%E7%BB%84"><span class="nav-text">25.模板类的示例-数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#26-%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E5%B5%8C%E5%A5%97%E5%92%8C%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-text">26.类模板-嵌套和递归使用模板类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#27-%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E5%85%B7%E4%BD%93%E5%8C%96"><span class="nav-text">27.类模板-模板类具体化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#28-%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-text">28.类模板-模板类与继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#29-%E7%B1%BB%E6%A8%A1%E6%9D%BF-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-text">29.类模板-模板类与函数</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="构造"
      src="https://img-qn-2.51miz.com/preview/element/00/01/25/80/E-1258046-80796AAA.gif">
  <p class="site-author-name" itemprop="name">构造</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="sidebar-button site-overview-item animated">
    <button class="js-gitter-toggle-chat-button"><i class="fa fa-comment"></i>
      在线讨论
    </button>
  </div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/XGM001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;XGM001" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://gitee.com/xgm-embedded-os/GoupOS" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;xgm-embedded-os&#x2F;GoupOS" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>Gitee</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xgmcreate@foxmail.com" title="E-Mail0 → mailto:xgmcreate@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail0</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xgmcreate@189.cn" title="E-Mail1 → mailto:xgmcreate@189.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail1</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      技术帮助友情链接与网站导航
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://home.goupos.top/" title="https:&#x2F;&#x2F;home.goupos.top&#x2F;" rel="noopener" target="_blank">网站导航</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://blog.bubuzi.top/" title="http:&#x2F;&#x2F;blog.bubuzi.top&#x2F;" rel="noopener" target="_blank">布布子Blog</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://home.bubuzi.top/" title="https:&#x2F;&#x2F;home.bubuzi.top&#x2F;" rel="noopener" target="_blank">布布子导航</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://home.bubuzi.top/" title="https:&#x2F;&#x2F;home.bubuzi.top&#x2F;" rel="noopener" target="_blank">导航对齐</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://goupos.top/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img-qn-2.51miz.com/preview/element/00/01/25/80/E-1258046-80796AAA.gif">
      <meta itemprop="name" content="构造">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="个人博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++学习笔记 | 个人博客">
      <meta itemprop="description" content="C++学习笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++学习笔记
        </h1>

        <div class="post-meta-container">
          
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-09-21 17:15:14" itemprop="dateCreated datePublished" datetime="2023-09-21T17:15:14+08:00">2023-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-11-23 00:42:12" itemprop="dateModified" datetime="2023-11-23T00:42:12+08:00">2023-11-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    <a title="C++学习笔记" href="/2023/09/21/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91/C++/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#SOHUCS" itemprop="discussionUrl">
      <span id="sourceId::3a940a97979c391c27ed09f3ee2aee82" class="cy_cmt_count" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>46k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>42 分钟</span>
    </span>
</div>

            <div class="post-description">C++学习笔记</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>没什么可看的，都是我不会记录一下</p>
</blockquote>
<span id="more"></span>
<h4 id="0-关于为什么要用-new-创建变量"><a href="#0-关于为什么要用-new-创建变量" class="headerlink" title="0. 关于为什么要用 new 创建变量"></a>0. 关于为什么要用 <code>new</code> 创建变量</h4><p>原因是分给程序的栈空间一般很小，<code>8M</code> 空间 ,当有很大的数组或者变量的时候，栈空间不足，但是堆空间很大，可以使用堆空间。</p>
<h4 id="1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数"><a href="#1-成员初始化表中成员初始化列表格式-如下形式，Student-string-name-int-age-参数初始化对象中的参数" class="headerlink" title="1. 成员初始化表中成员初始化列表格式 如下形式，Student(string name,int age) 参数初始化对象中的参数"></a>1. 成员初始化表中成员初始化列表格式 如下形式，<code>Student(string name,int age)</code> 参数初始化对象中的参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">	public:</span><br><span class="line">		Student(string name,int age):name(Name),age(Age)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	private:</span><br><span class="line">		string Name;</span><br><span class="line">		int Age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-new-创建数组，要使用如下方式删除数组-delete-数组名"><a href="#2-new-创建数组，要使用如下方式删除数组-delete-数组名" class="headerlink" title="2. new 创建数组，要使用如下方式删除数组 delete []数组名"></a>2. <code>new</code> 创建数组，要使用如下方式删除数组 <code>delete []数组名</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">uint64_t *arr = new uint64_t[10];</span><br><span class="line">int i = 0;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (i == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        *arr = 5;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        arr[i] =*(arr+(i-1))*10;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *(arr + i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delete[]arr;</span><br><span class="line">cout &lt;&lt; &quot;结束任务&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h4 id="3-对象的赋值和复制"><a href="#3-对象的赋值和复制" class="headerlink" title="3. 对象的赋值和复制"></a>3. 对象的赋值和复制</h4><p>（1）对象的赋值 如果两个对象都已存在，这种叫赋值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(&quot;yuyu&quot;,56);</span><br><span class="line">t1 = t2;</span><br></pre></td></tr></table></figure>
<p>（2）对象的复制（拷贝）用一个已存在的对象去创建一个新的对象，叫拷贝</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student t1(&quot;pxl&quot;,29);</span><br><span class="line">Student t2(t1);//Student t2 = t1;调用了一个拷贝构造函数</span><br></pre></td></tr></table></figure>

<h4 id="4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"><a href="#4-如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数-（这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors" class="headerlink" title="4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）-fno-elide-constructors"></a>4. 如果一个函数返回的是一个类类型的对象，那么一定会调用拷贝构造函数 （这个过程，有些编译器会被优化，如果不希望被优先，可以加一个选项）<code>-fno-elide-constructors</code></h4><h4 id="5-拷贝构造函数-copy-constructor"><a href="#5-拷贝构造函数-copy-constructor" class="headerlink" title="5. 拷贝构造函数(copy constructor)"></a>5. 拷贝构造函数(copy constructor)</h4><p>当一个类中没有显式的去声明拷贝构造函数时候，编译器会自动生成。自动生成的拷贝构造函数执行：逐成员赋值</p>
<h4 id="6-不可重载运算符以及只能被成员函数重载运算符"><a href="#6-不可重载运算符以及只能被成员函数重载运算符" class="headerlink" title="6. 不可重载运算符以及只能被成员函数重载运算符"></a>6. 不可重载运算符以及只能被成员函数重载运算符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不可重载运算符</span><br><span class="line">sizeof        sizeof运算符</span><br><span class="line">.             成员运算符</span><br><span class="line">.*            成员指针运算符</span><br><span class="line">::            作用域解析运算符</span><br><span class="line">?:            条件运算符</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">只能被成员函数重载运算符</span><br><span class="line">=        赋值运算符</span><br><span class="line">()       函数调用运算符</span><br><span class="line">[]       下标运算符</span><br><span class="line">-&gt;       通过指针访问成员的运算符</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="7-访问修饰符"><a href="#7-访问修饰符" class="headerlink" title="7. 访问修饰符"></a>7. 访问修饰符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private    私有的    只能在类的内部访问，外界不能直接访问</span><br><span class="line">public     公有的    在任意地方都可以访问</span><br><span class="line">protected  保护的    只能在类的内部访问，外界不能直接访问，其子类可以访问</span><br></pre></td></tr></table></figure>

<h4 id="8-浅拷贝与深拷贝"><a href="#8-浅拷贝与深拷贝" class="headerlink" title="8.浅拷贝与深拷贝"></a>8.浅拷贝与深拷贝</h4><p>浅拷贝：多个指针指向同一段内存<br>深拷贝：每个指针指向单独的内存</p>
<h4 id="9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。"><a href="#9-new和delete重载函数，编译器默认加上了-static-是静态成员，该关键字可以是类成员也可以是全局成员。" class="headerlink" title="9. new和delete重载函数，编译器默认加上了 static 是静态成员，该关键字可以是类成员也可以是全局成员。"></a>9. <code>new</code>和<code>delete</code>重载函数，编译器默认加上了 <code>static</code> 是静态成员，该关键字可以是类成员也可以是全局成员。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="10-using-使用using-关键字可以改变基类成员在派生类中的访问权限"><a href="#10-using-使用using-关键字可以改变基类成员在派生类中的访问权限" class="headerlink" title="10. using 使用using 关键字可以改变基类成员在派生类中的访问权限"></a>10. using 使用using 关键字可以改变基类成员在派生类中的访问权限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a = 10;</span><br><span class="line">protected:</span><br><span class="line">	int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">	int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	using A::m_b;	//把m_b的权限修改为共有的</span><br><span class="line">protected:</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	using A::m_a;	//把m_a的权限修改为私有的</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明"><a href="#11-如果要使用基类-父类-的构造函数-，可以在派生类-子类-中指明" class="headerlink" title="11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明"></a>11. 如果要使用基类(父类)的构造函数 ，可以在派生类(子类)中指明</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a = 10;</span><br><span class="line">	A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showA(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">	int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_d;</span><br><span class="line">	B():m_d(0),A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的构造函数,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~B()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void showB(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因"><a href="#12-名字屏蔽和类解析符-继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因" class="headerlink" title="12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)"></a>12. 名字屏蔽和类解析符(继承的类中与父类中有同名函数，可以加上类名和作用域，调用父类中同名函数；当存在继承关系时，基类的作用域嵌套在派生类的作用域中，如果成员在派生类的作用域已经找到，就不会在基类作用域中继续查找，如果没有找到，则继续在基类作用域中查找；派生类与基类成员不能构成重载也是这个原因)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a = 10;</span><br><span class="line">	A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void showA(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void show(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">	int m_c = 30;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B:public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_d;</span><br><span class="line">	B():m_d(0),A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的构造函数1,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	B(int a,int b,int c,int d):A(a,b,c),m_d(d)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的构造函数2,并初始化A。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~B()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了B的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void showB(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show(void)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_d = &quot; &lt;&lt; m_d &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	B b(10, 20, 30, 40);</span><br><span class="line">	b.showA();</span><br><span class="line">	b.showB();</span><br><span class="line">	b.A::show();		//重点</span><br><span class="line">	b.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-虚函数关键字：-virtual"><a href="#13-虚函数关键字：-virtual" class="headerlink" title="13. 虚函数关键字： virtual"></a>13. 虚函数关键字： virtual</h4><p>类中如果有虚函数，那么会创建虚函数列表，虚函数列表保存着虚函数地址，正常类成员函数，是在链接中放入类中<br>类中的成员变量。如果存在菱形的虚继承，也会出现虚成员表保存类成员，出现虚基类<br>如果要使用基类对象析构派生类对象时，需要对基类析构函数使用虚函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点"><a href="#14-基类中即使不需要析构函数也需要创建一个虚析构函数-在有继承关系的类中需要注意的点" class="headerlink" title="14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点"></a>14. 基类中即使不需要析构函数也需要创建一个虚析构函数 在有继承关系的类中需要注意的点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual ~a()&#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"><a href="#15-纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用" class="headerlink" title="15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用"></a>15.  纯虚函数，如果基类中有纯虚函数，无法创建对象实例化，但是可以创建指针或引用；含有虚函数的类被称为抽象类，不饿能实例化对象，可以创建指针和引用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">virtual void func() = 0;//基类中定义，但是继承类中一定要实现，才能实例化，</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_a = 10;</span><br><span class="line">	A()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数1。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(int a,int b,int c):m_a(a),m_b(b),m_c(c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数2。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	A(A &amp;co_a) :m_a(co_a.m_a), m_b(co_a.m_b), m_c(co_a.m_c)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的构造函数3。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	virtual ~A() = 0</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;调用了A的析构函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	virtual void showA(void) = 0//一定要有代码实现</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;m_a = &quot; &lt;&lt; m_a &lt;&lt; &quot;  m_b = &quot; &lt;&lt; m_b &lt;&lt; &quot;  m_c = &quot; &lt;&lt; m_c &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">protected:</span><br><span class="line">	int m_b = 20;</span><br><span class="line">private:</span><br><span class="line">	int m_c = 30;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类"><a href="#16-dynamic-cast-运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题-只适用于包含虚函数的类" class="headerlink" title="16. dynamic_cast 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)"></a>16. <code>dynamic_cast</code> 运算符用指向基类的指针来生成派生类的指针。他不能回答“指针指向的是什么类的对象”问题，但能回答“是否可以安全的将对象地址赋给特定类型的指针”问题(只适用于包含虚函数的类)</h4><p>派生类指针 &#x3D; dynamic_cast&lt;派生类类型<code>*</code>&gt;(基类指针)<br>可以正确生成，则返回具体之，否则返回 <code>nullptr</code> ;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="17-typeid运算符和type-info类"><a href="#17-typeid运算符和type-info类" class="headerlink" title="17. typeid运算符和type_info类"></a>17. typeid运算符和type_info类</h4><p>typeid 用于获取数据类型的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// expre_typeid_Operator.cpp</span><br><span class="line">// compile with: /GR /EHsc</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;typeinfo&gt;</span><br><span class="line"></span><br><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">   virtual void vvfunc() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived : public Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">   Derived* pd = new Derived;</span><br><span class="line">   Base* pb = pd;</span><br><span class="line">   cout &lt;&lt; typeid( pb ).name() &lt;&lt; endl;   //prints &quot;class Base *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pb ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   cout &lt;&lt; typeid( pd ).name() &lt;&lt; endl;   //prints &quot;class Derived *&quot;</span><br><span class="line">   cout &lt;&lt; typeid( *pd ).name() &lt;&lt; endl;   //prints &quot;class Derived&quot;</span><br><span class="line">   delete pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Base *</span><br><span class="line">class Derived</span><br><span class="line">class Derived *</span><br><span class="line">class Derived</span><br></pre></td></tr></table></figure>


<h4 id="18-关于-auto-的一些用法"><a href="#18-关于-auto-的一些用法" class="headerlink" title="18. 关于 auto 的一些用法"></a>18. 关于 <code>auto</code> 的一些用法</h4><p>方法一：代替冗长复杂的变量声明。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">double func(int a,int b , char *c ,int d)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt;&quot;  b = &quot; &lt;&lt; b &lt;&lt;&quot;  c = &quot;&lt;&lt; c &lt;&lt; &quot;   d = &quot; &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">	return 1.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	auto funcp = func;</span><br><span class="line">	funcp(10,20,&quot;小婷&quot;,40); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="19-函数模板概念"><a href="#19-函数模板概念" class="headerlink" title="19. 函数模板概念"></a>19. 函数模板概念</h4><p>在对一个数据进行交换时，可能重载很多数据的交换类型，每增加一种数据类型，就要增加一个重载函数，这样始终不是很好。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void Swap(int &amp;a , int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	int &amp;temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(double &amp;a , double &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	double &amp;temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(char &amp;a , char &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	char &amp;temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数模板是通用的函数描述，使用任意类型（泛型）来描述函数<br>编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。<br>生成函数定义的过程被称为实例化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//template		模板</span><br><span class="line">//typename		类型名称</span><br><span class="line">//template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	anytype temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)	//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">	double temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10;</span><br><span class="line">	int b = 20;</span><br><span class="line">	Swap(a,b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;  b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想让编译器自动推导，可以手工指定市场的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//template		模板</span><br><span class="line">//typename		类型名称</span><br><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void Swap(anytype&amp; a, anytype&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	anytype temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Swap(int &amp; a, double&amp; b)	//可以对函数模板进行重载(这里只是举例子)</span><br><span class="line">&#123;</span><br><span class="line">	double temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">		string str_a = &quot;小婷&quot;, str_b = &quot;小明&quot;;</span><br><span class="line">		Swap&lt;string&gt;(str_a, str_b);//&lt;&gt;中强制指定类型</span><br><span class="line">		cout &lt;&lt; &quot;str_a = &quot; &lt;&lt; str_a &lt;&lt; &quot;  str_b = &quot; &lt;&lt; str_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++98添加关键字typename之前，C++使用关键字class来创建模板；建议使用 <code>typename</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">template&lt;class anytype&gt;</span><br></pre></td></tr></table></figure>
<p>可以为类的成员函数创建模板，但是不能是虚函数和析构函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class template_class</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	template&lt;typename T&gt;</span><br><span class="line">	template_class(T perem)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	template&lt;typename T&gt;</span><br><span class="line">	void show(T perem)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;perem = &quot; &lt;&lt; perem &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	template_class temp_class(&quot;小婷&quot;);</span><br><span class="line">	temp_class.show(&quot;小婷&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数模板，必须明确数据类型，确保实参与函数模板能匹配上；函数模板多个变量时候，一定要保证<code>T</code>是相同类型，否则无法匹配，还有一个特殊类，函数模板没有参数，必须明确类型，如果没有参数，只能显示的指定类型了；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename anytype&gt;//模板样板  anytype:任意类型名字。可以自己随意定义</span><br><span class="line">void show()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;shou函数&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	show&lt;int&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数模板时，推导的数据类型必须适应函数模板中的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()//这种就不适用函数模板中的代码</span><br><span class="line">&#123;</span><br><span class="line">	CGil a, b;</span><br><span class="line">	add_vlaue(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数模板，如果是自动类型推导，不会发生隐式类型转换，如果显示指定了函数模板的数据类型，可以发生隐式类型转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T add_vlaue(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">	return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	int a = 10; </span><br><span class="line">	char b = 20;</span><br><span class="line">	int c= add_vlaue&lt;int&gt;(a,b);	//显式制定了函数模板的数据类型，编译器就可以对实参惊醒隐式类型转换</span><br><span class="line">	cout &lt;&lt; &quot;a + b = &quot; &lt;&lt; c &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>函数模板可以被重载，可以有非通用数据类型的参数（T Multi_type(T a, T2 b, int c)）；支持多个通用数据类型的参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a + b;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2&gt;</span><br><span class="line">T Multi_type(T a, T2 b, int c)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a + b;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T, typename T2, typename T3, typename T4, typename T5&gt;</span><br><span class="line">T Multi_type(T a, T2 b, T3 c, T4 d, T5 e)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a + b + c + d + e;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = Multi_type((unsigned int)b, (unsigned char)f);</span><br></pre></td></tr></table></figure>


<h4 id="20-函数模板的具体化"><a href="#20-函数模板的具体化" class="headerlink" title="20. 函数模板的具体化"></a>20. 函数模板的具体化</h4><p>可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板；具体化（特丽化、特化）的语法；就是函数通用版本以外的一个特殊版本：<br>具体函数的返回值、函数名和形参列表与函数模板相同，但是对具体化函数来说，不管是函数的声明还是函数体中，都是具体的数据类型，没有通用的数据类型了，函数体中代码随意写，满足要求就可以<br>编译器推导实参数据类型匹配，会直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_rank;</span><br><span class="line">	CGil(int a):m_rank(a)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	void show(string str)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = g1.m_rank;</span><br><span class="line">	g1.m_rank = g2.m_rank;</span><br><span class="line">	g2.m_rank = temp;</span><br><span class="line">	cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10, b = 20;</span><br><span class="line">	CGil g1(10),g2(20);</span><br><span class="line">	Swap(a, b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line">	Swap(g1,g2);</span><br><span class="line">	g1.show(&quot;g1&quot;);</span><br><span class="line">	g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板声明和定义都可以分开写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b);</span><br><span class="line"></span><br><span class="line">/*如下两种方法是一样的效果*/</span><br><span class="line">//template&lt;&gt; 		\</span><br><span class="line">void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; </span><br><span class="line">void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T &amp;a, T &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = g1.m_rank;</span><br><span class="line">	g1.m_rank = g2.m_rank;</span><br><span class="line">	g2.m_rank = temp;</span><br><span class="line">	cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于给定的函数名，有普通函数、函数模板、具体化函数模板、重载函数<br>如果多种函数都可以匹配上，编译器使用规则<br>普通函数(重载函数) &gt; 具体化函数模板 &gt; 函数模板<br>如果希望使用函数模板，可以使用空模板参数强制使用函数模板</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//空模板函数示例</span><br><span class="line">Swap&lt;&gt;(1,2);//使用具体化函数模板示例</span><br></pre></td></tr></table></figure>
<p>如果函数模板能产生更好的匹配，将优先于普通函数</p>
<h4 id="21-函数模板-函数模板份文件编写"><a href="#21-函数模板-函数模板份文件编写" class="headerlink" title="21. 函数模板-函数模板份文件编写"></a>21. 函数模板-函数模板份文件编写</h4><p>函数模板只是函数的描述，没有实体(函数模板只是模型，并没有直接写入可执行文件中，有点宏定义特性)<br>《C++ P P》 函数模板一般放在头文件中<br>函数模板只是函数的描述，没有实体，创建函数模板的代码放在头文件中。<br>函数模板的具体化有实体，编译的原理和普通函数一样，所以，声明放在头文件，定义在源文件中</p>
<figure class="highlight plaintext"><figcaption><span>xxx.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class CGil</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_rank;</span><br><span class="line">	CGil(int a):m_rank(a)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	void show(string str)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; str + &#x27;.&#x27; &lt;&lt; &quot;m_rank = &quot; &lt;&lt; m_rank &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void Swap(T&amp; a, T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">	T temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">	cout &lt;&lt; &quot;void Swap(T &amp;a, T &amp;b)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数模板具体化</span><br><span class="line">//template&lt;&gt; void Swap&lt;CGil&gt;(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2);</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><figcaption><span>xxx.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#Include &quot;xxx.h&quot;</span><br><span class="line"></span><br><span class="line">template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)</span><br><span class="line">&#123;</span><br><span class="line">	int temp = g1.m_rank;</span><br><span class="line">	g1.m_rank = g2.m_rank;</span><br><span class="line">	g2.m_rank = temp;</span><br><span class="line">	cout &lt;&lt; &quot;template&lt;&gt; void Swap(CGil&amp; g1, CGil&amp; g2)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 10, b = 20;</span><br><span class="line">	CGil g1(10),g2(20);</span><br><span class="line">	Swap(a, b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; ,b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	Swap(g1,g2);</span><br><span class="line">	g1.show(&quot;g1&quot;);</span><br><span class="line">	g2.show(&quot;g2&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>普通函数和函数模板具体化，在头文件声明，源文件中定义，函数模板都在头文件中（其他函数模板形式无意义）；</p>
<figure class="highlight plaintext"><figcaption><span>函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">	decltype(x+y) temp = x+y;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"><a href="#22-函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）" class="headerlink" title="22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）"></a>22. 函数模板-函数模板高级（当函数模板中，有多个通用类型时候使用）</h4><p><code>decltype</code> 关键字，在C++11中，decltype 操作符，用于查询表达式的的数据类型<br>语法 decltype(expression) var; expression:填写表达式 var:是变量<br><code>decltype</code> 分析表达式并得到他的类型，不会计算执行表达式。函数调用也是一种表达式，因此不必担心在使用 decltype 时执行了函数。<br><code>decltype</code> 返回值是数据类型，可以用它定义变量，后面直接写变量名就行了；如果表达式中有函数，不用担心会被调用执行<br>decltype 规则<br>（1）如果 <code>expression</code> 是没有用括号括起来的标识符(decltype本身括号不算括号,要在decltype内部再加一个括号)，则var的类型与该标识符的类型相同，包括const等限定符。</p>
<figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	short a = 5;</span><br><span class="line">	decltype(a) da;//`da`变量类型与变量`a`相同，`a` `da`都是short</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）如果 <code>expression</code> 是函数调用，则var的类型与函数的返回值类型相同(函数不能返回 <code>void</code> ,但可以返回<code>（void *）</code> ;这是因为 <code>void</code> 无法声明变量)</p>
<figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int func_main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">	return 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 100;</span><br><span class="line"></span><br><span class="line">	//如下两个格式变量不相同 decltype表达式中，填函数调用和填函数名是两回事，</span><br><span class="line">	//只填写函数名，得到的是函数的类型，不是返回值的类型 </span><br><span class="line">	//函数返回值类型</span><br><span class="line">	decltype(func_main())func_main_value = a;</span><br><span class="line"></span><br><span class="line">	decltype(func_main) func_main_value_g;	//无用 void 无法声明变量</span><br><span class="line"></span><br><span class="line">	//函数名类型 :int()(),对变量名加入 * 号，转换为函数指针</span><br><span class="line">	decltype(func_main) *pfunc_main_value = func;	// void * 声明变量</span><br><span class="line">	pfunc_main_value_g();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）如果 <code>expression</code> 是左值（能取地址）（排除第一种可能）、或者用括号括起来的标识符，那么var的类型是<code>expression</code>的引用<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	int func_main()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main 被调用&quot; &lt;&lt; endl;</span><br><span class="line">	return 10;</span><br><span class="line">&#125;</span><br><span class="line">	int main()</span><br><span class="line">	&#123;</span><br><span class="line">		int b = 10;</span><br><span class="line">		</span><br><span class="line">		//注意：没有用括号和用了括号不一样</span><br><span class="line">		decltype(b) copy_b; //int copy_b;</span><br><span class="line">		//加了括号都变成了引用</span><br><span class="line">		decltype((b)) yingyong1_b = b; // int &amp;yingyong1_b = b;</span><br><span class="line"></span><br><span class="line">		decltype((func_main)) yingyong_func_main = func_main;// int (&amp;yingyong_func_main)() = func_main;</span><br><span class="line">		//引用一定要初始化</span><br><span class="line">	yingyong_func_main();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure><br>（4）如果上面的条件都不满足，则var的类型与 <code>expression</code> 的类型相同；<br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><br>decltype：关键字不是应用就是，就是变量<br>如果需要多次使用decltype,可以结合 <code>typedef</code> 和 <code>using</code><br> <figure class="highlight plaintext"><figcaption><span>示例代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using std::cout;		//释放某个变量到当前作用域</span><br><span class="line">using namespace std;	//释放这个命名空间到当前作用域</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><br>函数后置返回值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int func(int x ,int y);</span><br><span class="line">//等同</span><br><span class="line">auto func(int x,int y) -&gt; int;//C++11中有的，不管是函数声明还是定义都可以这么写</span><br></pre></td></tr></table></figure>
<p>将返回类型移到了函数声明后面。<br><code>auto</code> 是一个占位符（c++11给 <code>auto</code> 新增的角色），为函数返回值占了一个位置。<br>这种语法也可以用户函数定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , tyoename T2&gt;</span><br><span class="line">auto func(T x,T2 y) -&gt; decltype(x + y)//后面在形参x和y的作用域内，前面不在形成 x 和 y 的作用域内</span><br><span class="line">&#123;</span><br><span class="line">	decltype(x+y) temp = x+y;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) -&gt; int </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) -&gt; decltype(x+y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">	return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++14的 <code>auto</code> 关键字：C++14标准对函数返回类型推导规则做了优化，函数的返回值可以用 <code>auto</code> ,不必尾随返回类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//函数模板有多个类型，并且有返回值，无法确认返回类型示例代码</span><br><span class="line">template&lt;typename T , typename T2&gt;</span><br><span class="line">auto func(T x,T2 y)</span><br><span class="line">&#123;</span><br><span class="line">	decltype(x+y) temp = x+y;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_3(int x,int y) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto func_main_2(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;func_main_2&quot; &lt;&lt; endl;</span><br><span class="line">	return x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int b = func_main_2(100,100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="23-类模板-模板类的基本概念"><a href="#23-类模板-模板类的基本概念" class="headerlink" title="23. 类模板-模板类的基本概念"></a>23. 类模板-模板类的基本概念</h4><p>类模板与模板类都是同一个；函数模板和模板函数都是同一个。<br>类模板是通用类的描述，使用任意类型(泛型)来描述类的定义。<br>使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义</p>
<figure class="highlight plaintext"><figcaption><span>语法</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class 类模板名</span><br><span class="line">&#123;</span><br><span class="line">	类的定义；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T	m_a;	//通用类型用于成员变量</span><br><span class="line">	T2	m_b;	//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的参数</span><br><span class="line">	AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	~AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的返回值</span><br><span class="line">	T geta()</span><br><span class="line">	&#123;</span><br><span class="line">		T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">		return m_a + a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T2 getb()</span><br><span class="line">	&#123;</span><br><span class="line">		T2 b = 2;</span><br><span class="line">		return m_b + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	AA &lt;int, double &gt; a;//类模板需要指定具体类型</span><br><span class="line">	a.m_a = 10;</span><br><span class="line">	a.m_b = 10.5;</span><br><span class="line">	cout &lt;&lt; &quot;a.m_a = &quot; &lt;&lt; a.m_a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a.m_b = &quot; &lt;&lt; a.m_b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用类模板，数据类型必须适应类模板中的代码；<br>类模板可以为通用类型指定缺省值的数据类型（C++11标准的才支持函数模板缺省值设置，以前不可以）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt; //如果T2没有指定类型，那么就会使用缺省值double</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T	m_a;	//通用类型用于成员变量</span><br><span class="line">	T2	m_b;	//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的参数</span><br><span class="line">	AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	~AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的返回值</span><br><span class="line">	T geta()</span><br><span class="line">	&#123;</span><br><span class="line">		T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">		return m_a + a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T2 getb()</span><br><span class="line">	&#123;</span><br><span class="line">		T2 b = 2;</span><br><span class="line">		return m_b + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">	a.m_a = 10;</span><br><span class="line">	a.m_b = 10.5;</span><br><span class="line">	cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板类的成员函数可以在类外实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T, class T2 = double&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T	m_a;	//通用类型用于成员变量</span><br><span class="line">	T2	m_b;	//通用类型用于成员变量</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的参数</span><br><span class="line">	AA(T x, T2 y):m_a(x),m_b(y)//</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	~AA()</span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	//通用类型用于成员函数的返回值</span><br><span class="line">	T geta()</span><br><span class="line">	&#123;</span><br><span class="line">		T a = 2; //通用类型用于成员函数的代码中</span><br><span class="line">		return m_a + a;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	T2 getb();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, class T2&gt;</span><br><span class="line">T2 AA&lt;T, T2&gt;::getb()</span><br><span class="line">&#123;</span><br><span class="line">	T2 b = 1;</span><br><span class="line">	return m_b + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	AA &lt;int&gt; a;//类模板需要指定具体类型</span><br><span class="line">	a.m_a = 10;</span><br><span class="line">	a.m_b = 10.5;</span><br><span class="line">	cout &lt;&lt; &quot;a.geta() = &quot; &lt;&lt; a.geta() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;a.getb() = &quot; &lt;&lt; a.getb() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用<code>new</code>创建模板类对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AA&lt;int ,double&gt; * p_a1 = new AA&lt;int ,double&gt;;</span><br><span class="line">AA&lt;int, double&gt;* p_a2 = new AA&lt;int, double&gt;(10, 10.5);</span><br><span class="line"></span><br><span class="line">delete p_a1;</span><br><span class="line">delete p_a2;</span><br></pre></td></tr></table></figure>
<p>模板类的成员函数和模板函数相同，都是使用了才会创建，不使用不会创建。</p>
<h4 id="24-模板类的示例-栈"><a href="#24-模板类的示例-栈" class="headerlink" title="24.模板类的示例-栈"></a>24.模板类的示例-栈</h4><p>模板类最常用的就是作为容器类<br>C++标准库:栈、数组、链表、二叉树和哈希表</p>
<h4 id="25-模板类的示例-数组"><a href="#25-模板类的示例-数组" class="headerlink" title="25.模板类的示例-数组"></a>25.模板类的示例-数组</h4><p>定长数组:array容器（C++11标准）<br>可变数组:vector容器<br>类模板的非通用类型参数</p>
<figure class="highlight plaintext"><figcaption><span>定长数组:array容器（C++11标准）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T items[MAXLEN];	//数组元素</span><br><span class="line">	const T&amp; operator[](int idenx) const;	//重载操作符[], 可以修改数组中的元素</span><br><span class="line">	T&amp; operator[](int idenx);	//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Array();</span><br><span class="line">	~Array();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">	memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Array&lt;T&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T &amp;Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T &amp;Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;//这里是不完善的，可以自己完善</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Array&lt;int&gt; array;</span><br><span class="line">	array[3] = 10;</span><br><span class="line">	cout &lt;&lt; array[3] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>类模板的非通用类型参数；非通用类型参数可以有缺省值，创建类型的时候，可以不用填写</p>
<figure class="highlight plaintext"><figcaption><span>类模板的非通用类型参数（定长类数组容器）</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T,int len&gt;//类模板可以支持非通用类</span><br><span class="line">//template&lt;class T,int len = 10&gt;//类模板可以支持非通用类，非通用类添加缺省值</span><br><span class="line">class Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T items[len];	//数组元素</span><br><span class="line">	const T&amp; operator[](int idenx) const;	//重载操作符[], 可以修改数组中的元素</span><br><span class="line">	T&amp; operator[](int idenx);	//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Array();</span><br><span class="line">	~Array();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::Array()</span><br><span class="line">&#123;</span><br><span class="line">	//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">Array&lt;T,len&gt;::~Array()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">const T &amp;Array&lt;T,len&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T, int len&gt;</span><br><span class="line">T &amp;Array&lt;T,len&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//如下是三个类</span><br><span class="line">	Array&lt;string,100&gt; array;</span><br><span class="line">	Array&lt;string,101&gt; array1;</span><br><span class="line">	Array&lt;string,102&gt; array2;</span><br><span class="line"></span><br><span class="line">	array[0] = &quot;小0&quot;;</span><br><span class="line">	array[1] = &quot;小1&quot;;</span><br><span class="line">	array[2] = &quot;小2&quot;;</span><br><span class="line">	array[3] = &quot;小3&quot;;</span><br><span class="line">	array[4] = &quot;小4&quot;;</span><br><span class="line">	array[5] = &quot;小5&quot;;</span><br><span class="line">	array[6] = &quot;小6&quot;;</span><br><span class="line">	array[7] = &quot;小7&quot;;</span><br><span class="line">	array[8] = &quot;小8&quot;;</span><br><span class="line">	array[9] = &quot;小9&quot;;</span><br><span class="line">	array[10] = &quot;小10&quot;;</span><br><span class="line">	array[11] = &quot;小11&quot;;</span><br><span class="line">	array[12] = &quot;小12&quot;;</span><br><span class="line">	</span><br><span class="line">	for (int i = 0; i &lt; 13; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; array[i].c_str() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类模板可以有非通用类型参数：1.通常是整型(C++20标准可以用其它)；2.实例化模板必须用常量表达式；3.模板中不能修改参数的值<br>优点：在栈上分配内存，以维护，执行速度快，合适小型数组<br>缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类,导致程序的二进制代码会更大，运行的时候，占用的内存空间也更多，Vector_Array容器效率虽然不如Array容器，但是更通用，还可以自动扩展，也不会存在Array容器创建多个类定义的情况.<br>构造函数的方法更通用，因为数据的大小是类的成员(而不是硬编码)，可以创建数组大小可变的类。</p>
<figure class="highlight plaintext"><figcaption><span>变长数组容器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int len;</span><br><span class="line">	T* items;	//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Vector_Array(int size = 10);</span><br><span class="line">	~Vector_Array();</span><br><span class="line">	void resize(int size);//扩展数组内存空间</span><br><span class="line">	int size_Array(void) const;//数组长度</span><br><span class="line">	const T&amp; operator[](int idenx) const;	//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">	T&amp; operator[](int idenx);	//重载操作符[], 可以修改数组中的元素</span><br><span class="line">	/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">	如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">	注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">	可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">	//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">	this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] this-&gt;items;</span><br><span class="line">	this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">	T* temp = nullptr;</span><br><span class="line">	int i = 0;</span><br><span class="line">	if (size &lt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		temp = new T[size];</span><br><span class="line">		for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp[i] = this-&gt;items[i];</span><br><span class="line">		&#125;</span><br><span class="line">		delete[] this-&gt;items;</span><br><span class="line">		this-&gt;items = temp;</span><br><span class="line">		this-&gt;len = size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">	if (index &gt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Vector_Array&lt;string&gt;array(5);</span><br><span class="line">	array[0] = &quot;小11&quot;;</span><br><span class="line">	array[1] = &quot;小12&quot;;</span><br><span class="line">	array[2] = &quot;小13&quot;;</span><br><span class="line">	array[3] = &quot;小14&quot;;</span><br><span class="line">	array[4] = &quot;小15&quot;;</span><br><span class="line">	array[5] = &quot;小16&quot;;</span><br><span class="line">	array[6] = &quot;小17&quot;;</span><br><span class="line">	array[7] = &quot;小18&quot;;</span><br><span class="line">	array[8] = &quot;小19&quot;;</span><br><span class="line">	array[9] = &quot;小110&quot;;</span><br><span class="line">	array[10] =&quot;小111&quot;;</span><br><span class="line">	array[11] =&quot;小112&quot;;</span><br><span class="line">	array[12] =&quot;小113&quot;;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; &quot;array.size_Array() = &quot; &lt;&lt; array.size_Array() &lt;&lt; endl;</span><br><span class="line">	for (int i = 0; i &lt; array.size_Array(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;array[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; array[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="26-类模板-嵌套和递归使用模板类"><a href="#26-类模板-嵌套和递归使用模板类" class="headerlink" title="26.类模板-嵌套和递归使用模板类"></a>26.类模板-嵌套和递归使用模板类</h4><p>1.容器中有容器<br>2.数组的元素可以是栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	DataType *items;</span><br><span class="line">	int top;</span><br><span class="line">	int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Stack(int size = 3);</span><br><span class="line">	~Stack();</span><br><span class="line">	bool isempty();	//判断栈是否为空。</span><br><span class="line">	bool isfull();	//判断栈是否以满</span><br><span class="line">	bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">	bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">	Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;top = 0;</span><br><span class="line">	this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;</span><br><span class="line">	this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()	//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">	return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()	//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">	return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">	if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">	if (this-&gt;top &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		item = this-&gt;items[--this-&gt;top];</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;			//释放原内存</span><br><span class="line">	this-&gt;stacksize = v.stacksize;	//栈实际的大小</span><br><span class="line">	this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">	for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[ii] = v.items[ii];</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;top = v.top;//栈顶指针</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int len;</span><br><span class="line">	T* items;	//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Vector_Array(int size = 2);</span><br><span class="line">	~Vector_Array();</span><br><span class="line">	void resize(int size);//扩展数组内存空间</span><br><span class="line">	int size_Array(void) const;//数组长度</span><br><span class="line">	const T&amp; operator[](int idenx) const;	//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">	T&amp; operator[](int idenx);	//重载操作符[], 可以修改数组中的元素</span><br><span class="line">	/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">	如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">	注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">	可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">	Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">	//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">	this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] this-&gt;items;</span><br><span class="line">	this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">	T* temp = nullptr;</span><br><span class="line">	int i = 0;</span><br><span class="line">	if (size &lt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		temp = new T[size];</span><br><span class="line">		for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp[i] = this-&gt;items[i];</span><br><span class="line">		&#125;</span><br><span class="line">		delete[] this-&gt;items;</span><br><span class="line">		this-&gt;items = temp;</span><br><span class="line">		this-&gt;len = size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">	if (index &gt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;resize(index + 10);//扩展数组长度</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;</span><br><span class="line">	this-&gt;len = v.len;</span><br><span class="line">	this-&gt;items = new T[this-&gt;len];</span><br><span class="line">	for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[ii] = v.items[ii];</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">	Vector_Array&lt; Stack&lt;string&gt; &gt; vs;</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">	vs[0].push(&quot;小婷0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[0].push(&quot;小明0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[0].push(&quot;小雯0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[1].push(&quot;小婷1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[1].push(&quot;小明1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[1].push(&quot;小雯1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[2].push(&quot;小婷2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[2].push(&quot;小明2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[2].push(&quot;小雯2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[3].push(&quot;小婷3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[3].push(&quot;小明3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[3].push(&quot;小雯3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[4].push(&quot;小婷4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[4].push(&quot;小明4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[4].push(&quot;小雯4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[5].push(&quot;小婷5&quot;);	//vs容器中的第5个栈</span><br><span class="line">	vs[5].push(&quot;小明5&quot;);	//vs容器中的第5个栈</span><br><span class="line">	vs[5].push(&quot;小雯5&quot;);	//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">	for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">	&#123;</span><br><span class="line">		while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">		&#123;</span><br><span class="line">			string item;</span><br><span class="line">			vs[ii].pop(item);</span><br><span class="line">			cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.栈中的元素可以是数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	DataType *items;</span><br><span class="line">	int top;</span><br><span class="line">	int stacksize;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Stack(int size = 3);</span><br><span class="line">	~Stack();</span><br><span class="line">	bool isempty();	//判断栈是否为空。</span><br><span class="line">	bool isfull();	//判断栈是否以满</span><br><span class="line">	bool push(const DataType&amp;item);//元素入栈</span><br><span class="line">	bool pop(DataType &amp;item);//元素出栈</span><br><span class="line">	Stack &amp;operator=(const Stack &amp;v);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::Stack(int size):stacksize(size)</span><br><span class="line">&#123;</span><br><span class="line">	this-&gt;top = 0;</span><br><span class="line">	this-&gt;items = new DataType[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt;::~Stack()</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;</span><br><span class="line">	this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isempty()	//判断栈是否为空。</span><br><span class="line">&#123;</span><br><span class="line">	return (this-&gt;top == 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::isfull()	//判断栈是否以满</span><br><span class="line">&#123;</span><br><span class="line">	return (this-&gt;top == this-&gt;stacksize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::push(const DataType&amp;item)//元素入栈</span><br><span class="line">&#123;</span><br><span class="line">	if (this-&gt;top &lt; this-&gt;stacksize)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[this-&gt;top++] = item;</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">bool Stack&lt;DataType&gt;::pop(DataType &amp;item)//元素出栈</span><br><span class="line">&#123;</span><br><span class="line">	if (this-&gt;top &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		item = this-&gt;items[--this-&gt;top];</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class DataType&gt;</span><br><span class="line">Stack&lt;DataType&gt; &amp;Stack&lt;DataType&gt;::operator=(const Stack &amp;v)</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;			//释放原内存</span><br><span class="line">	this-&gt;stacksize = v.stacksize;	//栈实际的大小</span><br><span class="line">	this-&gt;items = new DataType[v.stacksize];//重新分配数组</span><br><span class="line">	for (int ii = 0; ii &lt; this-&gt;stacksize; ii++)//复制数组中的元素</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[ii] = v.items[ii];</span><br><span class="line">	&#125;</span><br><span class="line">	this-&gt;top = v.top;//栈顶指针</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------------------</span><br><span class="line">template&lt;class T&gt;//类模板可以支持非通用类</span><br><span class="line">class Vector_Array</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int len;</span><br><span class="line">	T* items;	//数组元素</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	Vector_Array(int size = 2);</span><br><span class="line">	~Vector_Array();</span><br><span class="line">	void resize(int size);//扩展数组内存空间</span><br><span class="line">	int size_Array(void) const;//数组长度</span><br><span class="line">	const T&amp; operator[](int idenx) const;	//重载操作符[], 可以修改数组中的元素</span><br><span class="line"></span><br><span class="line">	T&amp; operator[](int idenx);	//重载操作符[], 可以修改数组中的元素</span><br><span class="line">	/*重载下表操作夫的函数也需要修改，需要加自动扩展数组功能，</span><br><span class="line">	如果访问数组的下标超出了数组长度，就扩展数组</span><br><span class="line">	注意：扩展数组参数可以调整，如果每次只扩展一位数据，就会频繁操作分配和释放内存，</span><br><span class="line">	可以一次扩展多个。*/</span><br><span class="line"></span><br><span class="line">	Vector_Array &amp; operator=(const Vector_Array &amp; v);//重载复制运算符函数</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">protected:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::Vector_Array(int size) :len(size)</span><br><span class="line">&#123;</span><br><span class="line">	//memset(this-&gt;items,0,sizeof(this-&gt;items));</span><br><span class="line">	this-&gt;items = new T[this-&gt;len];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt;::~Vector_Array()</span><br><span class="line">&#123;</span><br><span class="line">	delete[] this-&gt;items;</span><br><span class="line">	this-&gt;items = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">void Vector_Array&lt;T&gt;::resize(int size)//扩展数组内存空间</span><br><span class="line">&#123;</span><br><span class="line">	T* temp = nullptr;</span><br><span class="line">	int i = 0;</span><br><span class="line">	if (size &lt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		temp = new T[size];</span><br><span class="line">		for (i = 0; i &lt; this-&gt;len; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			temp[i] = this-&gt;items[i];</span><br><span class="line">		&#125;</span><br><span class="line">		delete[] this-&gt;items;</span><br><span class="line">		this-&gt;items = temp;</span><br><span class="line">		this-&gt;len = size;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">int Vector_Array&lt;T&gt;::size_Array(void) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">const T&amp; Vector_Array&lt;T&gt;::operator[](int index) const</span><br><span class="line">&#123;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">T&amp; Vector_Array&lt;T&gt;::operator[](int index)</span><br><span class="line">&#123;</span><br><span class="line">	if (index &gt;= this-&gt;len)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;resize(index + 2);//扩展数组长度</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	return this-&gt;items[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">Vector_Array&lt;T&gt; &amp; Vector_Array&lt;T&gt;::operator=(const Vector_Array &amp; v)//重载复制运算符函数</span><br><span class="line">&#123;</span><br><span class="line">	delete[]this-&gt;items;</span><br><span class="line">	this-&gt;len = v.len;</span><br><span class="line">	this-&gt;items = new T[this-&gt;len];</span><br><span class="line">	for (int ii = 0; ii &lt; this-&gt;len; ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		this-&gt;items[ii] = v.items[ii];</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//Vector_Array容器的大小缺省值是2，Stack容器的大小缺省值是3</span><br><span class="line">	Vector_Array&lt; Stack&lt;string&gt; &gt; vs;//数组中有栈</span><br><span class="line">//创建Vector_Array容器,容器中的元素用Stack</span><br><span class="line"></span><br><span class="line">//手工的往容器中插入数据</span><br><span class="line">	vs[0].push(&quot;小婷0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[0].push(&quot;小明0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[0].push(&quot;小雯0&quot;);	//vs容器中的第0个栈</span><br><span class="line">	vs[1].push(&quot;小婷1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[1].push(&quot;小明1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[1].push(&quot;小雯1&quot;);	//vs容器中的第1个栈</span><br><span class="line">	vs[2].push(&quot;小婷2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[2].push(&quot;小明2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[2].push(&quot;小雯2&quot;);	//vs容器中的第2个栈</span><br><span class="line">	vs[3].push(&quot;小婷3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[3].push(&quot;小明3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[3].push(&quot;小雯3&quot;);	//vs容器中的第3个栈</span><br><span class="line">	vs[4].push(&quot;小婷4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[4].push(&quot;小明4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[4].push(&quot;小雯4&quot;);	//vs容器中的第4个栈</span><br><span class="line">	vs[5].push(&quot;小婷5&quot;);	//vs容器中的第5个栈</span><br><span class="line">	vs[5].push(&quot;小明5&quot;);	//vs容器中的第5个栈</span><br><span class="line">	vs[5].push(&quot;小雯5&quot;);	//vs容器中的第5个栈</span><br><span class="line"></span><br><span class="line">//用嵌套的循环，把容器中的数据显示出来</span><br><span class="line">	for (int ii = 0; ii &lt; vs.size_Array(); ii++)//遍历Vector_Array容器</span><br><span class="line">	&#123;</span><br><span class="line">		while(!vs[ii].isempty())//遍历Stack容器</span><br><span class="line">		&#123;</span><br><span class="line">			string item;</span><br><span class="line">			vs[ii].pop(item);</span><br><span class="line">			cout &lt;&lt; &quot;item = &quot; &lt;&lt; item.c_str() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">//创建Stack容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">	Stack&lt;Vector_Array&lt;string&gt;&gt;	sv;//栈中有数组</span><br><span class="line">	</span><br><span class="line">	Vector_Array&lt;string&gt; temp;	//栈的元素，临时Vector&lt;string&gt;容器</span><br><span class="line">	//第一个入栈的元素</span><br><span class="line">	temp[0] = &quot;西施1&quot;; temp[1] = &quot;西施2&quot;;	sv.push(temp);</span><br><span class="line">	//第二个入栈的元素</span><br><span class="line">	temp[0] = &quot;西瓜1&quot;; temp[1] = &quot;西瓜2&quot;;	sv.push(temp);</span><br><span class="line">	//第三个入栈的元素</span><br><span class="line">	temp[0] = &quot;冰冰1&quot;; temp[1] = &quot;冰冰2&quot;; temp[2] = &quot;冰冰3&quot;; temp[3] = &quot;冰冰4&quot;; sv.push(temp);</span><br><span class="line"></span><br><span class="line">	Vector_Array&lt;string&gt; temp_pop;</span><br><span class="line">	while (sv.isempty() == false)</span><br><span class="line">	&#123;</span><br><span class="line">		sv.pop(temp_pop);//出栈一个元素，放在临时容器中</span><br><span class="line"></span><br><span class="line">		for (int ii = 0; ii &lt; temp_pop.size_Array(); ii++)//遍历临时Vector_Array&lt;string&gt;容器，显示容器中每个元素的值</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; &quot;vt[&quot; &lt;&lt; ii &lt;&lt; &quot;] = &quot; &lt;&lt; temp_pop[ii].c_str() &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//创建Vector_Array容器，容器中的元素用Vector_Array&lt;string&gt;</span><br><span class="line">	Vector_Array&lt;Vector_Array&lt;string&gt;&gt; vv;	//递归使用模板类</span><br><span class="line">	//char a[][]//二维指针，是连续内存</span><br><span class="line">	//char *a[] -&gt; char b[]递归模板类 是先创建一个指针数组，指针数组元素再指向一个数组</span><br><span class="line">	//二维数组大小固定，这一个大小是可变的</span><br><span class="line">	vv[0][0] = &quot;西施1&quot;; vv[0][1] = &quot;西施2&quot;; vv[0][2] = &quot;西施3&quot;;</span><br><span class="line">	vv[1][0] = &quot;西瓜1&quot;; vv[1][1] = &quot;西瓜2&quot;;</span><br><span class="line">	vv[2][0] = &quot;冰冰1&quot;; vv[2][1] = &quot;冰冰2&quot;; vv[2][2] = &quot;冰冰3&quot;; vv[2][3] = &quot;冰冰4&quot;;</span><br><span class="line"></span><br><span class="line">	for (int ii = 0; ii &lt; vv.size_Array(); ii++)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int jj = 0; jj &lt; vv[ii].size_Array(); jj++)</span><br><span class="line">		&#123;</span><br><span class="line">			//cout &lt;&lt; &quot;vv[&quot; &lt;&lt; ii &lt;&lt; &quot;][&quot; &lt;&lt; jj &lt;&lt; &quot;]= &quot; &lt;&lt; vv[ii][jj].c_str() &lt;&lt; endl;</span><br><span class="line">			cout &lt;&lt; vv[ii][jj].c_str() &lt;&lt; &quot;  &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C++11 之前 嵌套使用模板类的时候 &gt; &gt;之间要加空格。</p>
<h4 id="27-类模板-模板类具体化"><a href="#27-类模板-模板类具体化" class="headerlink" title="27.类模板-模板类具体化"></a>27.类模板-模板类具体化</h4><p>模板类具体化(特化、特例化)有两种：完全具体化和部分具体化。</p>
<p>完全具体化：语法和函数模板集体化是相似的，template关键字，一对空的尖括号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line">	</span><br><span class="line">	AA(const T1 x, const T2 y):m_x(x),m_y(y)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板完全具体化 模板类AA的一个完全具体化版本*/</span><br><span class="line">template&lt;&gt; </span><br><span class="line">class AA&lt;int, string&gt; </span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	int m_x;</span><br><span class="line">	string m_y;</span><br><span class="line">	AA(int x, string y) :m_x(x), m_y(y)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;完全具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void AA&lt;int,string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;完全具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>部分具体化：函数模板没有部分具体化说法，只有类模板才有,<br>部分具体化的意思是：为多个模板参数的部分参数指定具体的数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/*类模板*/</span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line">	</span><br><span class="line">	AA(T1 x, T2 y):m_x(x),m_y(y)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;类模板：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;类模板：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*类模板部分具体化 模板类AA的一个部分具体化版本*/</span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">class AA&lt;T1, string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	string m_y;</span><br><span class="line">	AA(const T1 x, const string y) :m_x(x), m_y(y)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;部分具体化：构造函数。&quot; &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	void show()const;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1&gt;</span><br><span class="line">void AA&lt;T1, string&gt;::show() const</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;部分具体化：x = &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y = &quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>调用示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AA&lt;int, string&gt; aa_1(8, &quot;完全具体化类模板&quot;);</span><br><span class="line">	aa_1.show();</span><br><span class="line"></span><br><span class="line">	AA&lt;char, string&gt; aa_2(8, &quot;部分具体化类模板&quot;);</span><br><span class="line">	aa_2.show();</span><br><span class="line"></span><br><span class="line">	AA&lt;char, int&gt; aa_3(8, 8);</span><br><span class="line">	aa_3.show();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用模板规则：具体化程度高 &gt; 集体化程度低 &gt; 没有具体化的类；主要看匹配</p>
<h4 id="28-类模板-模板类与继承"><a href="#28-类模板-模板类与继承" class="headerlink" title="28.类模板-模板类与继承"></a>28.类模板-模板类与继承</h4><p>1）模板类继承普通类（常见）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	AA(int a);</span><br><span class="line">	~AA();</span><br><span class="line">	void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a):m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1,class T2&gt;</span><br><span class="line">class BB :public AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	BB(T1 x, T2 y, int a);</span><br><span class="line">	~BB();</span><br><span class="line">	void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1,T2&gt;::BB(T1 x,T2 y,int a):AA(a),m_x(x),m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;, 9);</span><br><span class="line">	bb_1.func2();</span><br><span class="line">	bb_1.func1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）普通类继承模板类的实例版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	BB(T1 x, T2 y);</span><br><span class="line">	~BB();</span><br><span class="line">	void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AA: public BB&lt;int,string&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	AA(int a, int x, string y);</span><br><span class="line">	~AA();</span><br><span class="line">	void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA::AA(int a,int x,string y):m_a(a),BB(x,y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AA::~AA()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AA::func1()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	//BB&lt;int, string&gt; bb_1(8, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	//bb_1.func2();</span><br><span class="line"></span><br><span class="line">	AA aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	aa_1.func1();</span><br><span class="line">	aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）普通类继承模板类（常见） 要把普通类也变成模板类：注意的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	BB(T1 x, T2 y);</span><br><span class="line">	~BB();</span><br><span class="line">	void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	AA(int a, const T1 x, const T2 y);</span><br><span class="line">	~AA();</span><br><span class="line">	void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AA&lt;int,string&gt; aa_1(1, 2, &quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	aa_1.func1();</span><br><span class="line">	aa_1.func2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）模板类继承模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	BB(T1 x, T2 y);</span><br><span class="line">	~BB();</span><br><span class="line">	void func2();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::BB(T1 x, T2 y) :m_x(x), m_y(y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">BB&lt;T1, T2&gt;::~BB()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了BB析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void BB&lt;T1, T2&gt;::func2()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func2()函数:x= &quot; &lt;&lt; this-&gt;m_x &lt;&lt; &quot;  ,y=&quot; &lt;&lt; this-&gt;m_y.c_str() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">class AA: public BB&lt;T1, T2&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	AA(int a, const T1 x, const T2 y);</span><br><span class="line">	~AA();</span><br><span class="line">	void func1();</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	int m_a;</span><br><span class="line">private:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1,T2&gt;::AA(int a, const T1 x,const T2 y):m_a(a),BB&lt;T1,T2&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt;::~AA()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了AA析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;class T1, class T2&gt;</span><br><span class="line">void AA&lt;T1, T2&gt;::func1()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func1()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2,class T3&gt;</span><br><span class="line">class CC : public BB&lt;T2, T3&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_a;</span><br><span class="line">public:</span><br><span class="line">	CC(T1 a, T2 x, T3 y);</span><br><span class="line">	~CC();</span><br><span class="line">	void func3();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1,T2 ,T3&gt;::CC(T1 a,T2 x,T3 y):m_a(a), BB&lt;T2,T3&gt;(x,y)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了CC的构造函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">CC&lt;T1, T2, T3&gt;::~CC()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了CC析构函数\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;class T1, class T2, class T3&gt;</span><br><span class="line">void CC&lt;T1, T2, T3&gt;::func3()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;调用了func3()函数： m_a = &quot; &lt;&lt; this-&gt;m_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	CC&lt;int ,int ,string&gt; cc_1(4,5,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	cc_1.func2();</span><br><span class="line">	cc_1.func3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）模板类继承模板类参数给出的基类（不能是模板类）关注 <code>EE</code> 类 EE既是模板类，也是派生类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	AA() &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	AA(int a) &#123; cout &lt;&lt; &quot;调用了AA的构造函数AA(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	~AA() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class BB</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	BB() &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	BB(int a) &#123; cout &lt;&lt; &quot;调用了BB的构造函数BB(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	~BB() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CC</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	CC() &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	CC(int a) &#123; cout &lt;&lt; &quot;调用了CC的构造函数CC(int a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	~CC() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class DD</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	DD() &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	DD(int a) &#123; cout &lt;&lt; &quot;调用了DD的构造函数DD(T a)&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	~DD() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;class T&gt;</span><br><span class="line">class EE:public T	//模板类继承模板阐述给出的基类</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	EE():T() &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">	EE(int a):T(a) &#123; cout &lt;&lt; &quot;调用了EE的构造函数EE(int a)&quot; &lt;&lt; endl; &#125;//模板参数T调用基类构造函数</span><br><span class="line">	~EE() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	EE&lt;AA&gt;		ea1;	//AA作为基类</span><br><span class="line">	EE&lt;BB&gt;		eb1;	//BB作为基类</span><br><span class="line">	EE&lt;CC&gt;		ec1;	//CC作为基类</span><br><span class="line">	EE&lt;DD&lt;int&gt;&gt; ed1;	//DD&lt;int&gt;作为基类 看上去像容器嵌套</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EE继承模板T，也就是他继承的是可以改变的，</p>
<h4 id="29-类模板-模板类与函数"><a href="#29-类模板-模板类与函数" class="headerlink" title="29.类模板-模板类与函数"></a>29.类模板-模板类与函数</h4><p>模板类可以用于函数的参数和返回值，有三种形式<br>1）普通函数，参数和返回值是模板类的实例化版本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA	//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line">public:</span><br><span class="line">	AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">	~AA() &#123;&#125;;</span><br><span class="line">	void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AA&lt;int ,string&gt; func(AA&lt;int,string&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">	aa.show();</span><br><span class="line">	cout &lt;&lt; &quot;调用func(AA&lt;int,string&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">	return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）函数模板，参数和返回值是某种模板类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA	//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line">public:</span><br><span class="line">	AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">	~AA() &#123;&#125;;</span><br><span class="line">	void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板，参数和返回值的是模板类AA，这种不是通用的</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">AA&lt;T1, T2&gt; func(AA&lt;T1, T2&gt; &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">	aa.show();</span><br><span class="line">	cout &lt;&lt; &quot;调用func(AA&lt;T1, T2&gt; &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">	return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3）函数模板，参数和返回值是任意类型（支持普通类和米板类和其它类型）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">template&lt;class T1,class T2&gt;</span><br><span class="line">class AA	//模板类AA</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">	T1 m_x;</span><br><span class="line">	T2 m_y;</span><br><span class="line">public:</span><br><span class="line">	AA(const T1 x, const T2 y) :m_x(x), m_y(y) &#123;&#125;</span><br><span class="line">	~AA() &#123;&#125;;</span><br><span class="line">	void show() const &#123; cout &lt;&lt; &quot;show() x =&quot; &lt;&lt; m_x &lt;&lt; &quot;  , y = &quot; &lt;&lt; m_y.c_str() &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//函数模板类，参数和返回值都是任意类型</span><br><span class="line">template&lt;typename T1&gt;</span><br><span class="line">T1 func(T1 &amp;aa)</span><br><span class="line">&#123;</span><br><span class="line">	aa.show();</span><br><span class="line">	cout &lt;&lt; &quot;调用func(T1 &amp;aa)函数&quot; &lt;&lt; endl;</span><br><span class="line">	return aa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AA&lt;char, string&gt; aa(3,&quot;我是一只傻傻鸟&quot;);</span><br><span class="line">	func(aa);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种方法更规范，支持所有的类或者普通函数，第二种方法只支持AA这一种模板类，函数模板不管传入什么，只要符合函数内部程序就可以</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>开源不易</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="https://s2.loli.net/2022/05/11/mgOt58vuhD3PYkE.png" alt="构造 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"><i class="fa fa-tag"></i> C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/09/11/MDK%20KEIL/MDK%20KEIL%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89XXX/" rel="prev" title="MDK KEIL添加自定义XXX">
                  <i class="fa fa-chevron-left"></i> MDK KEIL添加自定义XXX
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/10/31/MDK%20KEIL/MDK%20KEIL%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B7%A5%E7%A8%8B-%E5%A4%9A%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/" rel="next" title="MDK KEIL创建多项目-多工程编译">
                  MDK KEIL创建多项目-多工程编译 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





  <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束 <i class="fa fa-heart"></i> 感谢阅读-------------</div>



    <div class="comments" id="SOHUCS" sid="3a940a97979c391c27ed09f3ee2aee82"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">构造</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">285k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:19</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>本站访客数
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span> 人次
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>本站总访问量
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span> 次
      </span>
    </span>
</div>




    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>
<script class="next-config" data-name="gitter" type="application/json">{"enable":true,"room":"hexo_Online_discussion/community"}</script>
<script src="/js/third-party/chat/gitter.js"></script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

  <script class="next-config" data-name="pdf" type="application/json">{"object_url":{"url":"https://cdn.jsdelivr.net/npm/pdfobject@2.2.7/pdfobject.min.js","integrity":"sha256-ph3Dk89VmuTVXG6x/RDzk53SU9LPdAh1tpv0UvnDZ2I="},"url":"/lib/pdf/web/viewer.html"}</script>
  <script src="/js/third-party/tags/pdf.js"></script>

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js","integrity":"sha256-7wT34TI0pEBeEFoi4z+vhuSddGh6vUTMWdqJ2SDe2jg="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>

  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="changyan" type="application/json">{"enable":true,"appid":"cyw3VyumL","appkey":"e9ff69b1f44325f8c6d24a15fdf89113"}</script>
<script src="/js/third-party/comments/changyan.js"></script>

</body>
</html>
